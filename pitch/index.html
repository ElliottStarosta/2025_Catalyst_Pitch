<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Senergy</title>
  <link rel="icon" href="public/logo-icon-blue.png" type="image/png" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    :root {
      --primary-color: #1f3b73;
      --primary-color-hover: #16305f;

      --secondary-color: #4a90e2;
      --secondary-color-hover: #3b7dd3;
      --background-color: #ffffff;
      --background-alt-color: #fafafa;

      --text-color: #1a1a1a;
      --muted-text-color: #555555;
      --inverted-text-color: #ffffff;

      --border-color: #e0e0e0;

      --primary-gradient: linear-gradient(135deg, #1f3b73, #4a90e2);
      --secondary-gradient: linear-gradient(135deg, #4a90e2, #a0c8f0);
      --accent-gradient: linear-gradient(135deg, #7bede7, #7971f3);
      --background-gradient: linear-gradient(180deg, #ffffff, #fafafa);

      --shadow-small: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-medium: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-large: 0 10px 15px rgba(0, 0, 0, 0.15);

      --border-radius-small: 4px;
      --border-radius-medium: 8px;
      --border-radius-large: 12px;

      --success-color: #27ae60;
      --error-color: #e74c3c;
      --warning-color: #f39c12;
      --info-color: #3498db;

      --transition: all 0.3s ease;
      --blue-bg: rgba(74, 144, 226, 0.08);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", "Inter", -apple-system, BlinkMacSystemFont,
        sans-serif;
      background: var(--background-color);
      min-height: 100vh;
      color: var(--text-color);
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Modern navbar */
    .navbar {
      background: var(--background-color);
      padding: 1.2rem 2rem;
      margin: 2rem 0;
      border-radius: var(--border-radius-large);
      box-shadow: var(--shadow-medium);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 20px;
      z-index: 100;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 800;

      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .nav-links {
      display: flex;
      gap: 1.5rem;
      list-style: none;
    }

    .nav-links a {
      text-decoration: none;
      color: var(--text-color);
      font-weight: 500;
      transition: var(--transition);
      position: relative;
      padding: 8px 0;
      font-size: 1rem;
    }

    .nav-links a::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 3px;
      background: var(--accent-gradient);
      border-radius: var(--border-radius-small);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform: translateX(-50%);
    }

    .nav-links a:hover {
      color: var(--secondary-color);
    }

    .nav-links a:hover::after {
      width: 100%;
    }

    .nav-links a.active {
      color: var(--secondary-color);
      font-weight: 600;
    }

    .nav-links a.active::after {
      width: 100%;
    }

    /* Card styling */
    .card {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 2.5rem;
      margin-bottom: 2.5rem;
      box-shadow: var(--shadow-medium);
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: var(--shadow-large);
    }

    .card-header {
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .card-header h2 {
      font-size: 1.8rem;
      color: var(--text-color);
      margin-bottom: 0.5rem;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .card-header p {
      color: var(--muted-text-color);
      max-width: 700px;
      margin: 0 auto;
    }

    .hidden {
      display: none;
    }

    /* Buttons */
    .btn {
      background: var(--primary-gradient);
      color: var(--inverted-text-color);
      border: none;
      padding: 14px 28px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s ease;
      margin: 0.5rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: var(--shadow-small);
      line-height: 1;
      /* Fix extra vertical space inside buttons */
    }

    /* Ensure icons inside buttons don't increase vertical height */
    .btn i {
      line-height: 1;
    }

    /* Tighter spacing for buttons inside cards */
    .user-card .btn,
    .experience-card .btn {
      margin: 0;
    }

    /* Stabilize action area height to prevent jitter on state changes */
    .user-actions {
      min-height: 36px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-medium);
      filter: brightness(1.1);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn:disabled {
      background: var(--border-color);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: var(--background-alt-color);
      color: var(--text-color);
      border: 2px solid var(--border-color);
      box-shadow: none;
    }

    .btn-secondary:hover {
      background: var(--border-color);
      transform: translateY(-3px);
      box-shadow: var(--shadow-small);
    }

    .btn-danger {
      background: linear-gradient(135deg, var(--error-color) 0%, #c0392b 100%);
      color: var(--inverted-text-color);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--secondary-color) 0%, #2980b9 100%);
      color: var(--inverted-text-color);
    }

    .btn-info {
      background: linear-gradient(135deg, var(--info-color) 0%, #2980b9 100%);
      color: var(--inverted-text-color);
    }

    .btn-google {
      background: white;
      color: #333;
      border: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-weight: 500;
      margin-top: 10px;
    }

    .btn-google:hover {
      background: #f8f9fa;
      border-color: #ccc;
      transform: translateY(-2px);
      box-shadow: var(--shadow-small);
    }

    /* Professional Minimalistic Auth Styles */
    .auth-container {
      max-width: 400px;
      margin: 2rem auto;
      padding: 2.5rem;
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      box-shadow: var(--shadow-medium);
      border: 1px solid var(--border-color);
      transition: var(--transition);
    }

    .auth-container:hover {
      box-shadow: var(--shadow-large);
    }

    .auth-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .auth-header h2 {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--text-color);
      margin: 0 0 0.5rem 0;
      letter-spacing: -0.025em;
    }

    .auth-header p {
      color: var(--muted-text-color);
      font-size: 0.95rem;
      margin: 0;
      line-height: 1.5;
    }

    .auth-step {
      width: 100%;
    }

    .auth-input {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 500;
      background: var(--background-color);
      color: var(--text-color);
      transition: all 0.2s ease;
      margin-bottom: 1rem;
    }

    .auth-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(31, 59, 115, 0.1);
    }

    .auth-input::placeholder {
      color: #9ca3af;
      font-weight: 400;
    }

    textarea.auth-input {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    .auth-btn-primary {
      width: 100%;
      padding: 14px 20px;
      background: var(--primary-gradient);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 1.5rem;
      letter-spacing: 0.025em;
    }

    .auth-btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 25px rgba(31, 59, 115, 0.25);
    }

    .auth-btn-primary:active {
      transform: translateY(0);
    }

    .auth-divider {
      text-align: center;
      margin: 1.5rem 0;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .auth-divider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: #6b7280;
    }

    .auth-divider span {
      background: var(--background-color);
      padding: 0 1rem;
      color: #6b7280;
      font-size: 0.875rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      position: relative;
      z-index: 1;
    }

    .oauth-buttons {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .oauth-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 12px 16px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      background: var(--background-color);
      color: var(--text-color);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .oauth-btn:hover {
      border-color: var(--primary-color);
      background: var(--blue-bg);
      transform: translateY(-1px);
    }

    .oauth-btn svg {
      flex-shrink: 0;
    }

    .auth-back {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding: 0.75rem;
      background: var(--background-alt-color);
      border-radius: 12px;
    }

    .back-btn {
      background: none;
      border: none;
      color: var(--muted-text-color);
      font-size: 1rem;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 8px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .back-btn:hover {
      background: var(--border-color);
      color: var(--text-color);
    }

    .back-info span {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-color);
    }

    .password-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .password-toggle-btn {
      position: absolute;
      right: 12px;
      background: none;
      border: none;
      color: var(--muted-text-color);
      cursor: pointer;
      padding: 0.5rem;
      font-size: 1rem;
      transition: all 0.2s ease;
      border-radius: 6px;
    }

    .password-toggle-btn:hover {
      color: var(--text-color);
      background: var(--background-alt-color);
    }

    .password-input-wrapper .auth-input {
      padding-right: 3rem;
      margin-bottom: 0;
    }

    .auth-footer {
      text-align: center;
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border-color);
    }

    .auth-footer p {
      margin: 0;
      color: var(--muted-text-color);
      font-size: 0.875rem;
    }

    .auth-footer a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .auth-footer a:hover {
      color: var(--primary-color-hover);
      text-decoration: underline;
    }

    /* Password Strength Indicator */
    .password-strength {
      margin-top: 0.5rem;
      font-size: 0.875rem;
    }

    .password-strength-bar {
      width: 100%;
      height: 4px;
      background: #e5e7eb;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .password-strength-fill {
      height: 100%;
      transition: all 0.3s ease;
      border-radius: 2px;
    }

    .password-strength-text {
      font-weight: 500;
    }

    .strength-weak {
      background: #ef4444;
      width: 25%;
    }

    .strength-fair {
      background: #f59e0b;
      width: 50%;
    }

    .strength-good {
      background: #10b981;
      width: 75%;
    }

    .strength-strong {
      background: #059669;
      width: 100%;
    }

    .text-weak {
      color: #ef4444;
    }

    .text-fair {
      color: #f59e0b;
    }

    .text-good {
      color: #10b981;
    }

    .text-strong {
      color: #059669;
    }

    .form-divider span {
      background: white;
      padding: 0 15px;
      color: #666;
      font-size: 14px;
    }

    /* Personality assessment */
    .question-container {
      margin-bottom: 2.5rem;
      padding: 1.5rem;
      border-radius: var(--border-radius-large);
      background: var(--blue-bg);
    }

    .question-text {
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
      color: var(--text-color);
      text-align: center;
    }

    .scale-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 1.5rem 0;
    }

    .scale-labels {
      display: flex;
      justify-content: space-between;
      width: 100%;
      font-size: 0.95rem;
      color: var(--muted-text-color);
      margin-bottom: 1rem;
      font-weight: 500;
    }

    .radio-group {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    .radio-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: var(--transition);
      padding: 10px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
    }

    .radio-item:hover {
      background: rgba(74, 144, 226, 0.1);
      transform: translateY(-5px);
      box-shadow: var(--shadow-small);
    }

    .radio-item input[type="radio"] {
      appearance: none;
      width: 24px;
      height: 24px;
      border: 2px solid var(--secondary-color);
      border-radius: 50%;
      position: relative;
      cursor: pointer;
      transition: var(--transition);
    }

    .radio-item input[type="radio"]:checked {
      background: var(--secondary-color);
    }

    .radio-item input[type="radio"]:checked::after {
      content: "";
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--inverted-text-color);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .radio-item label {
      margin-top: 0.8rem;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--secondary-color);
    }

    .progress-container {
      margin: 2rem 0;
      padding: 0 1rem;
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(74, 144, 226, 0.2);
      border-radius: var(--border-radius-small);
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--secondary-gradient);
      border-radius: var(--border-radius-small);
      transition: width 0.5s ease;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: var(--muted-text-color);
      font-weight: 500;
    }

    /* Results page */
    .personality-result {
      text-align: center;
      padding: 2rem;
    }

    .personality-score {
      font-size: 4rem;
      font-weight: 800;
      margin: 1.5rem 0;
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .personality-type {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      font-weight: 700;
      color: var(--text-color);
    }

    .personality-description {
      max-width: 600px;
      margin: 0 auto 2rem;
      font-size: 1.1rem;
      color: var(--muted-text-color);
      line-height: 1.7;
    }

    /* Activity cards */
    .activity-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.8rem;
      margin-top: 2rem;
    }

    .activity-card {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 1.8rem;
      box-shadow: var(--shadow-small);
      transition: var(--transition);
      cursor: pointer;
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    .activity-card:hover {
      transform: translateY(-8px);
      box-shadow: var(--shadow-large);
      border-color: var(--secondary-color);
    }

    .activity-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      color: var(--text-color);
    }

    .activity-category {
      color: var(--secondary-color);
      font-size: 0.95rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .activity-details {
      margin-bottom: 1.2rem;
      color: var(--muted-text-color);
      flex-grow: 1;
    }

    .rating-section {
      border-top: 1px solid var(--border-color);
      padding-top: 1.2rem;
      margin-top: 1.2rem;
    }

    .rating-questions {
      margin-bottom: 1.2rem;
    }

    .rating-question {
      margin-bottom: 1.5rem;
    }

    .rating-question label {
      display: block;
      margin-bottom: 0.8rem;
      font-weight: 500;
      color: var(--text-color);
    }

    .rating-slider {
      width: 100%;
      height: 8px;
      border-radius: var(--border-radius-small);
      background: rgba(74, 144, 226, 0.2);
      outline: none;
      appearance: none;
    }

    .rating-slider::-webkit-slider-thumb {
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--secondary-gradient);
      cursor: pointer;
      box-shadow: var(--shadow-small);
      border: 2px solid var(--inverted-text-color);
    }

    .rating-slider::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--primary-gradient);
      cursor: pointer;
      box-shadow: var(--shadow-small);
      border: 2px solid var(--inverted-text-color);
    }

    .slider-value {
      text-align: center;
      font-weight: 700;
      color: var(--muted-text-color);
      margin-top: 0.8rem;
      font-size: 1.1rem;
    }

    .final-score {
      font-size: 1.3rem;
      font-weight: 700;
      text-align: center;
      padding: 1.2rem;
      background: var(--primary-gradient);
      color: var(--inverted-text-color);
      border-radius: var(--border-radius-medium);
      margin-top: 1.5rem;
      box-shadow: var(--shadow-small);
    }

    /* User info */
    .user-info {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 2.5rem;
      background: var(--blue-bg);
      padding: 1.5rem;
      border-radius: var(--border-radius-large);
    }

    .avatar {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: var(--secondary-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--inverted-text-color);
      font-size: 1.8rem;
      font-weight: 700;
      box-shadow: var(--shadow-small);
    }

    .welcome-text {
      font-size: 1.3rem;
      color: var(--text-color);
      font-weight: 500;
    }

    .welcome-text strong {
      font-weight: 700;
      color: var(--primary-color);
    }

    /* Forms */
    .form-group {
      margin-bottom: 1.8rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.8rem;
      font-weight: 600;
      color: var(--text-color);
    }

    .form-control {
      width: 100%;
      padding: 14px 18px;
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius-medium);
      font-size: 1rem;
      transition: var(--transition);
      background: var(--background-color);
      color: var(--text-color);
      font-family: inherit;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(31, 59, 115, 0.2);
    }

    .form-control::placeholder {
      color: var(--muted-text-color);
    }

    .form-control select {
      cursor: pointer;
    }

    textarea.form-control {
      resize: vertical;
      min-height: 120px;
    }

    /* Feed items */
    .feed-item {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 1.8rem;
      margin-bottom: 1.8rem;
      box-shadow: var(--shadow-small);
      transition: var(--transition);
      border: 1px solid var(--border-color);
    }

    .feed-item:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-medium);
    }

    .feed-header {
      display: flex;
      align-items: center;
      gap: 1.2rem;
      margin-bottom: 1.2rem;
    }

    .feed-avatar {
      width: 55px;
      height: 55px;
      border-radius: 50%;
      background: var(--primary-gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--inverted-text-color);
      font-size: 1.3rem;
      font-weight: 700;
      flex-shrink: 0;
    }

    .feed-user-info h4 {
      margin: 0;
      color: var(--text-color);
      font-size: 1.1rem;
    }

    .feed-user-info .personality-type {
      font-size: 0.85rem;
      color: var(--primary-color);
      margin: 0.3rem 0 0;
      font-weight: 600;
    }

    .feed-timestamp {
      font-size: 0.8rem;
      color: var(--muted-text-color);
      margin-top: 0.2rem;
    }

    .feed-content {
      margin-bottom: 1.2rem;
    }

    .feed-rating {
      display: inline-block;
      background: var(--primary-gradient);
      color: var(--inverted-text-color);
      padding: 0.6rem 1.2rem;
      border-radius: 50px;
      font-weight: 700;
      margin-bottom: 1.2rem;
      font-size: 0.95rem;
    }

    .similar-users-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-top: 1.5rem;
    }

    .similar-user-card {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 1.8rem;
      text-align: center;
      box-shadow: var(--shadow-small);
      transition: var(--transition);
      border: 1px solid var(--border-color);
    }

    .similar-user-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-medium);
    }

    .similarity-score {
      background: var(--accent-gradient);
      color: var(--inverted-text-color);
      padding: 0.4rem 1rem;
      border-radius: 50px;
      font-size: 0.85rem;
      font-weight: 700;
      margin-top: 1rem;
      display: inline-block;
    }

    .group-card {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 1.8rem;
      margin-bottom: 1.8rem;
      box-shadow: var(--shadow-small);
      border: 1px solid var(--border-color);
    }

    .group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.2rem;
    }

    .group-members {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
      margin-bottom: 1.2rem;
    }

    .group-members>div:last-child {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    /* Voting system styles */
    .voting-section {
      margin-top: 1.5rem;
      padding: 1.5rem;
      background: var(--background-alt-color);
      border-radius: var(--border-radius-medium);
    }

    .vote-button {
      background: var(--border-color);
      color: var(--text-color);
      border: 2px solid transparent;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 600;
      transition: all 0.3s ease;
      margin: 0 0.5rem 0.5rem 0;
    }

    .vote-button:hover {
      background: var(--muted-text-color);
      color: var(--inverted-text-color);
      transform: translateY(-2px);
    }

    .vote-button.voted {
      background: var(--primary-color);
      color: var(--inverted-text-color);
      border-color: var(--primary-color);
    }

    .most-voted {
      border: 3px solid var(--error-color) !important;
      background: rgba(231, 76, 60, 0.1) !important;
      position: relative;
    }

    .most-voted::before {
      content: "🏆 MOST VOTED";
      position: absolute;
      top: -10px;
      left: 10px;
      background: var(--error-color);
      color: var(--inverted-text-color);
      padding: 4px 12px;
      border-radius: var(--border-radius-medium);
      font-size: 0.7rem;
      font-weight: bold;
    }

    .vote-count {
      font-size: 0.8rem;
      color: var(--muted-text-color);
      margin-top: 0.5rem;
      font-weight: bold;
    }

    .edit-group-btn {
      background: var(--info-color);
      color: var(--inverted-text-color);
      border: none;
      padding: 14px 28px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      margin-right: 0.5rem;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: var(--shadow-small);
    }

    .edit-group-btn:hover {
      background: var(--secondary-color);
      transform: translateY(-3px);
      box-shadow: var(--shadow-medium);
      filter: brightness(1.1);
    }

    .member-tag {
      background: rgba(31, 59, 115, 0.1);
      color: var(--primary-color);
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .prediction-card {
      background: var(--blue-bg);
      border: 2px solid rgba(31, 59, 115, 0.15);
      border-radius: var(--border-radius-medium);
      padding: 1.2rem;
      margin: 1.2rem 0;
    }

    .prediction-score {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--primary-color);
      text-align: center;
      margin-bottom: 0.5rem;
      background: var(--primary-color);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .prediction-confidence {
      text-align: center;
      font-size: 0.95rem;
      color: var(--muted-text-color);
    }

    /* Stats */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1.5rem;
      margin: 1.5rem 0;
    }

    .stat-card {
      text-align: center;
      padding: 1.5rem;
      background: var(--blue-bg);
      border-radius: var(--border-radius-medium);
      transition: var(--transition);
    }

    .stat-card:hover {
      transform: translateY(-5px);
      background: rgba(74, 144, 226, 0.15);
    }

    .stat-value {
      font-size: 2.2rem;
      font-weight: 800;
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }

    .stat-label {
      font-size: 0.95rem;
      color: var(--muted-text-color);
    }

    /* Search */
    .search-box {
      position: relative;
      margin-bottom: 2rem;
    }

    .search-input {
      width: 100%;
      padding: 14px 50px 14px 20px;
      border: 2px solid var(--border-color);
      border-radius: 50px;
      font-size: 1rem;
      background: var(--background-color);
      color: var(--text-color);
      transition: var(--transition);
      font-family: inherit;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(31, 59, 115, 0.2);
    }

    .search-icon {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--primary-color);
      font-size: 1.2rem;
    }

    /* Professional Filter Dropdown System */
    .filter-container {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .filter-dropdown {
      position: relative;
      min-width: 200px;
    }

    .filter-dropdown-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 12px 16px;
      background: var(--background-color);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-color);
      transition: all 0.2s ease;
      min-height: 48px;
    }

    .filter-dropdown-btn:hover {
      border-color: var(--primary-color);
      box-shadow: 0 2px 8px rgba(31, 59, 115, 0.1);
    }

    .filter-dropdown-btn.active {
      border-color: var(--primary-color);
      background: rgba(31, 59, 115, 0.05);
    }

    .filter-dropdown-btn i {
      transition: transform 0.2s ease;
    }

    .filter-dropdown-btn.active i {
      transform: rotate(180deg);
    }

    .filter-dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--background-color);
      border: 2px solid var(--border-color);
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      max-height: 300px;
      overflow-y: auto;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s ease;
    }

    .filter-dropdown-menu.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .filter-dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-dropdown-item:last-child {
      border-bottom: none;
    }

    .filter-dropdown-item:hover {
      background: rgba(31, 59, 115, 0.1);
      color: var(--primary-color);
    }

    .filter-dropdown-item.active {
      background: var(--primary-color);
      color: var(--inverted-text-color);
    }

    .filter-dropdown-item i {
      width: 16px;
      text-align: center;
    }

    /* Legacy filter tabs - keeping for backward compatibility */
    .filter-tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .filter-tab {
      padding: 0.9rem 1.8rem;
      border: 2px solid var(--primary-color);
      border-radius: 50px;
      background: transparent;
      color: var(--primary-color);
      cursor: pointer;
      font-weight: 600;
      transition: var(--transition);
      font-size: 0.95rem;
    }

    .filter-tab.active {
      background: var(--primary-color);
      color: var(--inverted-text-color);
    }

    .filter-tab:hover:not(.active) {
      background: rgba(31, 59, 115, 0.1);
    }

    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--muted-text-color);
    }

    .empty-state h3 {
      margin-bottom: 1rem;
      color: var(--text-color);
      font-size: 1.5rem;
    }

    .empty-state p {
      max-width: 500px;
      margin: 0 auto 1.5rem;
    }

    .centered {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
    }

    .community-section {
      transition: all 0.3s ease;
    }

    .community-nav-tabs {
      text-align: center;
      margin: 2rem 0;
    }

    .community-nav-tabs .btn {
      background: var(--primary-gradient);
      color: white;
      padding: 1rem 2rem;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 12px;
      box-shadow: var(--shadow-medium);
      transition: all 0.3s ease;
      margin: 0 0.5rem;
    }

    .community-nav-tabs .btn.btn-secondary {
      background: var(--background-alt-color);
      color: var(--text-color);
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow-small);
    }

    .community-nav-tabs .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-large);
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    /* GROUPS */
    .modal {
      display: flex;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
      overflow: hidden;
      /* Prevent modal from scrolling */
    }

    /* Prevent body scrolling when modal is open */
    body.modal-open {
      overflow: hidden;
      position: fixed;
      width: 100%;
    }

    /* Custom scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--primary-gradient);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--secondary-gradient);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) #f1f1f1;
    }

    .modal-content {
      background: var(--background-color);
      border-radius: var(--border-radius-large);
      padding: 0;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
      box-shadow: var(--shadow-large);
      animation: slideUp 0.3s ease;
    }

    .modal-header {
      padding: 2rem 2rem 1rem 2rem;
      border-bottom: 1px solid var(--border-color);
    }

    .modal-header h2 {
      margin: 0;
      color: var(--text-color);
      font-size: 1.8rem;
    }

    .modal-body {
      padding: 2rem;
    }

    .modal-close {
      position: absolute;
      top: 20px;
      right: 25px;
      color: var(--muted-text-color);
      font-size: 35px;
      font-weight: bold;
      background: none;
      border: none;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.3s ease;
    }

    .modal-close:hover {
      color: var(--text-color);
      background: rgba(0, 0, 0, 0.1);
      transform: rotate(90deg);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .activity-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 992px) {
      .navbar {
        flex-direction: column;
        gap: 1.2rem;
        padding: 1.5rem;
      }

      .nav-links {
        flex-wrap: wrap;
        justify-content: center;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 15px;
      }

      .card {
        padding: 1.8rem;
      }

      .radio-group {
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
      }

      .activity-grid,
      .stats-grid,
      .similar-users-grid {
        grid-template-columns: 1fr;
      }

      .user-info {
        flex-direction: column;
        text-align: center;
      }

      .group-header {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .action-buttons {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <nav class="navbar">
      <div class="logo">
        <img src="public/logo-icon-blue.png" alt="Social Energy"
          style="width: 50px; height: 50px; border-radius: 6px" />
        Senergy
      </div>
      <ul class="nav-links">
        <li>
          <a href="#" onclick="showPage('dashboard')" id="nav-dashboard">Dashboard</a>
        </li>
        <li>
          <a href="#" onclick="showPage('assessment')" id="nav-assessment">Assessment</a>
        </li>
        <li>
          <a href="#" onclick="showPage('activities')" id="nav-activities">Add Experience</a>
        </li>
        <li>
          <a href="#" onclick="showPage('feed')" id="nav-feed">Community</a>
        </li>
        <li>
          <a href="#" onclick="showPage('groups')" id="nav-groups">Groups</a>
        </li>

        <li>
          <a href="#" onclick="showPage('profile')" id="nav-profile">Profile</a>
        </li>

      </ul>
    </nav>

    <!-- Dashboard Page -->
    <div id="dashboard" class="page hidden">
      <div class="card">
        <div class="user-info">
          <div class="avatar" id="user-avatar">?</div>
          <div>
            <div class="welcome-text" id="welcome-message">
              Welcome! Take the personality assessment to get started.
            </div>
          </div>
        </div>

        <div id="dashboard-content" class="centered">
          <h2>Discover Your Perfect Social Experiences</h2>
          <p style="padding: 1.2rem">
            Find activities that match your energy preferences and connect
            with like-minded people.
          </p>
          <button class="btn" onclick="showPage('assessment')">
            <i class="fas fa-play-circle"></i> Start Assessment
          </button>
        </div>
      </div>
    </div>

    <!-- Personality Assessment Page -->
    <div id="assessment" class="page hidden">
      <div class="card">
        <div class="card-header">
          <h2>Personality Assessment</h2>
          <p>
            Answer these questions to help us understand your social energy
            preferences.
          </p>
        </div>

        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
          </div>
          <div class="progress-info">
            <span id="progress-text">Question 1 of 10</span>
            <span>Understanding your energy</span>
          </div>
        </div>

        <div id="question-container">
          <!-- Questions will be dynamically inserted here -->
        </div>

        <div class="centered">
          <button class="btn" id="next-btn" onclick="nextQuestion()" disabled>
            Next Question <i class="fas fa-arrow-right"></i>
          </button>
        </div>
      </div>
    </div>

    <!-- Assessment Results -->
    <div id="results" class="page hidden">
      <div class="card">
        <div class="personality-result">
          <h2>Your Personality Profile</h2>
          <div class="personality-score" id="personality-score">0.0</div>
          <div class="personality-type" id="personality-type">Ambivert</div>
          <p class="personality-description" id="personality-description">
            You have a balanced approach to social energy.
          </p>
          <button class="btn" onclick="completeAssessment()">
            <i class="fas fa-tachometer-alt"></i> Continue to Dashboard
          </button>
        </div>
      </div>
    </div>

    <!-- Activities Page -->
    <div id="activities" class="page hidden">
      <div class="card">
        <div class="card-header">
          <h2>Add Your Experience</h2>
          <p>
            Share a recent social experience and rate how it affected your
            energy levels.
          </p>
        </div>

        <form id="activity-form" onsubmit="ActivitySystem.submitNewExperience(event)">
          <div class="form-group">
            <label for="activity-name"><i class="fas fa-map-marker-alt"></i> Place/Activity Name
              *</label>
            <input type="text" id="activity-name" class="form-control"
              placeholder="e.g., The Coffee Bean, Central Park, Downtown Nightclub" required />
          </div>

          <div class="form-group">
            <label for="activity-category"><i class="fas fa-tag"></i> Category *</label>
            <select id="activity-category" class="form-control" required>
              <option value="">Select category...</option>
              <option value="Restaurant">Restaurant</option>
              <option value="Bar/Pub">Bar/Pub</option>
              <option value="Nightclub">Nightclub</option>
              <option value="Cafe">Cafe</option>
              <option value="Park/Outdoor">Park/Outdoor</option>
              <option value="Museum/Gallery">Museum/Gallery</option>
              <option value="Shopping">Shopping</option>
              <option value="Entertainment">Entertainment</option>
              <option value="Sports/Fitness">Sports/Fitness</option>
              <option value="Library/Study">Library/Study</option>
              <option value="Event/Party">Event/Party</option>
              <option value="Other">Other</option>
            </select>
          </div>

          <div class="form-group">
            <label for="activity-location"><i class="fas fa-location-dot"></i> Location *</label>
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="activity-location" class="form-control" required
                placeholder="e.g., Downtown, Brooklyn, Central Mall" style="flex: 1;" />
              <button type="button" id="use-current-location-btn" class="btn btn-secondary"
                style="white-space: nowrap; padding: 14px 16px; font-size: 0.9rem;" onclick="useCurrentLocation()">
                <i class="fas fa-crosshairs"></i> Use Current Location
              </button>
            </div>
            <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">
              <i class="fas fa-info-circle"></i> We'll use your location to provide better recommendations and help
              others find places near you.
            </div>
          </div>

          <div class="form-group">
            <label for="activity-description"><i class="fas fa-align-left"></i> Description (Optional)</label>
            <textarea id="activity-description" class="form-control"
              placeholder="Describe the atmosphere, what you did, who you were with..."></textarea>
          </div>

          <div class="form-group">
            <label><i class="fas fa-star"></i> Rate Your Experience:</label>
            <div class="rating-questions" id="new-activity-rating">
              <div class="rating-question">
                <label>How energized did you feel?</label>
                <input type="range" class="rating-slider" min="1" max="10" value="5"
                  oninput="updateSliderValue(this, 'slider-energy')" id="rating-energy" />
                <div class="slider-value" id="slider-energy">5</div>
              </div>
              <div class="rating-question">
                <label>How satisfied were you with the social interaction?
                </label>
                <input type="range" class="rating-slider" min="1" max="10" value="5"
                  oninput="updateSliderValue(this, 'slider-social')" id="rating-social" />
                <div class="slider-value" id="slider-social">5</div>
              </div>
              <div class="rating-question">
                <label>How comfortable did you feel in this environment?
                </label>
                <input type="range" class="rating-slider" min="1" max="10" value="5"
                  oninput="updateSliderValue(this, 'slider-comfort')" id="rating-comfort" />
                <div class="slider-value" id="slider-comfort">5</div>
              </div>
              <div class="rating-question">
                <label>How overwhelming was the environment? (Rate higher if it felt more overwhelming)
                </label>
                <input type="range" class="rating-slider" min="1" max="10" value="5"
                  oninput="updateSliderValue(this, 'slider-overwhelm')" id="rating-overwhelm" />
                <div class="slider-value" id="slider-overwhelm">5</div>
              </div>
              <div class="rating-question">
                <label>How likely are you to return? </label>
                <input type="range" class="rating-slider" min="1" max="10" value="5"
                  oninput="updateSliderValue(this, 'slider-return')" id="rating-return" />
                <div class="slider-value" id="slider-return">5</div>
              </div>
            </div>
          </div>

          <div class="action-buttons">
            <button type="submit" class="btn">
              <i class="fas fa-plus-circle"></i> Add Experience
            </button>
            <button type="button" class="btn btn-secondary" onclick="resetActivityForm()">
              <i class="fas fa-eraser"></i> Clear Form
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Community Feed Page -->
    <div id="feed" class="page hidden">
      <div class="card">
        <div class="card-header">
          <h2>Community</h2>
          <p>
            Discover activities and connect with people in your community.
          </p>
        </div>

        <!-- Community Navigation Tabs -->
        <div class="community-nav-tabs">
          <button class="btn active" onclick="CommunitySystem.showSection('activities')" id="activities-tab">
            <i class="fas fa-star"></i> Activities
          </button>
          <button class="btn btn-secondary" onclick="CommunitySystem.showSection('friendship')" id="friendship-tab"
            style="position: relative;">
            <i class="fas fa-users"></i> Friendship
            <span id="friend-request-badge" style="
              display: none;
              background: #ff4757;
              color: white;
              border-radius: 50%;
              width: 25px;
              height: 25px;
              font-size: 12px;
              display: flex;
              align-items: center;
              justify-content: center;
              position: absolute;
              top: -8px;
              right: -8px;
              font-weight: bold;
              border: 2px solid white;
            ">0</span>
          </button>
        </div>

        <!-- Activities Section -->
        <div id="activities-section" class="community-section">
          <div class="search-box">
            <input type="text" class="search-input" id="feed-search"
              placeholder="Search activities, places, or users..." onkeyup="FeedSystem.filterFeed()" />
            <span class="search-icon"><i class="fas fa-search"></i></span>
          </div>

          <div class="filter-container">
            <div class="filter-dropdown">
              <button class="filter-dropdown-btn" onclick="toggleFilterDropdown('activities-filter')">
                <span id="activities-filter-text">All Activities</span>
                <i class="fas fa-chevron-down"></i>
              </button>
              <div class="filter-dropdown-menu" id="activities-filter-menu">
                <div class="filter-dropdown-item active"
                  onclick="selectFilter('activities', 'all', 'All Activities', this)">
                  <i class="fas fa-list"></i> All Activities
                </div>
                <div class="filter-dropdown-item"
                  onclick="selectFilter('activities', 'similar', 'Similar Users', this)">
                  <i class="fas fa-users"></i> Similar Users
                </div>
                <div class="filter-dropdown-item" onclick="selectFilter('activities', 'high-rated', 'Top Rated', this)">
                  <i class="fas fa-star"></i> Top Rated
                </div>
                <div class="filter-dropdown-item" onclick="selectFilter('activities', 'recent', 'Recent', this)">
                  <i class="fas fa-clock"></i> Recent
                </div>
                <div class="filter-dropdown-item" onclick="selectFilter('activities', 'nearby', 'Near Me', this)">
                  <i class="fas fa-map-marker-alt"></i> Near Me
                </div>
              </div>
            </div>
          </div>

          <div id="feed-content">
            <!-- Feed items will be dynamically inserted here -->
          </div>

          <!-- Load More Button -->
          <div id="load-more-container" style="text-align: center; margin-top: 2rem; display: none;">
            <button id="load-more-btn" class="btn btn-secondary" onclick="FeedSystem.loadNextPage()">
              <i class="fas fa-plus"></i> Load More Activities
            </button>
          </div>
        </div>

        <!-- Friendship Section -->
        <div id="friendship-section" class="community-section" style="display: none;">
          <div class="search-box">
            <input type="text" class="search-input" id="friendship-search"
              placeholder="Search users by name, username, or personality type..."
              onkeyup="FriendsDiscoverySystem.filterUsers()" />
            <span class="search-icon"><i class="fas fa-search"></i></span>
          </div>

          <div class="filter-container">
            <div class="filter-dropdown">
              <button class="filter-dropdown-btn" onclick="toggleFilterDropdown('friendship-filter')">
                <span id="friendship-filter-text">All Users</span>
                <i class="fas fa-chevron-down"></i>
              </button>
              <div class="filter-dropdown-menu" id="friendship-filter-menu">
                <div class="filter-dropdown-item active" onclick="selectFilter('friendship', 'all', 'All Users', this)">
                  <i class="fas fa-users"></i> All Users
                </div>
                <div class="filter-dropdown-item"
                  onclick="selectFilter('friendship', 'similar', 'Similar to You', this)">
                  <i class="fas fa-user-friends"></i> Similar to You
                </div>
                <div class="filter-dropdown-item" onclick="selectFilter('friendship', 'friends', 'My Friends', this)">
                  <i class="fas fa-heart"></i> My Friends
                </div>
                <div class="filter-dropdown-item"
                  onclick="selectFilter('friendship', 'requests', 'Friend Requests', this)">
                  <i class="fas fa-user-plus"></i> Friend Requests
                </div>
              </div>
            </div>
          </div>

          <div id="friendship-content">
            <!-- Friendship content will be dynamically inserted here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Groups Page -->
    <div id="groups" class="page hidden">
      <div class="card">
        <div class="card-header">
          <h2>Group Planning</h2>
          <p>
            Create groups with friends and find activities that work for
            everyone's energy preferences.
          </p>
        </div>

        <div class="centered">
          <button class="btn" onclick="showCreateGroupModal()" id="create-group-btn">
            <i class="fas fa-users"></i> Create New Group
          </button>
        </div>

        <!-- Group Usage Display -->
        <div id="group-usage-display" style="
          background: rgba(74, 144, 226, 0.1); 
          padding: 1rem; 
          border-radius: 10px; 
          margin: 1rem 0; 
          text-align: center;
        ">
          <div style="display: flex; justify-content: center; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <i class="fas fa-users" style="color: var(--secondary-color);"></i>
              <span style="font-weight: bold;">Groups This Month:</span>
              <span id="group-usage-text" style="
                background: var(--primary-color); 
                color: white; 
                padding: 0.2rem 0.6rem; 
                border-radius: 12px; 
                font-size: 0.9rem;
              ">Loading...</span>
            </div>
            <div id="premium-status-display" style="display: flex; align-items: center; gap: 0.5rem;">
              <i class="fas fa-crown" style="color: #FFD700;"></i>
              <span id="premium-status-text" style="font-size: 0.9rem; color: #666;">Loading...</span>
            </div>
          </div>
        </div>

        <div id="groups-content">
          <!-- Groups will be dynamically inserted here -->
        </div>
      </div>
    </div>

    <!-- Login Page -->
    <div id="login" class="page">
      <div id="login-content">
        <!-- Professional Minimalistic Login Flow -->
        <div id="login-form-container" class="auth-container">
          <div class="auth-header">
            <h2>Welcome back</h2>
            <p>Sign in to your account to continue</p>
          </div>

          <!-- Step 1: Email Input -->
          <div id="login-step-1" class="auth-step">
            <div class="form-group">
              <input type="email" id="login-email" class="auth-input" placeholder="Email address" required>
            </div>

            <button type="button" class="auth-btn-primary" onclick="handleEmailContinue()">
              Continue
            </button>

            <div class="auth-divider">
              <span>or</span>
            </div>

            <div class="oauth-buttons">
              <button type="button" class="oauth-btn google-btn" onclick="handleGoogleSignIn()">
                <svg width="18" height="18" viewBox="0 0 24 24">
                  <path fill="#4285F4"
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                  <path fill="#34A853"
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                  <path fill="#FBBC05"
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                  <path fill="#EA4335"
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                </svg>
                Google
              </button>

              <button type="button" class="oauth-btn github-btn" onclick="handleGitHubSignIn()">
                <svg width="18" height="18" viewBox="0 0 24 24">
                  <path fill="currentColor"
                    d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
                GitHub
              </button>
            </div>

            <div class="auth-footer">
              <p>Don't have an account? <a href="#" onclick="showRegisterForm()">Sign up</a></p>
            </div>
          </div>

          <!-- Step 2: Password Input -->
          <div id="login-step-2" class="auth-step" style="display: none;">
            <div class="auth-back">
              <button type="button" class="back-btn" onclick="backToEmailStep()">
                <i class="fas fa-arrow-left"></i>
              </button>
              <div class="back-info">
                <span id="login-email-display"></span>
              </div>
            </div>

            <div class="form-group">
              <div class="password-input-wrapper">
                <input type="password" id="login-password" class="auth-input" placeholder="Password" required>
                <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('login-password')">
                  <i class="fas fa-eye"></i>
                </button>
              </div>
            </div>

            <button type="button" class="auth-btn-primary" onclick="handlePasswordContinue()">
              Sign in
            </button>

            <div class="auth-footer">
              <p><a href="#" onclick="showForgotPassword()">Forgot your password?</a></p>
            </div>
          </div>

          <!-- Forgot Password Form -->
          <div id="forgot-password-container" class="auth-container" style="display: none;">
            <div class="auth-header">
              <h2>Reset your password</h2>
              <p>Enter your email address and we'll send you a link to reset your password</p>
            </div>

            <div class="auth-back">
              <button type="button" class="back-btn" onclick="backToLoginStep()">
                <i class="fas fa-arrow-left"></i>
              </button>
              <div class="back-info">
                <span>Back to sign in</span>
              </div>
            </div>

            <div style="margin-bottom: 1rem;">
              <label for="forgot-email"
                style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-color);">Email</label>
              <input type="email" id="forgot-email" class="auth-input" placeholder="Enter your email address" required
                onkeypress="handleForgotPasswordKeyPress(event)">
            </div>

            <button type="button" class="auth-btn-primary" onclick="handleForgotPassword()">
              Send reset link
            </button>

            <div class="auth-footer">
              <p>Remember your password? <a href="#" onclick="backToLoginStep()">Sign in</a></p>
            </div>
          </div>
        </div>
      </div>

      <!-- Register Form -->
      <div id="register-form-container" class="auth-container" style="display: none;">
        <div class="auth-header">
          <h2>Create account</h2>
          <p>Join Senergy to start your journey</p>
        </div>

        <form id="register-form" onsubmit="event.preventDefault();">
          <!-- First Name and Last Name side by side -->
          <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
            <div style="flex: 1;">
              <label for="register-firstName"
                style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-color);">First
                name</label>
              <input type="text" id="register-firstName" class="auth-input" placeholder="Your first name" required
                onkeypress="handleRegisterKeyPress(event)">
            </div>
            <div style="flex: 1;">
              <label for="register-lastName"
                style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-color);">Last
                name</label>
              <input type="text" id="register-lastName" class="auth-input" placeholder="Your last name" required
                onkeypress="handleRegisterKeyPress(event)">
            </div>
          </div>

          <!-- Email field -->
          <div style="margin-bottom: 1rem;">
            <label for="register-email"
              style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-color);">Email</label>
            <input type="email" id="register-email" class="auth-input" placeholder="Your email address" required
              onkeypress="handleRegisterKeyPress(event)">
          </div>

          <!-- Continue button -->
          <button type="button" class="auth-btn-primary" onclick="handleRegisterContinue()">
            Continue
          </button>

          <!-- OR separator -->
          <div class="auth-divider">
            <span>OR</span>
          </div>

          <!-- Social login buttons -->
          <div class="oauth-buttons">
            <button type="button" class="oauth-btn google-btn" onclick="handleGoogleSignIn()">
              <svg width="18" height="18" viewBox="0 0 24 24">
                <path fill="#4285F4"
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                <path fill="#34A853"
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                <path fill="#FBBC05"
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                <path fill="#EA4335"
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
              </svg>
              Google
            </button>

            <button type="button" class="oauth-btn github-btn" onclick="handleGitHubSignIn()">
              <svg width="18" height="18" viewBox="0 0 24 24">
                <path fill="currentColor"
                  d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
              </svg>
              GitHub
            </button>
          </div>

          <div class="auth-footer">
            <p>Already have an account? <a href="#" onclick="showLoginForm()">Sign in</a></p>
          </div>
        </form>

        <!-- Password Step (hidden initially) -->
        <div id="register-password-step" class="auth-container" style="display: none;">
          <div class="auth-back">
            <button type="button" class="back-btn" onclick="backToRegisterStep()">
              <i class="fas fa-arrow-left"></i>
            </button>
            <div class="back-info">
              <span id="register-email-display"></span>
            </div>
          </div>

          <div style="margin-bottom: 1rem;">
            <label for="register-password"
              style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-color);">Password</label>
            <div class="password-input-wrapper">
              <input type="password" id="register-password" class="auth-input" placeholder="Create a password" required
                minlength="6" onkeypress="handleRegisterPasswordKeyPress(event)"
                oninput="checkPasswordStrength(this.value)">
              <button type="button" class="password-toggle-btn" onclick="togglePasswordVisibility('register-password')">
                <i class="fas fa-eye"></i>
              </button>
            </div>
            <div class="password-strength">
              <div class="password-strength-bar">
                <div class="password-strength-fill" id="password-strength-fill"></div>
              </div>
              <div class="password-strength-text" id="password-strength-text">Password strength</div>
            </div>
          </div>

          <button type="button" class="auth-btn-primary" onclick="handleRegisterPasswordContinue()">
            Continue
          </button>

          <div class="auth-footer">
            <p>Already have an account? <a href="#" onclick="showLoginForm()">Sign in</a></p>
          </div>
        </div>
      </div>
    </div>
  </div>
  </div>

  <!-- Friends Page -->
  <div id="friends" class="page hidden">
    <div class="card">
      <div class="card-header">
        <h2>Friends & Discovery</h2>
        <p>Connect with other users and discover people with similar social energy preferences.</p>
      </div>

      <div class="search-box">
        <input type="text" class="search-input" id="friends-search"
          placeholder="Search users by name, username, or personality type..."
          onkeyup="FriendsDiscoverySystem.filterUsers()" />
        <span class="search-icon"><i class="fas fa-search"></i></span>
      </div>

      <div class="filter-tabs">
        <button class="filter-tab active" onclick="FriendsDiscoverySystem.setFilter('all')">
          All Users
        </button>
        <button class="filter-tab" onclick="FriendsDiscoverySystem.setFilter('similar')">
          Similar to You
        </button>
        <button class="filter-tab" onclick="FriendsDiscoverySystem.setFilter('friends')">
          My Friends
        </button>
        <button class="filter-tab" onclick="FriendsDiscoverySystem.setFilter('requests')">
          Friend Requests
        </button>
      </div>

      <div id="friends-content">
        <!-- Friends and user discovery content will be dynamically inserted here -->
      </div>
    </div>
  </div>

  <!-- Profile Page -->
  <div id="profile" class="page hidden">
    <div class="card">
      <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
        <h2>Your Profile</h2>
        <button class="btn btn-danger" onclick="handleLogout()" style="font-size: 0.9rem; padding: 8px 16px;">
          <i class="fas fa-sign-out-alt"></i> Sign Out
        </button>
      </div>
      <div id="profile-content">
        <!-- Profile content will be dynamically inserted here -->
      </div>
    </div>
  </div>
  </div>
  <!-- JavaScript remains unchanged -->
  <script>

    // AI Premium Feature Configuration
    let AI_PREMIUM_ENABLED = true; // Set to false to disable premium features

    // Console command to toggle AI Premium features
    window.toggleAIPremium = function () {
      AI_PREMIUM_ENABLED = !AI_PREMIUM_ENABLED;
      console.log(`🎭 AI Premium features ${AI_PREMIUM_ENABLED ? 'ENABLED' : 'DISABLED'}`);

      // Update current user premium status
      const currentUser = DataLayer.load("currentUser");
      if (currentUser) {
        currentUser.isPremium = AI_PREMIUM_ENABLED;
        DataLayer.save("currentUser", currentUser);
      }

      // Refresh the current page to reflect changes
      const currentPage = document.querySelector(".page:not(.hidden)").id;
      if (currentPage) {
        showPage(currentPage);
      }

      return AI_PREMIUM_ENABLED;
    };

    // Console command to set AI Premium features to specific value
    window.setAIPremium = function (enabled) {
      if (typeof enabled !== 'boolean') {
        console.error('❌ Please provide a boolean value (true or false)');
        return false;
      }

      AI_PREMIUM_ENABLED = enabled;
      console.log(`🎭 AI Premium features ${AI_PREMIUM_ENABLED ? 'ENABLED' : 'DISABLED'}`);

      // Update current user premium status
      const currentUser = DataLayer.load("currentUser");
      if (currentUser) {
        currentUser.isPremium = AI_PREMIUM_ENABLED;
        DataLayer.save("currentUser", currentUser);
      }

      // Refresh the current page to reflect changes
      const currentPage = document.querySelector(".page:not(.hidden)").id;
      if (currentPage) {
        showPage(currentPage);
      }

      return AI_PREMIUM_ENABLED;
    };

    // Console command to test Firebase email functionality
    window.testFirebaseEmail = async function (email = 'test@example.com') {
      try {
        console.log('🧪 Testing Firebase email functionality...');

        if (!authManager) {
          console.log('❌ Firebase not initialized');
          return false;
        }

        console.log('✅ Firebase initialized');
        console.log('📧 Testing password reset email...');

        const { sendPasswordResetEmail } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');

        const actionCodeSettings = {
          url: window.location.origin + '/pitch/index.html',
          handleCodeInApp: false
        };

        await sendPasswordResetEmail(authManager.auth, email, actionCodeSettings);
        console.log('✅ Password reset email sent successfully!');
        console.log('📬 Check your email inbox and spam folder');

        return true;
      } catch (error) {
        console.error('❌ Email test failed:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        return false;
      }
    };

    // Console command to check current AI Premium status
    window.getAIPremiumStatus = function () {
      console.log(`🎭 AI Premium features are currently ${AI_PREMIUM_ENABLED ? 'ENABLED' : 'DISABLED'}`);
      return AI_PREMIUM_ENABLED;
    };

    // Helper function to add crown to premium users
    function addCrownToPremiumUser(displayName, userId) {
      // Get current user safely
      const currentUser = DataLayer.load("currentUser");

      const isPremium = userId === (currentUser ? currentUser.id : null) ?
        (currentUser ? currentUser.isPremium : false) :
        false; // No demo users - all premium status comes from Firebase user data

      if (isPremium) {
        return `${displayName} <i class="fas fa-crown" style="color: #FFD700; margin-left: 0.3rem;"></i>`;
      }
      return displayName;
    }

    // Helper function to add online status indicator
    function addOnlineStatusIndicator(displayName, userId, isOnline = false, isActive = false) {
      if (userId === (DataLayer.load("currentUser") ? DataLayer.load("currentUser").id : null)) {
        return displayName; // Don't show online status for current user
      }

      // Handle legacy users who don't have isActive field yet
      // If isOnline is true but isActive is undefined, assume they are active
      const isActuallyActive = isActive !== undefined ? isActive : isOnline;

      if (isOnline && isActuallyActive) {
        // Online and active: Green circle
        return `${displayName} <i class="fas fa-circle" style="color: #27ae60; font-size: 0.7rem; margin-left: 0.3rem;" title="Online"></i>`;
      } else if (isOnline && !isActuallyActive) {
        // Online but inactive: Yellow crescent moon
        return `${displayName} <i class="fas fa-moon" style="color: #fbbf24; font-size: 0.7rem; margin-left: 0.3rem;" title="Inactive"></i>`;
      } else {
        // Offline: Grey circle
        return `${displayName} <i class="fas fa-circle" style="color: #6b7280; font-size: 0.7rem; margin-left: 0.3rem;" title="Offline"></i>`;
      }
    }


    // Filter dropdown functionality
    function toggleFilterDropdown(filterId) {
      const menu = document.getElementById(filterId + '-menu');
      const btn = document.querySelector(`[onclick="toggleFilterDropdown('${filterId}')"]`);

      // Close all other dropdowns
      document.querySelectorAll('.filter-dropdown-menu').forEach(m => {
        if (m !== menu) {
          m.classList.remove('show');
          m.previousElementSibling.classList.remove('active');
        }
      });

      // Toggle current dropdown
      menu.classList.toggle('show');
      btn.classList.toggle('active');
    }

    function selectFilter(type, filter, text, clickedElement) {
      // Update button text
      const textElement = document.getElementById(type + '-filter-text');
      if (textElement) {
        textElement.textContent = text;
      }

      // Update active state
      const menu = document.getElementById(type + '-filter-menu');
      menu.querySelectorAll('.filter-dropdown-item').forEach(item => {
        item.classList.remove('active');
      });

      // Use the passed element or fallback to event.target
      const targetElement = clickedElement || (typeof event !== 'undefined' ? event.target : null);
      if (targetElement) {
        const dropdownItem = targetElement.closest('.filter-dropdown-item');
        if (dropdownItem) {
          dropdownItem.classList.add('active');
        }
      }

      // Close dropdown
      menu.classList.remove('show');
      menu.previousElementSibling.classList.remove('active');

      // Call appropriate filter function
      if (type === 'activities') {
        if (typeof FeedSystem !== 'undefined' && FeedSystem.setFilter) {
          FeedSystem.setFilter(filter);
        }
      } else if (type === 'friendship') {
        if (typeof FriendsDiscoverySystem !== 'undefined' && FriendsDiscoverySystem.setFilter) {
          FriendsDiscoverySystem.setFilter(filter);
        }
      }
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', function (event) {
      if (!event.target.closest('.filter-dropdown')) {
        document.querySelectorAll('.filter-dropdown-menu').forEach(menu => {
          menu.classList.remove('show');
        });
        document.querySelectorAll('.filter-dropdown-btn').forEach(btn => {
          btn.classList.remove('active');
        });
      }
    });

    // Function to handle rating a place from the community feed
    function ratePlace(name, category, location, description) {
      // Pre-fill the activity form
      document.getElementById("activity-name").value = name;
      document.getElementById("activity-category").value = category;
      document.getElementById("activity-location").value = location;
      document.getElementById("activity-description").value = description;

      // Switch to the activities page
      showPage("activities");

      // Scroll to the form
      document
        .getElementById("activity-form")
        .scrollIntoView({ behavior: "smooth" });
    }

    // Function to edit user's own experience
    function editUserExperience(experienceId) {
      // Find the experience in user's experiences
      const userExperiences = DataLayer.load("userExperiences", []);

      // Debug logging
      console.log('🔍 Looking for experience with ID:', experienceId);
      console.log('🔍 Available experiences:', userExperiences.map(exp => ({ id: exp.id, name: exp.name })));

      // Try multiple ways to find the experience
      let experience = userExperiences.find(exp => exp.id === experienceId || exp.name === experienceId);

      // If not found, try string comparison for IDs
      if (!experience) {
        experience = userExperiences.find(exp => String(exp.id) === String(experienceId) || exp.name === experienceId);
      }

      // If still not found, try to find by name if the ID looks like a timestamp
      if (!experience && !isNaN(experienceId)) {
        // The ID might be a timestamp, try to find by name from the experience card
        const experienceCard = document.querySelector(`[onclick*="editUserExperience('${experienceId}')"]`);
        if (experienceCard) {
          const nameElement = experienceCard.querySelector('h3');
          if (nameElement) {
            const name = nameElement.textContent.split('✓')[0].trim();
            experience = userExperiences.find(exp => exp.name === name);
          }
        }
      }

      if (experience) {
        console.log('✅ Found experience:', experience);

        // Find the index of the experience in the array
        const experienceIndex = userExperiences.findIndex(exp => exp.id === experience.id);

        if (experienceIndex !== -1) {
          // Use the existing editExperience function to open the edit modal
          editExperience(experienceIndex);
        } else {
          console.error('❌ Could not find experience index');
          NotificationSystem.show('Error: Could not find experience to edit.', 'error');
        }
      } else {
        console.error('❌ Experience not found with ID:', experienceId);
        console.error('❌ Available experiences:', userExperiences.map(exp => ({ id: exp.id, name: exp.name })));

        // Try to provide more helpful error message
        const experienceCard = document.querySelector(`[onclick*="editUserExperience('${experienceId}')"]`);
        if (experienceCard) {
          const nameElement = experienceCard.querySelector('h3');
          if (nameElement) {
            const name = nameElement.textContent.split('✓')[0].trim();
            NotificationSystem.show(`Experience "${name}" not found in your saved experiences. It may have been deleted or you may need to refresh the page.`, 'error');
          } else {
            NotificationSystem.show('Experience not found. Please try refreshing the page.', 'error');
          }
        } else {
          NotificationSystem.show('Experience not found. Please try refreshing the page.', 'error');
        }
      }
    }

    // In-memory data storage (replaces localStorage)
    let appData = {
      personalityScore: null,
      personalityType: null,
      userExperiences: [],
      groups: [],
      friends: [], // Add friends array
      currentUser: {
        id: "user-main",
        username: "you",
        displayName: "You",
        avatar: "Y",
        isPremium: AI_PREMIUM_ENABLED, // Current user's premium status
      },
      gotoPage(page) {
        GroupsSystem.currentPage = page;
        GroupsSystem.displayGroups();
      },
    };

    const FriendsSystem = {
      async addFriend(userId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to add friends.', 'warning');
          return false;
        }

        try {
          const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Create friend request
          const requestData = {
            fromUserId: currentFirebaseUser.uid,
            toUserId: userId,
            status: 'pending',
            createdAt: serverTimestamp()
          };

          await wrapWrite(
            addDoc(collection(authManager.db, 'friendRequests'), requestData),
            'addDoc',
            'friendRequests',
            { toUserId: userId }
          );

          NotificationSystem.show('Friend request sent!', 'success');

          // Update all buttons for this user to show "Pending" state
          const buttons = document.querySelectorAll(`[onclick*="FriendsSystem.addFriend(${userId})"]`);
          buttons.forEach(button => {
            button.innerHTML = '<i class="fas fa-clock"></i> Pending';
            button.style.background = '#fbbf24'; // Yellow background
            button.style.color = '#1f2937'; // Dark text for contrast
            button.style.border = '1px solid #f59e0b';
            button.disabled = true;
            button.onclick = null; // Remove the onclick to prevent multiple clicks
          });

          return true;
        } catch (error) {
          console.error('Error adding friend:', error);
          NotificationSystem.show('Failed to send friend request.', 'error');
          return false;
        }
      },

      updateFriendButton: (userId, isFriend) => {
        console.log(`Updating friend button for user ${userId}, isFriend: ${isFriend}`);

        // Find all buttons for this user with comprehensive selectors
        const buttonSelectors = [
          `[onclick*="FriendsSystem.addFriend(${userId})"]`,
          `[onclick*="FriendsSystem.addFriend('${userId}')"]`,
          `[onclick*="FriendsDiscoverySystem.sendFriendRequest('${userId}')"]`,
          `[onclick*="addFriend(${userId})"]`,
          `button[data-user-id="${userId}"]`,
          `[data-user-id="${userId}"]`
        ];

        // Also look for pending buttons that might need updating
        const pendingSelectors = [
          `[data-pending-for="${userId}"]`,
          `[style*="fbbf24"]`, // Yellow background (pending)
          `[style*="f59e0b"]`  // Yellow border (pending)
        ];

        let buttons = [];

        // Find buttons with specific user ID
        buttonSelectors.forEach(selector => {
          const foundButtons = document.querySelectorAll(selector);
          buttons = buttons.concat(Array.from(foundButtons));
        });

        // Enhanced search: look in user cards for any related buttons
        const userCards = document.querySelectorAll('.user-card, .similar-user-card, [data-user-id]');
        userCards.forEach(card => {
          if (card.getAttribute('data-user-id') === userId ||
            card.textContent.includes(userId) ||
            card.querySelector(`[onclick*="${userId}"]`)) {
            const cardButtons = card.querySelectorAll('button');
            cardButtons.forEach(btn => {
              if (btn.textContent.includes('Add Friend') ||
                btn.textContent.includes('Pending') ||
                btn.textContent.includes('Friend') ||
                (btn.onclick && btn.onclick.toString().includes(userId))) {
                buttons.push(btn);
              }
            });
          }
        });

        // If still no buttons, look for pending buttons
        if (buttons.length === 0) {
          console.log(`No specific buttons found for user ${userId}, looking for pending buttons`);
          pendingSelectors.forEach(selector => {
            try {
              const foundButtons = document.querySelectorAll(selector);
              buttons = buttons.concat(Array.from(foundButtons));
            } catch (e) {
              console.log(`Selector ${selector} not supported, skipping`);
            }
          });
        }

        // Remove duplicates
        buttons = [...new Set(buttons)];

        console.log(`Found ${buttons.length} buttons to update for user ${userId}`);

        buttons.forEach(button => {
          console.log(`Updating button:`, button);

          if (isFriend) {
            // Animate the button change
            button.style.transition = 'all 0.3s ease';
            button.style.transform = 'scale(1.1)';
            button.style.color = 'white';

            // Reset transform after animation and update content
            setTimeout(() => {
              button.style.transform = 'scale(1)';
              // Clear button styling to avoid double styling
              button.style.background = 'transparent';
              button.style.border = 'none';
              button.style.padding = '0';
              button.style.margin = '0';
              button.style.boxShadow = 'none';
              button.style.cursor = 'default';
              button.onclick = null; // Remove click handler
              button.innerHTML = '<span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color); display: inline-block;">✓ Friend</span>';
              console.log(`Button updated to "Friend" for user ${userId}`);
            }, 300);
          } else {
            // Reset to original button styling
            button.innerHTML = 'Add Friend';
            button.style.background = '';
            button.style.color = '';
            button.style.border = '';
            button.style.padding = '';
            button.style.margin = '';
            button.style.boxShadow = '';
            button.style.transform = '';
            button.style.cursor = 'pointer';
            console.log(`Button reset to "Add Friend" for user ${userId}`);
            // Restore click handler - this will be handled by the page refresh
          }
        });

        // Force refresh of the friends display to ensure all UI is updated
        setTimeout(() => {
          if (typeof FriendsDiscoverySystem !== 'undefined') {
            console.log(`Refreshing FriendsDiscoverySystem display for user ${userId}`);
            FriendsDiscoverySystem.displayUsers();

            // Also update any specific user cards that might be cached
            const userCards = document.querySelectorAll(`[data-user-id="${userId}"]`);
            userCards.forEach(card => {
              // Force re-render of this specific card
              card.style.opacity = '0.8';
              setTimeout(() => {
                card.style.opacity = '1';
              }, 100);
            });
          }
        }, 500);
      },

      async getFriends() {
        if (!currentFirebaseUser) return [];

        try {
          const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid)),
            query(friendsCollection, where('user2Id', '==', currentFirebaseUser.uid))
          ];

          const friends = [];
          const friendIds = new Set();

          for (const q of queries) {
            const querySnapshot = await getDocs(q);

            for (const docSnap of querySnapshot.docs) {
              const friendshipData = docSnap.data();
              const friendId = friendshipData.user1Id === currentFirebaseUser.uid
                ? friendshipData.user2Id
                : friendshipData.user1Id;

              if (!friendIds.has(friendId)) {
                friendIds.add(friendId);

                const friendDoc = await getDoc(doc(authManager.db, 'users', friendId));
                if (friendDoc.exists()) {
                  friends.push({
                    id: friendDoc.id,
                    ...friendDoc.data()
                  });
                }
              }
            }
          }

          return friends;
        } catch (error) {
          console.error('Error getting friends:', error);
          return [];
        }
      },

      getFriendIds: async () => {
        const friends = await FriendsSystem.getFriends();
        return friends.map((friend) => friend.id);
      },

      async isFriend(userId) {
        if (!currentFirebaseUser) return false;

        try {
          const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid), where('user2Id', '==', userId)),
            query(friendsCollection, where('user1Id', '==', userId), where('user2Id', '==', currentFirebaseUser.uid))
          ];

          for (const q of queries) {
            const querySnapshot = await wrapRead(getDocs(q), 'getDocs', 'friends', {});
            if (!querySnapshot.empty) {
              return true;
            }
          }

          return false;
        } catch (error) {
          console.error('Error checking friendship:', error);
          return false;
        }
      },

      async removeFriend(userId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to remove friends.', 'warning');
          return false;
        }

        try {
          const { collection, query, where, getDocs, deleteDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid), where('user2Id', '==', userId)),
            query(friendsCollection, where('user1Id', '==', userId), where('user2Id', '==', currentFirebaseUser.uid))
          ];

          for (const q of queries) {
            const querySnapshot = await wrapRead(getDocs(q), 'getDocs', 'friends', {});
            if (!querySnapshot.empty) {
              const friendshipDoc = querySnapshot.docs[0];
              await wrapWrite(
                deleteDoc(doc(authManager.db, 'friends', friendshipDoc.id)),
                'deleteDoc',
                `friends/${friendshipDoc.id}`,
                { reason: 'removeFriend' }
              );

              NotificationSystem.show('Friend removed successfully!', 'success');
              return true;
            }
          }

          NotificationSystem.show('Friend not found!', 'error');
          return false;
        } catch (error) {
          console.error('Error removing friend:', error);
          NotificationSystem.show('Failed to remove friend.', 'error');
          return false;
        }
      },

      // Enhanced friend request functions with real-time updates
      async acceptFriendRequest(requestId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to accept friend requests.', 'warning');
          return false;
        }

        try {
          const { doc, updateDoc, deleteDoc, addDoc, collection, serverTimestamp, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Get the friend request
          const requestDoc = doc(authManager.db, 'friendRequests', requestId);
          const requestSnapshot = await wrapRead(getDoc(requestDoc), 'getDoc', `friendRequests/${requestId}`, {});

          if (!requestSnapshot.exists()) {
            NotificationSystem.show('Friend request not found.', 'error');
            return false;
          }

          const requestData = requestSnapshot.data();

          // Update request status to accepted
          await wrapWrite(
            updateDoc(requestDoc, {
              status: 'accepted',
              acceptedAt: serverTimestamp()
            }),
            'updateDoc',
            `friendRequests/${requestId}`,
            { status: 'accepted' }
          );

          // Create friendship record
          const friendshipData = {
            user1Id: requestData.fromUserId,
            user2Id: requestData.toUserId,
            createdAt: serverTimestamp()
          };

          await wrapWrite(
            addDoc(collection(authManager.db, 'friends'), friendshipData),
            'addDoc',
            'friends',
            { user1Id: requestData.fromUserId, user2Id: requestData.toUserId }
          );

          NotificationSystem.show('Friend request accepted!', 'success');

          // Real-time listeners will automatically update the UI
          return true;
        } catch (error) {
          console.error('Error accepting friend request:', error);
          NotificationSystem.show('Failed to accept friend request.', 'error');
          return false;
        }
      },

      async rejectFriendRequest(requestId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to reject friend requests.', 'warning');
          return false;
        }

        try {
          const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Update request status to rejected
          await wrapWrite(
            updateDoc(doc(authManager.db, 'friendRequests', requestId), {
              status: 'rejected',
              rejectedAt: serverTimestamp()
            }),
            'updateDoc',
            `friendRequests/${requestId}`,
            { status: 'rejected' }
          );

          NotificationSystem.show('Friend request rejected.', 'info');

          // Real-time listeners will automatically update the UI
          return true;
        } catch (error) {
          console.error('Error rejecting friend request:', error);
          NotificationSystem.show('Failed to reject friend request.', 'error');
          return false;
        }
      },
    };

    // Data layer - handles in-memory storage operations
    const DataLayer = {
      save: (key, data) => {
        appData[key] = JSON.parse(JSON.stringify(data));
      },

      load: (key, defaultValue = null) => {
        return appData[key] !== undefined
          ? JSON.parse(JSON.stringify(appData[key]))
          : defaultValue;
      },

      exists: (key) => {
        return appData[key] !== undefined && appData[key] !== null;
      },

      push: (key, item) => {
        if (!appData[key]) appData[key] = [];
        appData[key].push(JSON.parse(JSON.stringify(item)));
      },

      remove: (key, predicate) => {
        if (appData[key] && Array.isArray(appData[key])) {
          appData[key] = appData[key].filter((item) => !predicate(item));
        }
      },
    };

    // Personality assessment system
    const PersonalityAssessment = {
      questions: [
        { text: "Large parties energize me", weight: 3 },
        {
          text: "I prefer quiet, intimate gatherings",
          weight: 3,
          reverse: true,
        },
        {
          text: "I need alone time after social events",
          weight: 2,
          reverse: true,
        },
        { text: "I'm comfortable being the center of attention", weight: 2 },
        {
          text: "I prefer deep conversations over small talk",
          weight: 2,
          reverse: true,
        },
        { text: "I enjoy spontaneous social activities", weight: 1 },
        { text: "I recharge by being around people", weight: 3 },
        { text: "I think out loud when making decisions", weight: 1 },
        { text: "I'm energized by new social environments", weight: 2 },
        { text: "I prefer working in teams vs alone", weight: 1 },
      ],

      // questions: [
      //   { text: "Large parties energize me", weight: 3 },
      // ],

      currentQuestion: 0,
      responses: [],

      init: () => {
        PersonalityAssessment.currentQuestion = 0;
        PersonalityAssessment.responses = [];
        PersonalityAssessment.displayQuestion();

        // Add keyboard event listener for assessment navigation
        document.addEventListener("keydown", PersonalityAssessment.handleKeyboard);
      },

      displayQuestion: () => {
        const container = document.getElementById("question-container");
        const question =
          PersonalityAssessment.questions[
          PersonalityAssessment.currentQuestion
          ];

        container.innerHTML = `
      <div class="question-container">
        <div class="question-text">${question.text}</div>
        <div class="scale-labels">
          <span>Strongly Disagree</span>
          <span>Strongly Agree</span>
        </div>
        <div class="radio-group">
          ${[1, 2, 3, 4, 5]
            .map(
              (value) => `
              <div class="radio-item" onclick="document.getElementById('q${value}').click()">
                <input type="radio" name="question" value="${value}" id="q${value}" onchange="PersonalityAssessment.selectAnswer(${value})">
                <label for="q${value}">${value}</label>
              </div>
            `
            )
            .join("")}
        </div>
      </div>
    `;

        // Update progress
        const progress =
          ((PersonalityAssessment.currentQuestion + 1) /
            PersonalityAssessment.questions.length) *
          100;
        document.getElementById("progress-fill").style.width = `${progress}%`;
        document.getElementById("progress-text").textContent = `Question ${PersonalityAssessment.currentQuestion + 1
          } of ${PersonalityAssessment.questions.length}`;
      },

      selectAnswer: (value) => {
        PersonalityAssessment.responses[
          PersonalityAssessment.currentQuestion
        ] = value;
        document.getElementById("next-btn").disabled = false;
      },

      handleKeyboard: (event) => {
        // Only handle keyboard events if we're on the assessment page
        if (document.getElementById("assessment").classList.contains("hidden")) {
          return;
        }

        const key = event.key;

        // Handle number keys 1-5 for radio button selection
        if (key >= "1" && key <= "5") {
          const value = parseInt(key);
          document.getElementById(`q${value}`).click();
          PersonalityAssessment.selectAnswer(value);
        }

        // Handle Enter key for next button
        if (key === "Enter") {
          const nextBtn = document.getElementById("next-btn");
          if (!nextBtn.disabled) {
            nextQuestion();
          }
        }
      },

      calculateScore: () => {
        let weightedSum = 0;
        let totalWeight = 0;

        PersonalityAssessment.questions.forEach((question, index) => {
          let response = PersonalityAssessment.responses[index];
          if (question.reverse) {
            response = 6 - response;
          }
          weightedSum += response * question.weight;
          totalWeight += question.weight;
        });

        const rawScore = weightedSum / totalWeight;
        const adjustmentFactor = Math.max(
          -1,
          Math.min(1, (rawScore - 2.5) / 2.5)
        );

        return {
          rawScore,
          adjustmentFactor,
        };
      },

      getPersonalityType: (adjustmentFactor) => {
        if (adjustmentFactor <= -0.6)
          return {
            type: "Strong Introvert",
            description:
              "You recharge through solitude and prefer quieter, more intimate social settings.",
          };
        if (adjustmentFactor <= -0.2)
          return {
            type: "Moderate Introvert",
            description:
              "You enjoy social interaction but need quiet time to recharge your energy.",
          };
        if (adjustmentFactor <= 0.2)
          return {
            type: "Ambivert",
            description:
              "You have a balanced approach to social energy and can adapt to various situations.",
          };
        if (adjustmentFactor <= 0.6)
          return {
            type: "Moderate Extrovert",
            description:
              "You're energized by social interaction and enjoy group activities.",
          };
        return {
          type: "Strong Extrovert",
          description:
            "You thrive in social situations and gain energy from being around others.",
        };
      },

      showResults: async () => {
        const scores = PersonalityAssessment.calculateScore();
        const personality = PersonalityAssessment.getPersonalityType(
          scores.adjustmentFactor
        );

        document.getElementById("personality-score").textContent =
          scores.adjustmentFactor.toFixed(1);
        document.getElementById("personality-type").textContent =
          personality.type;
        document.getElementById("personality-description").textContent =
          personality.description;

        // Save results locally
        DataLayer.save("personalityScore", scores);
        DataLayer.save("personalityType", personality);

        console.log('Personality assessment completed:', {
          scores,
          personality,
          currentUser: currentFirebaseUser?.uid
        });

        // Force reload the data to ensure it's available
        const reloadedScores = DataLayer.load("personalityScore");
        const reloadedType = DataLayer.load("personalityType");
        console.log('Reloaded data:', { reloadedScores, reloadedType });

        // Update current user locally
        let currentUser = DataLayer.load("currentUser");
        if (!currentUser) {
          currentUser = {
            id: "user-main",
            username: "you",
            displayName: "You",
          };
        }

        currentUser.adjustmentFactor = scores.adjustmentFactor;
        currentUser.personalityType = personality.type;
        currentUser.avatar = personality.type.charAt(0);

        // Save to Firebase if user is authenticated
        if (currentFirebaseUser && authManager) {
          try {
            const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

            await wrapWrite(
              updateDoc(doc(authManager.db, 'users', currentFirebaseUser.uid), {
                adjustmentFactor: scores.adjustmentFactor,
                personalityType: personality.type,
                avatar: personality.type.charAt(0),
                updatedAt: serverTimestamp()
              }),
              'updateDoc',
              `users/${currentFirebaseUser.uid}`,
              { adjustmentFactor: scores.adjustmentFactor, personalityType: personality.type }
            );

            console.log('Personality assessment saved to Firebase');
          } catch (error) {
            console.error('Error saving personality assessment to Firebase:', error);
          }
        }

        // Try to get user's actual location if geolocation is available
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              currentUser.location = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
              };
              DataLayer.save("currentUser", currentUser);

              // Save location to Firebase if user is authenticated
              if (currentFirebaseUser && authManager) {
                try {
                  const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

                  await wrapWrite(
                    updateDoc(doc(authManager.db, 'users', currentFirebaseUser.uid), {
                      location: {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                      },
                      updatedAt: serverTimestamp()
                    }),
                    'updateDoc',
                    `users/${currentFirebaseUser.uid}`,
                    { location: { lat: position.coords.latitude, lng: position.coords.longitude } }
                  );
                } catch (error) {
                  console.error('Error saving location to Firebase:', error);
                }
              }
            },
            (error) => {
              console.log("Could not get user location:", error.message);
              // Don't set a default location - let user update manually
            }
          );
        }

        DataLayer.save("currentUser", currentUser);

        // Remove the assessment tab completely
        const assessmentTab = document.querySelector(
          "li:has([onclick=\"showPage('assessment')\"])"
        );
        if (assessmentTab) {
          assessmentTab.remove();
        }

        showPage("results");
      },
    };

    // Demo users removed - using Firebase exclusively
    const DemoUsers = {
      users: {},
      experiences: []
    };

    // Helper functions for edit modal
    function closeEditModal() {
      console.log('Closing edit modal');
      const modal = document.getElementById("edit-group-modal");
      if (modal) {
        console.log('Modal found, removing with animation');
        modal.style.animation = "fadeOut 0.3s ease forwards";
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove();
            console.log('Modal removed from DOM');
          }
        }, 300);
      } else {
        console.log('Modal not found');
      }
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function handleEditModalBackdropClick(event) {
      console.log('Modal backdrop clicked:', event.target);
      if (event.target.classList.contains('modal')) {
        console.log('Closing edit modal via backdrop click');
        closeEditModal();
      }
    }

    async function handleEditGroup(event, groupId) {
      event.preventDefault();

      const groups = DataLayer.load("groups", []);
      const groupIndex = groups.findIndex((g) => g.id === groupId);
      if (groupIndex === -1) return;

      const name = document.getElementById("edit-group-name").value.trim();
      const description = document
        .getElementById("edit-group-description")
        .value.trim();

      // Update basic info
      groups[groupIndex].name = name;
      groups[groupIndex].description = description;

      // Update members
      const currentUser = DataLayer.load("currentUser");
      const personalityData = DataLayer.load("personalityScore");

      let newMembers = [
        {
          userId: currentUser.id,
          displayName: currentUser.displayName,
          personalityType: currentUser.personalityType,
          adjustmentFactor: personalityData.adjustmentFactor,
          avatar: currentUser.avatar,
          importance: 1.0,
        },
      ];

      // Keep existing members that are checked
      groups[groupIndex].members.forEach((member) => {
        if (member.userId !== currentUser.id) {
          const keepCheckbox = document.getElementById(
            `keep-member-${member.userId}`
          );
          if (keepCheckbox && keepCheckbox.checked) {
            newMembers.push(member);
          }
        }
      });

      // Add new members that are checked
      const friends = FriendsSystem.getFriends();
      friends.forEach((friend) => {
        const addCheckbox = document.getElementById(
          `add-member-${friend.id}`
        );
        if (addCheckbox && addCheckbox.checked) {
          newMembers.push({
            userId: friend.id,
            displayName: friend.displayName,
            personalityType: friend.personalityType,
            adjustmentFactor: friend.adjustmentFactor,
            avatar: friend.avatar,
            importance: 1.0,
          });
        }
      });

      groups[groupIndex].members = newMembers;
      DataLayer.save("groups", groups);

      // Save to Firebase
      try {
        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        await updateDoc(doc(authManager.db, 'groups', groupId), {
          name: name,
          description: description,
          members: newMembers.map(m => m.userId),
          memberDetails: newMembers,
          updatedAt: serverTimestamp()
        });
        console.log('Group updated in Firebase');
      } catch (error) {
        console.error('Error updating group in Firebase:', error);
      }

      closeEditModal();
      GroupsSystem.displayGroups();
      NotificationSystem.show("Group updated successfully!", "success");
    }
    // Activity system
    const ActivitySystem = {
      // Predefined activity categories
      categories: [
        {
          id: "restaurant",
          name: "Restaurant/Café",
          description: "Dining establishments, cafes, food courts",
        },
        {
          id: "nightlife",
          name: "Nightlife",
          description: "Bars, clubs, lounges",
        },
        {
          id: "outdoor",
          name: "Park/Outdoor",
          description: "Parks, gardens, hiking trails",
        },
        {
          id: "entertainment",
          name: "Entertainment",
          description: "Movies, theaters, concerts",
        },
        {
          id: "shopping",
          name: "Shopping",
          description: "Malls, markets, retail stores",
        },
        {
          id: "sports",
          name: "Sports/Recreation",
          description: "Gyms, sports venues, recreational facilities",
        },
        {
          id: "cultural",
          name: "Cultural",
          description: "Museums, galleries, historical sites",
        },
        {
          id: "social",
          name: "Social Venue",
          description: "Community centers, meet-up spaces",
        },
        {
          id: "wellness",
          name: "Wellness/Relaxation",
          description: "Spas, yoga studios, meditation centers",
        },
      ],

      // Rating questions for activity experiences
      ratingQuestions: [
        { id: "energy", text: "How energized did you feel?", weight: 0.4 },
        {
          id: "social",
          text: "How satisfied were you with the social interaction?",
          weight: 0.25,
        },
        {
          id: "comfort",
          text: "How comfortable did you feel in this environment?",
          weight: 0.2,
        },
        {
          id: "overwhelm",
          text: "How overwhelming was the environment?",
          weight: 0.1,
          reverse: true,
        },
        { id: "return", text: "How likely are you to return?", weight: 0.05 },
      ],

      submitNewExperience: async (event) => {
        event.preventDefault();

        const personalityData = DataLayer.load("personalityScore");
        if (!personalityData) {
          NotificationSystem.show(
            "Please complete the personality assessment first!",
            "warning"
          );
          showPage("assessment");
          return;
        }

        // Get form data
        const name = document.getElementById("activity-name").value.trim();
        const category = document.getElementById("activity-category").value;
        const location = document
          .getElementById("activity-location")
          .value.trim();
        const description = document
          .getElementById("activity-description")
          .value.trim();

        if (!name || !category || !location) {
          NotificationSystem.show(
            "Please fill in all required fields including location.",
            "warning"
          );
          return;
        }

        // Get ratings
        const responses = {};
        let rawScore = 0;

        ActivitySystem.ratingQuestions.forEach((question) => {
          let value = parseInt(
            document.getElementById(`rating-${question.id}`).value
          );

          if (question.reverse) {
            value = 11 - value; // Reverse score for overwhelming
          }

          responses[question.id] = value;
          rawScore += value * question.weight;
        });

        // Apply personality adjustment
        const adjustedScore = Math.max(
          1,
          Math.min(10, rawScore + personalityData.adjustmentFactor * 2)
        );

        // Estimate social characteristics based on category and user ratings
        const socialIntensity = ActivitySystem.estimateSocialIntensity(
          category,
          responses
        );
        const noiseLevel = ActivitySystem.estimateNoiseLevel(
          category,
          responses
        );
        const crowdSize = ActivitySystem.estimateCrowdSize(
          category,
          responses
        );

        // Try to get coordinates first, then save the experience
        const saveExperience = (coordinates = null) => {
          const experience = {
            id: Date.now(),
            userId: "user-main",
            name,
            category,
            location: location || "Not specified",
            description: description || "",
            responses,
            rawScore: parseFloat(rawScore.toFixed(1)),
            adjustedScore: parseFloat(adjustedScore.toFixed(1)),
            timestamp: new Date().toISOString(),
            socialIntensity,
            noiseLevel,
            crowdSize,
            coordinates
          };

          // Save experience locally
          DataLayer.push("userExperiences", experience);

          // Save to Firebase if user is authenticated
          if (currentFirebaseUser && authManager) {
            const saveToFirebase = async () => {
              try {
                const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

                const experienceData = {
                  ...experience,
                  userId: currentFirebaseUser.uid,
                  createdAt: serverTimestamp(),
                  updatedAt: serverTimestamp()
                };

                await wrapWrite(
                  addDoc(collection(authManager.db, 'experiences'), experienceData),
                  'addDoc',
                  'experiences',
                  { name: experienceData.name, hasCoordinates: !!coordinates }
                );
                console.log('Experience saved to Firebase with coordinates:', !!coordinates);
              } catch (error) {
                console.error('Error saving experience to Firebase:', error);
              }
            };
            saveToFirebase();
          }

          // Show success message
          NotificationSystem.show("Experience added successfully!", "success");

          // Reset form
          resetActivityForm();
          showPage("dashboard");
        };

        // Try to get coordinates for the location
        const getCoordinatesAndSave = async () => {
          let coordinates = null;

          // First, check if user used the "Use Current Location" button (locationFound flag)
          if (typeof locationFound !== 'undefined' && locationFound) {
            try {
              const position = await getUserLocationWithFallback();
              coordinates = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
              };
              console.log('Got coordinates from current location:', coordinates);
            } catch (error) {
              console.log("Could not get current location coordinates:", error.message);
            }
          }

          // If no coordinates from current location, try geocoding the entered location
          if (!coordinates && location && location.trim() !== '') {
            try {
              // Try to geocode the entered location using Google Maps API
              if (typeof google !== 'undefined' && google.maps && google.maps.Geocoder) {
                const geocoder = new google.maps.Geocoder();
                const result = await new Promise((resolve, reject) => {
                  geocoder.geocode({ address: location }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                      resolve(results[0]);
                    } else {
                      reject(new Error('Geocoding failed: ' + status));
                    }
                  });
                });

                coordinates = {
                  lat: result.geometry.location.lat(),
                  lng: result.geometry.location.lng()
                };
                console.log('Got coordinates from geocoding:', coordinates);
              }
            } catch (error) {
              console.log("Could not geocode location:", error.message);
            }
          }

          // Fallback: if still no coordinates, try current location one more time
          if (!coordinates && navigator.geolocation) {
            try {
              const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                  enableHighAccuracy: true,
                  timeout: 5000,
                  maximumAge: 300000
                });
              });

              coordinates = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
              };
              console.log('Got fallback coordinates:', coordinates);
            } catch (error) {
              console.log("Fallback geolocation failed:", error.message);
            }
          }

          saveExperience(coordinates);
        };

        getCoordinatesAndSave();

        // Success message, form reset, and page navigation are now handled in saveExperience()
      },

      estimateSocialIntensity: (category, responses) => {
        const baseValues = {
          Nightclub: 9.5,
          "Bar/Pub": 7.0,
          Restaurant: 5.5,
          "Event/Party": 8.5,
          "Sports/Fitness": 6.0,
          Cafe: 3.5,
          Shopping: 5.0,
          Entertainment: 7.5,
          "Museum/Gallery": 2.0,
          "Library/Study": 1.0,
          "Park/Outdoor": 2.5,
          Other: 5.0,
        };

        const base = baseValues[category] || 5.0;
        const socialFactor = (responses.social - 5) * 0.5;
        return Math.max(1, Math.min(10, base + socialFactor));
      },

      estimateNoiseLevel: (category, responses) => {
        const baseValues = {
          Nightclub: 9.0,
          "Bar/Pub": 7.5,
          Restaurant: 4.0,
          "Event/Party": 8.0,
          "Sports/Fitness": 6.5,
          Cafe: 2.5,
          Shopping: 6.0,
          Entertainment: 8.5,
          "Museum/Gallery": 1.5,
          "Library/Study": 1.0,
          "Park/Outdoor": 2.0,
          Other: 5.0,
        };

        const base = baseValues[category] || 5.0;
        const overwhelmFactor = (responses.overwhelm - 5) * 0.3;
        return Math.max(1, Math.min(10, base + overwhelmFactor));
      },

      estimateCrowdSize: (category, responses) => {
        const baseValues = {
          Nightclub: 9.0,
          "Bar/Pub": 7.0,
          Restaurant: 6.0,
          "Event/Party": 8.5,
          "Sports/Fitness": 6.5,
          Cafe: 4.0,
          Shopping: 7.5,
          Entertainment: 8.0,
          "Museum/Gallery": 3.0,
          "Library/Study": 2.0,
          "Park/Outdoor": 4.5,
          Other: 5.0,
        };

        const base = baseValues[category] || 5.0;
        const overwhelmFactor = (responses.overwhelm - 5) * 0.2;
        const comfortFactor = (5 - responses.comfort) * 0.1; // Lower comfort might mean more crowded
        return Math.max(
          1,
          Math.min(10, base + overwhelmFactor + comfortFactor)
        );
      },

      // Prediction Algorithm - Exact implementation from plan
      predictRating: (
        userAdjustmentFactor,
        experience,
        ratingUserAdjustmentFactor,
        ratingScore
      ) => {
        const basePrediction = parseFloat(ratingScore);
        const personalityDifference = Math.abs(
          ratingUserAdjustmentFactor - userAdjustmentFactor
        );
        const confidenceFactor = Math.max(0.1, 1 - personalityDifference / 2);

        let prediction;
        if (ratingUserAdjustmentFactor < userAdjustmentFactor) {
          // Rating user is more introverted than current user
          prediction =
            basePrediction +
            personalityDifference * experience.socialIntensity * 0.2;
        } else {
          // Rating user is more extroverted than current user
          prediction =
            basePrediction -
            personalityDifference * experience.socialIntensity * 0.2;
        }

        const finalPrediction = Math.max(1, Math.min(10, prediction));
        return {
          prediction: finalPrediction,
          confidence: confidenceFactor,
        };
      },

      // Get all experiences for community feed (fallback to user's own)
      getAllExperiences: () => {
        const all = DataLayer.load("allExperiences", null);
        if (Array.isArray(all)) return all;
        const userExperiences = DataLayer.load("userExperiences", []);
        return userExperiences;
      },

      // Activity Recommendation Engine
      getRecommendations: (userAdjustmentFactor) => {
        const allExperiences = ActivitySystem.getAllExperiences();
        const userExperiences = DataLayer.load("userExperiences", []);
        const userExperienceNames = userExperiences.map((exp) =>
          exp.name.toLowerCase()
        );
        const friendIds = []; // Fallback to empty array for now

        // Only include experiences from friends
        const friendExperiences = allExperiences.filter((exp) =>
          friendIds.includes(exp.userId)
        );

        const recommendations = [];

        // Group experiences by name to avoid duplicates
        const experienceGroups = {};
        friendExperiences.forEach((exp) => {
          const key = exp.name.toLowerCase();
          if (!experienceGroups[key]) {
            experienceGroups[key] = [];
          }
          experienceGroups[key].push(exp);
        });

        Object.entries(experienceGroups).forEach(([name, experiences]) => {
          // Skip if user has already been to this place
          if (userExperienceNames.includes(name)) return;

          const predictions = [];
          let totalScore = 0;
          let ratingCount = 0;

          experiences.forEach((exp) => {
            // Skip demo user lookups - no longer using demo data
            const ratingUser = null; // Only use Firebase user data going forward
            if (false) { // Disabled demo prediction logic
              const prediction = ActivitySystem.predictRating(
                userAdjustmentFactor,
                exp,
                ratingUser.adjustmentFactor,
                exp.rawScore
              );

              predictions.push({
                user: ratingUser,
                experience: exp,
                prediction: prediction,
              });

              totalScore += prediction.prediction * prediction.confidence;
              ratingCount++;
            }
          });

          if (ratingCount > 0) {
            const averageScore = totalScore / ratingCount;
            const avgConfidence =
              predictions.reduce(
                (sum, p) => sum + p.prediction.confidence,
                0
              ) / ratingCount;

            recommendations.push({
              experience: experiences[0], // Use first experience as representative
              predictedScore: averageScore,
              confidence: avgConfidence,
              ratingCount: ratingCount,
              predictions: predictions,
            });
          }
        });

        // Sort by predicted score * confidence
        return recommendations.sort(
          (a, b) =>
            b.predictedScore * b.confidence - a.predictedScore * a.confidence
        );
      },

      // Find Similar Users (pulls from Firebase with caching)
      findSimilarUsers: async (userAdjustmentFactor) => {
        console.log('ActivitySystem.findSimilarUsers() called with:', userAdjustmentFactor);
        if (!currentFirebaseUser || !authManager) {
          console.log('No Firebase user or auth manager, returning empty array');
          return [];
        }

        // Check cache first
        const cachedUsers = CacheSystem.get('SIMILAR_USERS', CacheSystem.CACHE_DURATIONS.SIMILAR_USERS);
        if (cachedUsers) {
          return cachedUsers;
        }

        try {
          // Reuse cached list to avoid duplicate 'users' reads
          if (typeof FriendsDiscoverySystem?.loadAllUsersOptimized === 'function') {
            await FriendsDiscoverySystem.loadAllUsersOptimized();
          }
          const allUsers = (FriendsDiscoverySystem?.allUsers || [])
            .filter(u => u && u.id !== currentFirebaseUser.uid && typeof u.adjustmentFactor !== 'undefined');

          console.log('Filtered users with adjustment factor (cached):', allUsers.length);

          if (allUsers.length === 0) {
            console.log('No users found for similarity matching');
            return [];
          }

          // Calculate similarity scores
          const usersWithScores = allUsers.map(user => {
            const similarityScore = 1 - Math.abs(userAdjustmentFactor - user.adjustmentFactor);
            return {
              ...user,
              similarityScore
            };
          });

          // Filter users with reasonable similarity (0.3 or higher) and sort by score
          const similarUsers = usersWithScores
            .filter(user => user.similarityScore >= 0.3)
            .sort((a, b) => b.similarityScore - a.similarityScore)
            .slice(0, 6); // Top 6 most similar users

          console.log('Similar users found:', similarUsers.length, 'with scores:', similarUsers.map(u => ({ name: u.displayName, score: u.similarityScore.toFixed(2) })));

          // If no similar users found, return random users from the same area
          if (similarUsers.length === 0) {
            const currentUser = DataLayer.load('currentUser');
            if (currentUser && currentUser.location) {
              const nearbyUsers = usersWithScores
                .filter(user => user.location)
                .map(user => {
                  const distance = calculateDistance(
                    currentUser.location.lat, currentUser.location.lng,
                    user.location.lat, user.location.lng
                  );
                  return { ...user, distance };
                })
                .filter(user => user.distance <= 50000) // Within 50km
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 6);

              console.log('No similar users found, showing nearby users:', nearbyUsers.length);
              return nearbyUsers;
            }
          }

          // Cache the results
          CacheSystem.set('SIMILAR_USERS', similarUsers);
          return similarUsers;
        } catch (error) {
          console.error('Error finding similar users:', error);
          return [];
        }
      },
    };

    function fillActivityForm(name, category, location, description = "") {
      console.log("fillActivityForm called with:", name, category, location);

      // Close nearby modal if it's open
      const nearbyModal = document.getElementById("nearby-modal");
      if (nearbyModal) {
        nearbyModal.remove();
      }

      // Close any other modals
      const allModals = document.querySelectorAll('.modal');
      allModals.forEach((modal) => {
        modal.remove();
      });

      // Navigate to activities page
      showPage("activities");

      // Fill the form after a short delay to ensure the page is loaded
      setTimeout(() => {
        const nameInput = document.getElementById("activity-name");
        const categoryInput = document.getElementById("activity-category");
        const locationInput = document.getElementById("activity-location");
        const descriptionInput = document.getElementById("activity-description");

        if (nameInput) nameInput.value = name;
        if (categoryInput) categoryInput.value = category;
        if (locationInput) locationInput.value = location;
        if (descriptionInput) descriptionInput.value = description;

        // Scroll to form
        const form = document.getElementById("activity-form");
        if (form) {
          form.scrollIntoView({ behavior: "smooth" });
        }

        NotificationSystem.show("Form pre-filled! Add your ratings below.", "success");
      }, 300);
    }

    // function editUserRating(placeName, category, location) {
    //   console.log("editUserRating called with:", placeName, category, location);

    //   // Find the user's existing experience for this place
    //   const userExperiences = DataLayer.load("userExperiences", []);
    //   const existingExperience = userExperiences.find(exp => 
    //     exp.name.toLowerCase() === placeName.toLowerCase()
    //   );

    //   if (!existingExperience) {
    //     NotificationSystem.show("Your rating for this place was not found.", "error");
    //     return;
    //   }

    //   // Create edit modal for the rating
    //   const modalHtml = `
    //     <div id="edit-rating-modal" class="modal">
    //       <div class="modal-content" style="max-width: 600px;">
    //         <button class="modal-close" onclick="closeEditRatingModal()">&times;</button>
    //         <div class="modal-header">
    //           <h2>Edit Your Rating</h2>
    //           <p style="margin: 0; color: #666;">Update your experience at ${placeName}</p>
    //         </div>
    //         <div class="modal-body">
    //           <div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 10px;">
    //             <h4 style="margin: 0 0 0.5rem 0; color: var(--primary-color);">${placeName}</h4>
    //             <div style="font-size: 0.9rem; color: #666;">
    //               <strong>Category:</strong> ${category} • <strong>Location:</strong> ${location}
    //             </div>
    //             <div style="font-size: 0.9rem; color: #666; margin-top: 0.3rem;">
    //               <strong>Current Rating:</strong> ${existingExperience.adjustedScore}/10
    //             </div>
    //           </div>

    //           <div class="rating-questions">
    //             <div class="rating-question">
    //               <label>How energized did you feel?</label>
    //               <input type="range" class="rating-slider" min="1" max="10" value="${existingExperience.responses.energy}" oninput="updateSliderValue(this, 'edit-slider-energy')" id="edit-rating-energy" />
    //               <div class="slider-value" id="edit-slider-energy">${existingExperience.responses.energy}</div>
    //             </div>
    //             <div class="rating-question">
    //               <label>How satisfied were you with the social interaction?</label>
    //               <input type="range" class="rating-slider" min="1" max="10" value="${existingExperience.responses.social}" oninput="updateSliderValue(this, 'edit-slider-social')" id="edit-rating-social" />
    //               <div class="slider-value" id="edit-slider-social">${existingExperience.responses.social}</div>
    //             </div>
    //             <div class="rating-question">
    //               <label>How comfortable did you feel in this environment?</label>
    //               <input type="range" class="rating-slider" min="1" max="10" value="${existingExperience.responses.comfort}" oninput="updateSliderValue(this, 'edit-slider-comfort')" id="edit-rating-comfort" />
    //               <div class="slider-value" id="edit-slider-comfort">${existingExperience.responses.comfort}</div>
    //             </div>
    //             <div class="rating-question">
    //               <label>How overwhelming was the environment?</label>
    //               <input type="range" class="rating-slider" min="1" max="10" value="${existingExperience.responses.overwhelm}" oninput="updateSliderValue(this, 'edit-slider-overwhelm')" id="edit-rating-overwhelm" />
    //               <div class="slider-value" id="edit-slider-overwhelm">${existingExperience.responses.overwhelm}</div>
    //             </div>
    //             <div class="rating-question">
    //               <label>How likely are you to return?</label>
    //               <input type="range" class="rating-slider" min="1" max="10" value="${existingExperience.responses.return}" oninput="updateSliderValue(this, 'edit-slider-return')" id="edit-rating-return" />
    //               <div class="slider-value" id="edit-slider-return">${existingExperience.responses.return}</div>
    //             </div>
    //           </div>

    //           <div style="text-align: center; margin-top: 2rem;">
    //             <button class="btn" onclick="saveEditedRating('${existingExperience.id}')">
    //               <i class="fas fa-save"></i> Save Changes
    //             </button>
    //             <button class="btn btn-secondary" onclick="closeEditRatingModal()" style="margin-left: 0.5rem;">
    //               Cancel
    //             </button>
    //           </div>
    //         </div>
    //       </div>
    //     </div>
    //   `;

    //   document.body.insertAdjacentHTML("beforeend", modalHtml);
    //   addModalListeners("edit-rating-modal", closeEditRatingModal);
    // }

    // function closeEditRatingModal() {
    //   const modal = document.getElementById("edit-rating-modal");
    //   if (modal) modal.remove();
    //   document.body.classList.remove('modal-open');
    // }

    // async function saveEditedRating(experienceId) {
    //   const personalityData = DataLayer.load("personalityScore");
    //   if (!personalityData) {
    //     NotificationSystem.show("Personality data not found.", "error");
    //     return;
    //   }

    //   // Get updated ratings
    //   const responses = {
    //     energy: parseInt(document.getElementById("edit-rating-energy").value),
    //     social: parseInt(document.getElementById("edit-rating-social").value),
    //     comfort: parseInt(document.getElementById("edit-rating-comfort").value),
    //     overwhelm: parseInt(document.getElementById("edit-rating-overwhelm").value),
    //     return: parseInt(document.getElementById("edit-rating-return").value)
    //   };

    //   // Calculate new scores
    //   let rawScore = 0;
    //   ActivitySystem.ratingQuestions.forEach((question) => {
    //     let value = responses[question.id];
    //     if (question.reverse) {
    //       value = 11 - value; // Reverse score for overwhelming
    //     }
    //     rawScore += value * question.weight;
    //   });

    //   const adjustedScore = Math.max(
    //     1,
    //     Math.min(10, rawScore + personalityData.adjustmentFactor * 2)
    //   );

    //   // Update the experience
    //   const userExperiences = DataLayer.load("userExperiences", []);
    //   const expIndex = userExperiences.findIndex(exp => exp.id == experienceId);

    //   if (expIndex !== -1) {
    //     userExperiences[expIndex].responses = responses;
    //     userExperiences[expIndex].rawScore = parseFloat(rawScore.toFixed(1));
    //     userExperiences[expIndex].adjustedScore = parseFloat(adjustedScore.toFixed(1));
    //     userExperiences[expIndex].timestamp = new Date().toISOString();

    //     // Update estimated characteristics
    //     userExperiences[expIndex].socialIntensity = ActivitySystem.estimateSocialIntensity(
    //       userExperiences[expIndex].category, responses
    //     );
    //     userExperiences[expIndex].noiseLevel = ActivitySystem.estimateNoiseLevel(
    //       userExperiences[expIndex].category, responses
    //     );
    //     userExperiences[expIndex].crowdSize = ActivitySystem.estimateCrowdSize(
    //       userExperiences[expIndex].category, responses
    //     );

    //     DataLayer.save("userExperiences", userExperiences);

    //     // Update Firebase if user is authenticated
    //     if (currentFirebaseUser && authManager) {
    //       try {
    //         const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

    //         // Find the Firebase document for this experience
    //         const updatedData = {
    //           responses,
    //           rawScore: userExperiences[expIndex].rawScore,
    //           adjustedScore: userExperiences[expIndex].adjustedScore,
    //           socialIntensity: userExperiences[expIndex].socialIntensity,
    //           noiseLevel: userExperiences[expIndex].noiseLevel,
    //           crowdSize: userExperiences[expIndex].crowdSize,
    //           updatedAt: serverTimestamp()
    //         };

    //         // Note: We would need the Firebase document ID to update it
    //         // For now, just update locally
    //         console.log('Updated experience locally:', userExperiences[expIndex]);
    //       } catch (error) {
    //         console.error('Error updating experience in Firebase:', error);
    //       }
    //     }

    //     closeEditRatingModal();
    //     NotificationSystem.show("Rating updated successfully!", "success");

    //     // Refresh the current page if we're on feed or dashboard
    //     const currentPage = document.querySelector('.page:not(.hidden)').id;
    //     if (currentPage === 'feed') {
    //       FeedSystem.displayFeed();
    //     } else if (currentPage === 'dashboard') {
    //       updateDashboard();
    //     }
    //   } else {
    //     NotificationSystem.show("Experience not found.", "error");
    //   }
    // }

    // Function to format date with full month name
    function formatFullDate(dateString) {
      const date = new Date(dateString);
      const months = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];
      const month = months[date.getMonth()];
      const day = date.getDate();
      const year = date.getFullYear();
      return `${month} ${day}, ${year}`;
    }

    // Helper function to add ESC and click-outside functionality to modals
    function addModalListeners(modalId, closeFunction) {
      // Prevent body scrolling when modal opens
      document.body.classList.add('modal-open');

      // Add ESC key listener
      const handleEscKey = (event) => {
        if (event.key === 'Escape') {
          closeFunction();
          document.removeEventListener('keydown', handleEscKey);
        }
      };
      document.addEventListener('keydown', handleEscKey);

      // Add click outside to close
      const modal = document.getElementById(modalId);
      if (modal) {
        // Simple click outside detection
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            closeFunction();
            document.removeEventListener('keydown', handleEscKey);
          }
        });
      }
    }

    // Function to calculate distance between two coordinates (Haversine formula)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Radius of the Earth in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c; // Distance in kilometers
      return distance;
    }

    // Function to calculate group's central location
    function calculateGroupCenter(group) {
      const members = group.members;
      let totalLat = 0;
      let totalLng = 0;
      let validLocations = 0;

      members.forEach(member => {
        if (member.location) {
          totalLat += member.location.lat;
          totalLng += member.location.lng;
          validLocations++;
        } else {
          // No demo user fallback - Firebase only
          // Skip member without location data
        }
      });

      if (validLocations === 0) {
        // Default to Waterloo center if no locations available
        return { lat: 43.4643, lng: -80.5204 };
      }

      return {
        lat: totalLat / validLocations,
        lng: totalLng / validLocations
      };
    }

    // Function to get location-based group recommendations
    function getGroupLocationRecommendations(groupId) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find(g => g.id === groupId);
      if (!group) return;

      const groupCenter = calculateGroupCenter(group);
      const allExperiences = ActivitySystem.getAllExperiences();

      // Calculate distance from group center for each experience
      const experiencesWithDistance = allExperiences.map(exp => {
        if (exp.coordinates) {
          const distance = calculateDistance(
            groupCenter.lat, groupCenter.lng,
            exp.coordinates.lat, exp.coordinates.lng
          );
          return { ...exp, distanceFromGroup: distance };
        }
        return { ...exp, distanceFromGroup: Infinity };
      });

      // Get current user's experiences to exclude them
      const currentUser = DataLayer.load("currentUser");
      const userExperiences = DataLayer.load("userExperiences", []);
      const userExperienceNames = userExperiences.map(exp => exp.name.toLowerCase());

      // Filter experiences within 25km of group center, exclude user's own experiences, and sort by distance
      const nearbyExperiences = experiencesWithDistance
        .filter(exp => exp.distanceFromGroup <= 25 && !userExperienceNames.includes(exp.name.toLowerCase()))
        .sort((a, b) => a.distanceFromGroup - b.distanceFromGroup)
        .slice(0, 10);

      return {
        groupCenter,
        recommendations: nearbyExperiences
      };
    }

    // Community System
    const CommunitySystem = {
      currentSection: 'activities',

      showSection: (section) => {
        console.log('🏗️ CommunitySystem.showSection() called with section:', section);
        CommunitySystem.currentSection = section;

        // Update tab styling
        document.querySelectorAll('#activities-tab, #friendship-tab').forEach(tab => {
          tab.classList.remove('active');
          tab.classList.remove('btn');
          tab.classList.remove('btn-secondary');
          tab.classList.add('filter-tab');
        });

        const activeTab = document.getElementById(`${section}-tab`);
        if (activeTab) {
          activeTab.classList.remove('filter-tab');
          activeTab.classList.add('btn');
          if (section === 'friendship') {
            activeTab.classList.add('btn-secondary');
          }
          activeTab.classList.add('active');
        }

        // Show/hide sections
        const activitiesSection = document.getElementById('activities-section');
        const friendshipSection = document.getElementById('friendship-section');

        if (activitiesSection) {
          activitiesSection.style.display = section === 'activities' ? 'block' : 'none';
        }
        if (friendshipSection) {
          friendshipSection.style.display = section === 'friendship' ? 'block' : 'none';
        }

        // Initialize the appropriate system
        if (section === 'activities') {
          console.log('🏗️ Initializing FeedSystem for activities section');
          if (typeof FeedSystem !== 'undefined') {
            FeedSystem.init();
          } else {
            console.error('🏗️ FeedSystem not found!');
          }
        } else if (section === 'friendship') {
          console.log('🏗️ Initializing FriendsDiscoverySystem for friendship section');
          if (typeof FriendsDiscoverySystem !== 'undefined') {
            FriendsDiscoverySystem.init();
          } else {
            console.error('🏗️ FriendsDiscoverySystem not found!');
          }
        }
      },

      init: () => {
        // Set up initial button styling
        const activitiesTab = document.getElementById('activities-tab');
        const friendshipTab = document.getElementById('friendship-tab');

        if (activitiesTab && friendshipTab) {
          activitiesTab.classList.remove('filter-tab');
          activitiesTab.classList.add('btn');
          friendshipTab.classList.remove('filter-tab');
          friendshipTab.classList.add('btn', 'btn-secondary');
        }

        // Check friend requests immediately when community tab is opened
        if (currentFirebaseUser && FriendsDiscoverySystem) {
          setTimeout(async () => {
            await FriendsDiscoverySystem.loadFriendRequests();
            FriendsDiscoverySystem.updateFriendRequestBadge();
          }, 500);
        }

        CommunitySystem.showSection('activities');
      }
    };
    // Feed System
    const FeedSystem = {
      currentFilter: "all",
      searchTerm: "",
      pageSize: 20,
      store: { items: [], lastCursorValue: null, hasMore: true, isLoading: false, cacheKey: null },

      init: async () => {
        console.log('🚀 FeedSystem.init() called');

        // Initialize FriendsDiscoverySystem if not already done to load users
        if (typeof FriendsDiscoverySystem !== 'undefined') {
          if (!FriendsDiscoverySystem.isInitialized) {
            console.log('🚀 Initializing FriendsDiscoverySystem for user data...');
            await FriendsDiscoverySystem.init();
          } else if (typeof FriendsDiscoverySystem.loadAllUsersOptimized === 'function') {
            console.log('🚀 Loading users for feed rendering...');
            await FriendsDiscoverySystem.loadAllUsersOptimized();
          }
        }

        FeedSystem.resetAndLoad();
      },

      setFilter: (filter) => {
        FeedSystem.currentFilter = filter;

        // Update active dropdown items instead of tabs
        document.querySelectorAll("#activities-filter-menu .filter-dropdown-item").forEach((item) => {
          item.classList.remove("active");
        });

        // Find and activate the correct dropdown item
        const filterMap = {
          'all': 'All Activities',
          'similar': 'Similar Users',
          'high-rated': 'Top Rated',
          'recent': 'Recent',
          'nearby': 'Near Me'
        };

        const filterText = filterMap[filter] || 'All Activities';
        const targetItem = Array.from(document.querySelectorAll("#activities-filter-menu .filter-dropdown-item"))
          .find(item => item.textContent.trim().includes(filterText));

        if (targetItem) {
          targetItem.classList.add("active");
          // Update button text
          const textElement = document.getElementById('activities-filter-text');
          if (textElement) {
            textElement.textContent = filterText;
          }
        }

        FeedSystem.resetAndLoad();
      },

      filterFeed: () => {
        FeedSystem.searchTerm = document
          .getElementById("feed-search")
          .value.toLowerCase();
        FeedSystem.resetAndLoad();
      },

      getCacheKey: () => {
        return `FEED_${FeedSystem.currentFilter}_${FeedSystem.searchTerm || ''}_${FeedSystem.pageSize}`;
      },

      resetAndLoad: async () => {
        console.log('🔄 FeedSystem.resetAndLoad() called');
        console.log('🔄 Cache key:', FeedSystem.getCacheKey());

        FeedSystem.store = { items: [], lastCursorValue: null, hasMore: true, isLoading: false, cacheKey: FeedSystem.getCacheKey() };
        const cached = CacheSystem.get(FeedSystem.store.cacheKey, CacheSystem.CACHE_DURATIONS.ACTIVITIES);
        console.log('🔄 Cached data found:', !!cached);

        if (cached) {
          console.log('🔄 Using cached data, items count:', cached.items?.length || 0);
          FeedSystem.store = { ...FeedSystem.store, ...cached };
          DataLayer.save('allExperiences', FeedSystem.store.items);
          console.log('🔄 Calling displayFeed with cached data');
          FeedSystem.displayFeed();

          // Update load more button visibility
          const loadMoreContainer = document.getElementById('load-more-container');
          if (loadMoreContainer) {
            loadMoreContainer.style.display = FeedSystem.store.hasMore ? 'block' : 'none';
          }

          // Prefetch next page silently
          console.log('🔄 Prefetching next page');
          FeedSystem.loadNextPage(true).catch(() => { });
        } else {
          console.log('🔄 No cache, loading from Firebase');
          await FeedSystem.loadNextPage(false);
        }
      },

      loadNextPage: async (isPrefetch = false) => {
        console.log('📥 FeedSystem.loadNextPage() called, isPrefetch:', isPrefetch);
        console.log('📥 Current store state:', {
          isLoading: FeedSystem.store.isLoading,
          hasMore: FeedSystem.store.hasMore,
          itemsCount: FeedSystem.store.items?.length || 0,
          lastCursor: FeedSystem.store.lastCursorValue
        });

        if (FeedSystem.store.isLoading || !FeedSystem.store.hasMore) {
          console.log('📥 Skipping load - isLoading:', FeedSystem.store.isLoading, 'hasMore:', FeedSystem.store.hasMore);
          return;
        }
        if (!currentFirebaseUser || !authManager) {
          console.log('📥 Skipping load - no user or auth manager');
          return;
        }

        FeedSystem.store.isLoading = true;
        console.log('📥 Starting Firebase query...');

        try {
          const { collection, query, where, orderBy, limit, startAfter, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          let q;
          const expCol = collection(authManager.db, 'experiences');
          console.log('📥 Building query for filter:', FeedSystem.currentFilter);

          // Base: order by createdAt desc
          const buildBaseQuery = () => query(expCol, orderBy('createdAt', 'desc'), limit(FeedSystem.pageSize));

          if (FeedSystem.currentFilter === 'similar') {
            console.log('📥 Processing similar users filter');
            const personalityData = DataLayer.load('personalityScore');
            if (personalityData && typeof ActivitySystem.findSimilarUsers === 'function') {
              const similarUsers = await ActivitySystem.findSimilarUsers(personalityData.adjustmentFactor);
              const ids = similarUsers.slice(0, 10).map(u => u.id);
              console.log('📥 Similar user IDs:', ids);
              if (ids.length > 0) {
                // To avoid complex index requirements, use simpler query and filter in memory
                q = query(expCol, orderBy('createdAt', 'desc'), limit(FeedSystem.pageSize * 3)); // Get more to filter
              } else {
                q = buildBaseQuery();
              }
            } else {
              q = buildBaseQuery();
            }
          } else if (FeedSystem.currentFilter === 'high-rated') {
            console.log('📥 Processing top rated filter');
            // For top rated, we'll sort by rating in the display logic
            q = buildBaseQuery();
          } else if (FeedSystem.currentFilter === 'recent') {
            console.log('📥 Processing recent filter');
            // Avoid composite index requirement: fetch recent items and filter by user in-memory
            q = query(expCol, orderBy('createdAt', 'desc'), limit(FeedSystem.pageSize * 3));
          } else {
            q = buildBaseQuery();
          }

          if (FeedSystem.store.lastCursorValue) {
            console.log('📥 Adding startAfter cursor');
            q = query(q, startAfter(FeedSystem.store.lastCursorValue));
          }

          console.log('📥 Executing Firebase query...');
          const snapshot = await wrapRead(getDocs(q), 'getDocs', 'experiences', { paginated: true, filter: FeedSystem.currentFilter });
          console.log('📥 Firebase response - docs count:', snapshot.docs.length);

          const pageItems = snapshot.docs.map(d => {
            const data = d.data();
            return {
              id: data.id || d.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
              firebaseId: d.id, // Store Firebase document ID separately
              ...data,
              timestamp: data.createdAt?.toDate?.() || new Date()
            };
          });
          console.log('📥 Processed page items:', pageItems.length);

          FeedSystem.store.items = [...FeedSystem.store.items, ...pageItems];
          FeedSystem.store.lastCursorValue = snapshot.docs[snapshot.docs.length - 1]?.data()?.createdAt || FeedSystem.store.lastCursorValue;
          FeedSystem.store.hasMore = snapshot.size === FeedSystem.pageSize;

          console.log('📥 Updated store - total items:', FeedSystem.store.items.length, 'hasMore:', FeedSystem.store.hasMore);

          // Persist and cache
          DataLayer.save('allExperiences', FeedSystem.store.items);
          CacheSystem.set(FeedSystem.store.cacheKey, {
            items: FeedSystem.store.items,
            lastCursorValue: FeedSystem.store.lastCursorValue,
            hasMore: FeedSystem.store.hasMore
          });
          console.log('📥 Data saved to DataLayer and CacheSystem');

          if (!isPrefetch) {
            console.log('📥 Calling displayFeed for non-prefetch load');
            FeedSystem.displayFeed();

            // Update load more button visibility
            const loadMoreContainer = document.getElementById('load-more-container');
            if (loadMoreContainer) {
              loadMoreContainer.style.display = FeedSystem.store.hasMore ? 'block' : 'none';
            }
          } else {
            console.log('📥 Skipping displayFeed for prefetch');
          }
        } catch (error) {
          console.error('Paginated feed load failed:', error);
          // Render whatever we have so UI updates even on failure
          try {
            if (!isPrefetch && typeof FeedSystem.displayFeed === 'function') {
              FeedSystem.displayFeed();
            }
          } catch (_) { }
          // Soft notify user if index required
          if (typeof NotificationSystem !== 'undefined' && NotificationSystem.show) {
            NotificationSystem.show('Unable to load activities (index may be required). Showing available results.', 'warning');
          }
        } finally {
          FeedSystem.store.isLoading = false;
          console.log('📥 Load completed, isLoading set to false');
        }
      },

      displaySortedExperiences: (experiences, filterType) => {
        const personalityData = DataLayer.load("personalityScore");
        const userExperiences = DataLayer.load("userExperiences", []);
        const userExperienceNames = userExperiences.map((exp) =>
          exp.name.toLowerCase()
        );

        const feedContent = document.getElementById("feed-content");

        if (experiences.length === 0) {
          if (filterType === "nearby") {
            feedContent.innerHTML = `
              <div class="empty-state">
                <h3>No nearby experiences found</h3>
                <p>Try expanding your search radius or check if you have location access enabled.</p>
                <div style="margin-top: 1rem;">
                  <button class="btn btn-secondary" onclick="FeedSystem.setFilter('all')">
                    <i class="fas fa-globe"></i> Show All Experiences
                  </button>
                </div>
              </div>
            `;
          } else {
            feedContent.innerHTML = `
              <div class="empty-state">
                <h3>No activities found</h3>
                <p>Try adjusting your search or filters to see more results.</p>
              </div>
            `;
          }
          return;
        }

        // Add location info for nearby filter
        let locationInfo = "";
        if (filterType === "nearby") {
          locationInfo = `
            <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
              <p style="margin: 0; font-size: 0.9rem; color: #666;">
                <i class="fas fa-map-marker-alt"></i> 
                Showing ${experiences.length} experiences within 50km of your location. Sorted by distance.
              </p>
            </div>
          `;
        }

        feedContent.innerHTML = locationInfo + experiences
          .map((exp) => {
            // Get user information - prioritize Firebase data
            let user = null;
            if (exp.userId === "user-main" || exp.userId === currentFirebaseUser?.uid) {
              user = DataLayer.load("currentUser");
            } else if (typeof FriendsDiscoverySystem !== 'undefined' && Array.isArray(FriendsDiscoverySystem.allUsers)) {
              user = FriendsDiscoverySystem.allUsers.find(u => u.id === exp.userId);
            }

            // If still no user found, try cache
            if (!user && exp.userId !== "user-main") {
              const cachedUser = CacheSystem.get(`USER_${exp.userId}`, CacheSystem.CACHE_DURATIONS.USER_PROFILES);
              if (cachedUser) {
                user = cachedUser;
              }
            }

            // If no user found, create a fallback user object
            if (!user) {
              user = {
                id: exp.userId,
                displayName: 'Unknown User',
                username: 'unknown',
                avatar: '?',
                personalityType: 'Unknown',
                adjustmentFactor: 0,
                isPremium: false
              };
              console.log('🔍 Created fallback user for:', exp.userId);
            }

            // Check if user has been to this place
            const hasBeenThere = userExperienceNames.includes(
              exp.name.toLowerCase()
            );
            const isFriend = FriendsSystem.isFriend(exp.userId);

            // Calculate prediction for current user
            let predictionHtml = "";
            if (personalityData && exp.userId !== "user-main") {
              const prediction = ActivitySystem.predictRating(
                personalityData.adjustmentFactor,
                exp,
                user.adjustmentFactor,
                exp.rawScore
              );

              predictionHtml = `
                <div class="prediction-card">
                  <div class="prediction-score">Predicted for you: ${prediction.prediction.toFixed(
                1
              )}/10</div>
                  <div class="prediction-confidence">Confidence: ${(
                  prediction.confidence * 100
                ).toFixed(0)}%</div>
                </div>
              `;
            }

            // Add distance info when coordinates are available (regardless of filter)
            let distanceInfo = "";
            if (exp.coordinates && exp.coordinates.lat && exp.coordinates.lng) {
              distanceInfo = `<div id="distance-${exp.id}" style="font-size: 0.8rem; color: var(--secondary-color); margin-top: 0.3rem;">Calculating distance...</div>`;
              getUserLocationWithFallback()
                .then((position) => {
                  const distance = calculateDistance(
                    position.coords.latitude, position.coords.longitude,
                    exp.coordinates.lat, exp.coordinates.lng
                  );
                  const distanceElement = document.getElementById(`distance-${exp.id}`);
                  if (distanceElement) {
                    distanceElement.textContent = `${distance.toFixed(1)}km away`;
                  }
                })
                .catch(() => {
                  const distanceElement = document.getElementById(`distance-${exp.id}`);
                  if (distanceElement) {
                    distanceElement.remove();
                  }
                });
            }

            // Add friend status and rate button
            let actionButtons = "";
            if (exp.userId !== "user-main" && exp.userId !== currentFirebaseUser?.uid) {
              // Check pending status first
              const hasPendingRequest = typeof FriendsDiscoverySystem !== 'undefined' &&
                Array.isArray(FriendsDiscoverySystem.pendingRequests) &&
                FriendsDiscoverySystem.pendingRequests.some(r => r.toUserId === exp.userId);

              if (hasPendingRequest) {
                actionButtons += `
                  <button class="btn" data-pending-for="${exp.userId}" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem; background: #fbbf24; color: #1f2937; border: 1px solid #f59e0b;" onclick="FriendsDiscoverySystem.cancelPendingRequest('${exp.userId}')">
                    <i class="fas fa-clock"></i> Pending
                  </button>
                `;
              } else if (!isFriend) {
                actionButtons += `
                  <button class="btn btn-secondary" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem;"
                    onclick="FriendsSystem.addFriend('${exp.userId}')">
                    <i class="fas fa-user-plus"></i> Add Friend
                  </button>
                `;
              } else {
                actionButtons += `
                  <span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color); display: inline-block; margin-right: 0.5rem;">✓ Friend</span>
                `;
              }
            }

            if (!hasBeenThere) {
              actionButtons += `
                <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;"
                  onclick="ratePlace('${exp.name.replace(/'/g, "\\'")}', '${exp.category.replace(/'/g, "\\'")}', '${exp.location.replace(/'/g, "\\'")}', '${exp.description ? exp.description.replace(/'/g, "\\'") : ""}')">
                  <i class="fas fa-star"></i> Rate This Place
                </button>
              `;
            } else {
              actionButtons += `
                                  <span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color);">
                    ✓ Been There
                  </span>
              `;
            }

            return `
              <div class="experience-card" style="
                border: 1px solid #eee; 
                border-radius: 12px; 
                padding: 1.5rem; 
                background: white;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                transition: all 0.2s ease;
                margin-bottom: 1rem;
              " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
                 onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
                
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                  <div style="flex: 1;">
                    <h4 style="margin-bottom: 0.5rem;">${addCrownToPremiumUser(user.displayName, exp.userId)}</h4>
                    <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;">
                      <span style="background: var(--secondary-color); color: white; padding: 0.2rem 0.6rem; border-radius: 5px 0px 5px 5px; font-size: 0.8rem;">
                        ${exp.category}
                      </span>
                      <span style="color: #666;">
                        <i class="fas fa-map-marker-alt"></i> ${exp.location}
                      </span>
                    </div>
                    <h3 style="margin: 0 0 0.5rem 0; color: var(--primary-color); font-size: 1.2rem;">
                      ${exp.name}
                    </h3>
                    <p style="margin: 0; color: #555; line-height: 1.5; font-size: 0.95rem;">
                      ${exp.description}
                    </p>
                    ${distanceInfo}
                  </div>
                  <div style="text-align: right; min-width: 80px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">
                      ${exp.adjustedScore.toFixed(1)}
                    </div>
                    <div style="font-size: 0.8rem; color: #666;">Rating</div>
                  </div>
                </div>
                
                ${predictionHtml}
                
                      <div class="user-actions" style="gap: 0.5rem; margin-top: 1rem;">
                  ${actionButtons}
                </div>
              </div>
            `;
          })
          .join("");
      },

      displayFilteredExperiences: async (experiences, filterType) => {
        const personalityData = DataLayer.load("personalityScore");
        const userExperiences = DataLayer.load("userExperiences", []);
        const userExperienceNames = userExperiences.map((exp) =>
          exp.name.toLowerCase()
        );

        // Sort by distance for nearby filter, otherwise by timestamp
        if (filterType === "nearby") {
          // Get user's current location and sort by distance
          getUserLocationWithFallback()
            .then((position) => {
              const userLat = position.coords.latitude;
              const userLng = position.coords.longitude;

              // Sort by distance
              experiences.sort((a, b) => {
                if (!a.coordinates || !b.coordinates) return 0;
                const distanceA = calculateDistance(
                  userLat, userLng,
                  a.coordinates.lat, a.coordinates.lng
                );
                const distanceB = calculateDistance(
                  userLat, userLng,
                  b.coordinates.lat, b.coordinates.lng
                );
                return distanceA - distanceB;
              });

              // Display the sorted experiences
              FeedSystem.displaySortedExperiences(experiences, filterType);
            })
            .catch((error) => {
              console.error('Error getting location for sorting:', error);
              // Fallback: sort by timestamp
              experiences.sort(
                (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
              );
              FeedSystem.displaySortedExperiences(experiences, filterType);
            });
          return; // Exit early since we're handling the display asynchronously
        } else {
          // Sort based on filter type
          if (FeedSystem.currentFilter === 'high-rated') {
            // Sort by predicted rating for current user
            const personalityData = DataLayer.load('personalityScore');
            if (personalityData) {
              experiences.sort((a, b) => {
                const predictionA = ActivitySystem.predictRating(
                  personalityData.adjustmentFactor,
                  a,
                  (a.userId === "user-main" ? 0 : 0), // Firebase user adjustment factors loaded separately
                  a.rawScore
                );
                const predictionB = ActivitySystem.predictRating(
                  personalityData.adjustmentFactor,
                  b,
                  (b.userId === "user-main" ? 0 : 0), // Firebase user adjustment factors loaded separately
                  b.rawScore
                );
                return predictionB.prediction - predictionA.prediction;
              });
            } else {
              // Fallback to raw score
              experiences.sort((a, b) => (b.rawScore || 0) - (a.rawScore || 0));
            }
          } else if (FeedSystem.currentFilter === 'recent') {
            // Sort by timestamp (newest first) for recent filter
            experiences.sort(
              (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
            );
          } else {
            // Default sort by timestamp (newest first) for other filters
            experiences.sort(
              (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
            );
          }
        }

        const feedContent = document.getElementById("feed-content");

        if (experiences.length === 0) {
          if (filterType === "nearby") {
            feedContent.innerHTML = `
              <div class="empty-state">
                <h3>No nearby experiences found</h3>
                <p>Try expanding your search radius or check if you have location access enabled.</p>
                <div style="margin-top: 1rem;">
                  <button class="btn btn-secondary" onclick="FeedSystem.setFilter('all')">
                    <i class="fas fa-globe"></i> Show All Experiences
                  </button>
                </div>
              </div>
            `;
          } else {
            feedContent.innerHTML = `
              <div class="empty-state">
                <h3>No activities found</h3>
                <p>Try adjusting your search or filters to see more results.</p>
              </div>
            `;
          }
          return;
        }

        // Add location info for nearby filter
        let locationInfo = "";
        if (filterType === "nearby") {
          locationInfo = `
            <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
              <p style="margin: 0; font-size: 0.9rem; color: #666;">
                <i class="fas fa-map-marker-alt"></i> 
                Showing ${experiences.length} experiences within 50km of your location. Sorted by distance.
              </p>
            </div>
          `;
        }

        feedContent.innerHTML = locationInfo + experiences
          .map((exp) => {
            // Get user information - prioritize Firebase data
            let user = null;
            if (exp.userId === "user-main" || exp.userId === currentFirebaseUser?.uid) {
              user = DataLayer.load("currentUser");
            } else if (typeof FriendsDiscoverySystem !== 'undefined' && Array.isArray(FriendsDiscoverySystem.allUsers)) {
              user = FriendsDiscoverySystem.allUsers.find(u => u.id === exp.userId);
            }

            // If still no user found, try cache
            if (!user && exp.userId !== "user-main") {
              const cachedUser = CacheSystem.get(`USER_${exp.userId}`, CacheSystem.CACHE_DURATIONS.USER_PROFILES);
              if (cachedUser) {
                user = cachedUser;
              }
            }

            // If no user found, create a fallback user object
            if (!user) {
              user = {
                id: exp.userId,
                displayName: 'Unknown User',
                username: 'unknown',
                avatar: '?',
                personalityType: 'Unknown',
                adjustmentFactor: 0,
                isPremium: false
              };
              console.log('🔍 Created fallback user for:', exp.userId);
            }

            // Check if user has been to this place
            const hasBeenThere = userExperienceNames.includes(
              exp.name.toLowerCase()
            );
            const isFriend = FriendsSystem.isFriend(exp.userId);

            // Calculate prediction for current user
            let predictionHtml = "";
            if (personalityData && exp.userId !== "user-main") {
              const prediction = ActivitySystem.predictRating(
                personalityData.adjustmentFactor,
                exp,
                user.adjustmentFactor,
                exp.rawScore
              );

              predictionHtml = `
                <div class="prediction-card">
                  <div class="prediction-score">Predicted for you: ${prediction.prediction.toFixed(
                1
              )}/10</div>
                  <div class="prediction-confidence">Confidence: ${(
                  prediction.confidence * 100
                ).toFixed(0)}%</div>
                </div>
              `;
            }

            // Add distance info for nearby filter
            let distanceInfo = "";
            if (filterType === "nearby" && exp.coordinates) {
              // Get user's current location to calculate distance
              if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                  (position) => {
                    const distance = calculateDistance(
                      position.coords.latitude, position.coords.longitude,
                      exp.coordinates.lat, exp.coordinates.lng
                    );
                    // Update the distance display for this experience
                    const distanceElement = document.getElementById(`distance-${exp.id}`);
                    if (distanceElement) {
                      distanceElement.textContent = `${distance.toFixed(1)}km away`;
                    }
                  }
                );
              }
              distanceInfo = `<div id="distance-${exp.id}" style="font-size: 0.8rem; color: var(--secondary-color); margin-top: 0.3rem;">Calculating distance...</div>`;
            }

            // Add friend status and rate button
            let actionButtons = "";
            if (exp.userId !== "user-main" && exp.userId !== currentFirebaseUser?.uid) {
              // Check pending status first
              const hasPendingRequest = typeof FriendsDiscoverySystem !== 'undefined' &&
                Array.isArray(FriendsDiscoverySystem.pendingRequests) &&
                FriendsDiscoverySystem.pendingRequests.some(r => r.toUserId === exp.userId);

              if (hasPendingRequest) {
                actionButtons += `
                  <button class="btn" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem; background: #fbbf24; color: #1f2937; border: 1px solid #f59e0b;" disabled>
                    <i class="fas fa-clock"></i> Pending
                  </button>
                `;
              } else if (!isFriend) {
                actionButtons += `
                  <button class="btn btn-secondary" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem;"
                          onclick="FriendsSystem.addFriend('${exp.userId}')">
                    Add Friend
                  </button>
                `;
              } else {
                actionButtons += `
                  <span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color); display: inline-block; margin-right: 0.5rem;">✓ Friend</span>
                `;
              }

              if (!hasBeenThere) {
                actionButtons += `
                  <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;"
                          onclick="fillActivityForm('${exp.name}', '${exp.category}', '${exp.location}', '${exp.description.replace(/'/g, "\\'")}')">
                    Rate This Place
                  </button>
                `;
              }
            }

            return `
              <div class="feed-item">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                  <div style="flex: 1;">
                    <h4 style="margin-bottom: 0.5rem;">${addCrownToPremiumUser(user.displayName, exp.userId)}</h4>
                    <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;">
                      <span style="background: var(--secondary-color); color: white; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.8rem;">
                        ${exp.category}
                      </span>
                      <span style="color: #666;">
                        <i class="fas fa-map-marker-alt"></i> ${exp.location}
                      </span>
                    </div>
                    <h3 style="margin: 0 0 0.5rem 0; color: var(--primary-color); font-size: 1.2rem;">
                      ${exp.name} ${hasBeenThere ? '<span style="color: var(--primary-color);">✓ Visited</span>' : ''}
                    </h3>
                    ${exp.description ? `<p style=\"margin: 0; color: #555; line-height: 1.5; font-size: 0.95rem;\">${exp.description}</p>` : ''}
                    ${distanceInfo}
                  </div>
                  <div style="text-align: right; min-width: 80px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">
                      ${(exp.adjustedScore ?? exp.rawScore ?? 0).toFixed(1)}
                    </div>
                    <div style="font-size: 0.8rem; color: #666;">Rating</div>
                  </div>
                </div>
                ${predictionHtml}
                 <div class="user-actions" style="gap: 0.5rem; margin-top: 1rem;">
                  ${actionButtons}
                </div>
              </div>
            `;
          })
          .join("");
      },

      displayFeed: () => {
        console.log('🔍 FeedSystem.displayFeed() called');
        console.log('🔍 Current filter:', FeedSystem.currentFilter);
        console.log('🔍 Search term:', FeedSystem.searchTerm);
        console.log('🔍 Store items count:', FeedSystem.store?.items?.length || 0);
        console.log('🔍 Store hasMore:', FeedSystem.store?.hasMore);
        console.log('🔍 Store cacheKey:', FeedSystem.store?.cacheKey);

        const personalityData = DataLayer.load("personalityScore");

        // Use the new paginated data from store instead of old ActivitySystem
        const allExperiences = FeedSystem.store?.items || [];
        console.log('🔍 Using experiences from store:', allExperiences.length);

        const userExperiences = DataLayer.load("userExperiences", []);
        const userExperienceNames = userExperiences.map((exp) =>
          exp.name.toLowerCase()
        );

        let filteredExperiences = [...allExperiences];

        // Apply search filter
        if (FeedSystem.searchTerm) {
          filteredExperiences = filteredExperiences.filter(
            (exp) =>
              exp.name.toLowerCase().includes(FeedSystem.searchTerm) ||
              exp.category.toLowerCase().includes(FeedSystem.searchTerm) ||
              exp.location.toLowerCase().includes(FeedSystem.searchTerm) ||
              false // Demo user search removed - Firebase users handled elsewhere
          );
        }

        // Apply category filters
        console.log('🔍 Applying filter:', FeedSystem.currentFilter);

        if (FeedSystem.currentFilter === "similar" && personalityData) {
          console.log('🔍 Processing similar users filter');
          // Handle async similar users lookup
          ActivitySystem.findSimilarUsers(personalityData.adjustmentFactor)
            .then(similarUsers => {
              console.log('🔍 Found similar users:', similarUsers.length);
              const similarUserIds = similarUsers.slice(0, 10).map(user => user.id);

              // Filter experiences by similar user IDs (in-memory filtering)
              const similarExperiences = filteredExperiences.filter((exp) => {
                // Include current user's activities and similar users' activities
                return similarUserIds.includes(exp.userId) ||
                  exp.userId === "user-main" ||
                  (currentFirebaseUser && exp.userId === currentFirebaseUser.uid);
              });
              console.log('🔍 Filtered to similar experiences:', similarExperiences.length);

              // Sort by timestamp (newest first)
              similarExperiences.sort(
                (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
              );

              FeedSystem.displayFilteredExperiences(similarExperiences, "similar");
            })
            .catch(error => {
              console.error('Error finding similar users:', error);
              FeedSystem.displayFilteredExperiences([], "similar");
            });
          return; // Exit early since we're handling the display asynchronously
        } else if (FeedSystem.currentFilter === "high-rated") {
          console.log('🔍 Processing high-rated filter');

          // Calculate predicted scores for current user for all experiences
          const personalityData = DataLayer.load('personalityScore');
          if (personalityData) {
            // Add predicted scores and sort by them
            filteredExperiences = filteredExperiences.map(exp => {
              const prediction = ActivitySystem.predictRating(
                personalityData.adjustmentFactor,
                exp,
                (exp.userId === "user-main" ? 0 : 0), // Firebase user adjustment factors loaded separately
                exp.rawScore || exp.adjustedScore || 5.0
              );
              return {
                ...exp,
                predictedScore: prediction.prediction
              };
            }).filter(exp => {
              // Use a more reasonable threshold - top 60% or score >= 6.0
              const threshold = Math.max(6.0, exp.predictedScore >= 6.0);
              return exp.predictedScore >= 6.0 || exp.adjustedScore >= 6.0;
            });
          } else {
            // Fallback: use adjusted score with lower threshold
            filteredExperiences = filteredExperiences.filter(
              (exp) => (exp.adjustedScore || exp.rawScore || 0) >= 6.0
            );
          }

          console.log('🔍 High-rated experiences after filter:', filteredExperiences.length);
        } else if (FeedSystem.currentFilter === "recent") {
          console.log('🔍 Processing recent filter - showing only current user activities');
          const currentUser = DataLayer.load('currentUser');
          if (currentUser && currentFirebaseUser) {
            // Filter for only the current authenticated user's activities
            filteredExperiences = filteredExperiences.filter(
              (exp) => exp.userId === currentFirebaseUser.uid || exp.userId === "user-main"
            );
          } else if (currentUser) {
            // Fallback for non-authenticated users
            filteredExperiences = filteredExperiences.filter(
              (exp) => exp.userId === currentUser.id || exp.userId === "user-main"
            );
          } else {
            // No user logged in, show empty
            filteredExperiences = [];
          }
          console.log('🔍 Recent experiences after filter:', filteredExperiences.length);
        } else if (FeedSystem.currentFilter === "nearby") {
          console.log('🔍 Processing nearby filter');
          // Get user's current location and filter by actual distance
          getUserLocationWithFallback()
            .then((position) => {
              const userLat = position.coords.latitude;
              const userLng = position.coords.longitude;
              console.log('🔍 User location:', userLat, userLng);

              // Filter experiences by actual distance (within 50km)
              const nearbyExperiences = filteredExperiences.filter((exp) => {
                if (!exp.coordinates) {
                  console.log('🔍 Experience missing coordinates:', exp.name);
                  return false;
                }

                const distance = calculateDistance(
                  userLat, userLng,
                  exp.coordinates.lat, exp.coordinates.lng
                );

                console.log(`🔍 Distance to ${exp.name}: ${distance.toFixed(1)}km`);
                return distance <= 50; // Within 50km
              });
              console.log('🔍 Nearby experiences after distance filter:', nearbyExperiences.length);

              // If no nearby experiences found, try to get more from the database
              if (nearbyExperiences.length === 0) {
                console.log('🔍 No nearby experiences found in current data, loading more from Firebase...');
                FeedSystem.loadNearbyExperiencesFromFirebase(userLat, userLng)
                  .then((firebaseNearby) => {
                    if (firebaseNearby.length > 0) {
                      console.log('🔍 Found', firebaseNearby.length, 'nearby experiences from Firebase');
                      FeedSystem.displayFilteredExperiences(firebaseNearby, "nearby");
                    } else {
                      // Show fallback message with action to add experiences
                      FeedSystem.displayEmptyNearbyState();
                    }
                  })
                  .catch(() => FeedSystem.displayEmptyNearbyState());
                return;
              }

              // Sort by distance
              nearbyExperiences.sort((a, b) => {
                const distanceA = calculateDistance(
                  userLat, userLng,
                  a.coordinates.lat, a.coordinates.lng
                );
                const distanceB = calculateDistance(
                  userLat, userLng,
                  b.coordinates.lat, b.coordinates.lng
                );
                return distanceA - distanceB;
              });

              // Update the feed with nearby experiences
              FeedSystem.displayFilteredExperiences(nearbyExperiences, "nearby");
            })
            .catch((error) => {
              console.error('Error getting location for nearby filter:', error);
              // Fallback: show experiences with location data or encourage adding location
              const locationExperiences = filteredExperiences.filter(
                (exp) => exp.coordinates || (exp.location && exp.location !== "Not specified")
              );
              console.log('🔍 Fallback location experiences:', locationExperiences.length);

              if (locationExperiences.length > 0) {
                FeedSystem.displayFilteredExperiences(locationExperiences, "nearby");
              } else {
                FeedSystem.displayLocationPermissionError();
              }
            });
          return; // Exit early since we're handling the display asynchronously
        }

        // Sort by timestamp (newest first)
        filteredExperiences.sort(
          (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
        );
        console.log('🔍 Final filtered experiences after sorting:', filteredExperiences.length);

        const feedContent = document.getElementById("feed-content");
        console.log('🔍 Feed content element:', feedContent);

        if (filteredExperiences.length === 0) {
          console.log('🔍 No experiences to display, showing empty state');
          feedContent.innerHTML = `
        <div class="empty-state">
          <h3>No activities found</h3>
          <p>Try adjusting your search or filters to see more results.</p>
        </div>
      `;
          return;
        }

        console.log('🔍 Rendering', filteredExperiences.length, 'experiences to feed');
        feedContent.innerHTML = filteredExperiences
          .map((exp) => {
            console.log('🔍 Rendering experience:', exp.name, 'by user:', exp.userId);

            // Improved user lookup with proactive loading
            let user = null;
            if (exp.userId === "user-main") {
              user = DataLayer.load("currentUser");
            } else {
              // Check current user for match (covers Firebase authenticated users)
              const currentUser = DataLayer.load("currentUser");
              if (currentUser && currentUser.id === exp.userId) {
                user = currentUser;
                // Demo users removed - Firebase only
              } else if (typeof FriendsDiscoverySystem !== 'undefined' && Array.isArray(FriendsDiscoverySystem.allUsers)) {
                // Look up in real Firebase users
                user = FriendsDiscoverySystem.allUsers.find(u => u.id === exp.userId);
              }
            }

            // If still no user found, try to load immediately from Firebase
            if (!user && exp.userId !== "user-main" && typeof authManager !== 'undefined') {
              // Try to fetch user data synchronously from cache or queue for async load
              const cachedUser = CacheSystem.get(`USER_${exp.userId}`, CacheSystem.CACHE_DURATIONS.USER_PROFILES);
              if (cachedUser) {
                user = cachedUser;
                console.log('🔍 Found cached user:', user.displayName);
              } else {
                // Queue this user for async loading and trigger display refresh
                if (typeof FriendsDiscoverySystem !== 'undefined' && FriendsDiscoverySystem.queueUserForLoading) {
                  FriendsDiscoverySystem.queueUserForLoading(exp.userId);
                  // Set a delayed refresh to update the display when user data loads
                  setTimeout(() => {
                    if (FeedSystem.displayFeed) FeedSystem.displayFeed();
                  }, 2000);
                }
              }
            }

            // If still no user found, create a fallback user object but with more info
            if (!user) {
              console.log('🔍 No user found for experience:', exp.userId, '- creating fallback user');
              user = {
                id: exp.userId,
                displayName: 'Loading User...',
                username: 'loading',
                avatar: '...',
                adjustmentFactor: 0,
                personalityType: 'Loading...',
                isPremium: false
              };
            }

            // Check if user has been to this place
            const hasBeenThere = userExperienceNames.includes(
              exp.name.toLowerCase()
            );
            const isFriend = FriendsSystem.isFriend(exp.userId);

            // Calculate prediction for current user
            let predictionHtml = "";
            if (personalityData && exp.userId !== "user-main") {
              const prediction = ActivitySystem.predictRating(
                personalityData.adjustmentFactor,
                exp,
                user.adjustmentFactor,
                exp.rawScore
              );

              predictionHtml = `
          <div class="prediction-card">
            <div class="prediction-score">Predicted for you: ${prediction.prediction.toFixed(
                1
              )}/10</div>
            <div class="prediction-confidence">Confidence: ${(
                  prediction.confidence * 100
                ).toFixed(0)}%</div>
          </div>
        `;
            }

            // Distance display whenever coordinates are present
            let distanceInfo = "";
            if (exp.coordinates && exp.coordinates.lat && exp.coordinates.lng) {
              distanceInfo = `<div id="distance-${exp.id}" style="font-size: 0.8rem; color: var(--secondary-color); margin-top: 0.3rem;">Calculating distance...</div>`;
              getUserLocationWithFallback()
                .then((position) => {
                  const distance = calculateDistance(
                    position.coords.latitude, position.coords.longitude,
                    exp.coordinates.lat, exp.coordinates.lng
                  );
                  const distanceElement = document.getElementById(`distance-${exp.id}`);
                  if (distanceElement) {
                    distanceElement.textContent = `${distance.toFixed(1)}km away`;
                  }
                })
                .catch(() => {
                  const distanceElement = document.getElementById(`distance-${exp.id}`);
                  if (distanceElement) {
                    distanceElement.remove();
                  }
                });
            }

            // Add friend status and rate/edit buttons
            let actionButtons = "";
            if (exp.userId !== "user-main" && exp.userId !== currentFirebaseUser?.uid) {
              // Check pending status first
              const hasPendingRequest = typeof FriendsDiscoverySystem !== 'undefined' &&
                Array.isArray(FriendsDiscoverySystem.pendingRequests) &&
                FriendsDiscoverySystem.pendingRequests.some(r => r.toUserId === exp.userId);

              if (hasPendingRequest) {
                actionButtons += `
            <button class="btn" data-pending-for="${exp.userId}" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem; background: #fbbf24; color: #1f2937; border: 1px solid #f59e0b;" onclick="FriendsDiscoverySystem.cancelPendingRequest('${exp.userId}')">
              <i class="fas fa-clock"></i> Pending
            </button>
          `;
              } else if (!isFriend) {
                actionButtons += `
            <button class="btn btn-secondary" style="font-size: 0.8rem; padding: 6px 12px; margin-right: 0.5rem;" onclick="FriendsSystem.addFriend('${exp.userId}')">
              <i class="fas fa-user-plus"></i> Add Friend
            </button>
          `;
              } else {
                actionButtons += `
                  <span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color); display: inline-block; margin-right: 0.5rem;">✓ Friend</span>
                `;
              }

              // Use Near Me style: show Rate This Place for places user hasn't rated
              if (!hasBeenThere) {
                const safeDesc = (exp.description || '').replace(/'/g, "\\'");
                actionButtons += `
                  <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;" onclick="ratePlace('${exp.name.replace(/'/g, "\\'")}', '${exp.category.replace(/'/g, "\\'")}', '${exp.location.replace(/'/g, "\\'")}', '${safeDesc}')">
                    <i class="fas fa-star"></i> Rate This Place
                  </button>
                `;
              }
            } else {
              // For current user's experiences, show edit button
              actionButtons += `
            <button class="btn btn-secondary" style="font-size: 0.8rem; padding: 6px 12px;"
                    onclick="editUserExperience('${exp.id || exp.name}')">
              <i class="fas fa-edit"></i> Edit
            </button>
          `;
            }

            // Resolve live presence if available
            let presenceOnline = false;
            let presenceActive = false;
            if (typeof FriendsDiscoverySystem !== 'undefined' && Array.isArray(FriendsDiscoverySystem.allUsers)) {
              const live = FriendsDiscoverySystem.allUsers.find(u => u.id === exp.userId);
              if (live) {
                presenceOnline = !!live.isOnline;
                presenceActive = !!live.isActive;
              }
            }
            if (!presenceOnline && user && typeof user.isOnline === 'boolean') {
              presenceOnline = user.isOnline;
            }

            // Use the unified Experience Card style across all tabs
            return `
              <div class="experience-card" style="
                border: 1px solid #eee; 
                border-radius: 12px; 
                padding: 1.5rem; 
                background: white;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                transition: all 0.2s ease;
                margin-bottom: 1rem;
              " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
                 onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                  <div style="flex: 1;">
                    <h4 style="margin-bottom: 0.5rem;">${addCrownToPremiumUser(user.displayName, exp.userId)}</h4>
                    <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;">
                      <span style="background: var(--secondary-color); color: white; padding: 0.2rem 0.6rem; border-radius: 5px 0px 5px 5px; font-size: 0.8rem;">
                        ${exp.category}
                      </span>
                      <span style="color: #666;">
                        <i class="fas fa-map-marker-alt"></i> ${exp.location}
                      </span>
                    </div>
                    <h3 style="margin: 0 0 0.5rem 0; color: var(--primary-color); font-size: 1.2rem;">
                      ${exp.name} ${hasBeenThere ? '<span style="color: var(--primary-color);">✓ Visited</span>' : ''}
                    </h3>
                    ${exp.description ? `<p style=\"margin: 0; color: #555; line-height: 1.5; font-size: 0.95rem;\">${exp.description}</p>` : ''}
                    ${distanceInfo}
                  </div>
                  <div style="text-align: right; min-width: 80px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">
                      ${(exp.adjustedScore ?? exp.rawScore ?? 0).toFixed(1)}
                    </div>
                    <div style="font-size: 0.8rem; color: #666;">Rating</div>
                  </div>
                </div>
                ${predictionHtml}
                <div class="user-actions" style="gap: 0.5rem; margin-top: 1rem;">
                  ${actionButtons}
                </div>
              </div>
            `;
          })
          .join("");

        // Load more control
        console.log('🔍 Checking for load more button. Store hasMore:', FeedSystem.store?.hasMore);
        if (FeedSystem.store && FeedSystem.store.hasMore) {
          console.log('🔍 Adding load more button');
          feedContent.innerHTML += `
            <div style="display:flex; justify-content:center; margin:16px 0;">
              <button class="btn btn-secondary" onclick="FeedSystem.loadNextPage(false)">Load More</button>
            </div>
          `;
        } else {
          console.log('🔍 No load more button needed');
        }
      },

      // Load nearby experiences from Firebase when none found locally
      loadNearbyExperiencesFromFirebase: async (userLat, userLng) => {
        try {
          if (!authManager) return [];

          const { collection, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const experiencesCollection = collection(authManager.db, 'experiences');
          const snapshot = await wrapRead(getDocs(experiencesCollection), 'getDocs', 'experiences', { source: 'nearby' });

          const nearbyExperiences = [];
          snapshot.forEach((doc) => {
            const data = doc.data();
            if (data.coordinates) {
              const distance = calculateDistance(
                userLat, userLng,
                data.coordinates.lat, data.coordinates.lng
              );

              if (distance <= 50) { // Within 50km
                nearbyExperiences.push({
                  id: data.id || doc.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
                  firebaseId: doc.id, // Store Firebase document ID separately
                  ...data,
                  distance,
                  timestamp: data.createdAt?.toDate?.() || new Date()
                });
              }
            }
          });

          // Sort by distance
          nearbyExperiences.sort((a, b) => a.distance - b.distance);

          // Cache the results for future use
          const currentUser = DataLayer.load('currentUser');
          if (currentUser) {
            CacheSystem.set(`NEARBY_${currentUser.id}`, nearbyExperiences);
          }

          return nearbyExperiences.slice(0, 20); // Limit to 20 results
        } catch (error) {
          console.error('Error loading nearby experiences from Firebase:', error);
          return [];
        }
      },

      // Display empty state for nearby when no experiences found
      displayEmptyNearbyState: () => {
        const feedContent = document.getElementById("feed-content");
        feedContent.innerHTML = `
          <div class="empty-state">
            <h3><i class="fas fa-map-marker-alt"></i> No Nearby Experiences</h3>
            <p>No activities have been shared within 50km of your location yet.</p>
            <div style="margin-top: 1.5rem;">
              <button class="btn" onclick="showPage('activities')">
                <i class="fas fa-plus-circle"></i> Be the First to Share!
              </button>
              <button class="btn btn-secondary" onclick="FeedSystem.setFilter('all')" style="margin-left: 0.5rem;">
                <i class="fas fa-globe"></i> View All Activities
              </button>
            </div>
          </div>
        `;
      },

      // Display location permission error state
      displayLocationPermissionError: () => {
        const feedContent = document.getElementById("feed-content");
        feedContent.innerHTML = `
          <div class="empty-state">
            <h3><i class="fas fa-location-slash"></i> Location Access Needed</h3>
            <p>To see nearby activities, please enable location access in your browser settings.</p>
            <div style="margin-top: 1.5rem;">
              <button class="btn" onclick="navigator.geolocation.getCurrentPosition(() => { FeedSystem.setFilter('nearby'); }, () => { NotificationSystem.show('Location access denied', 'warning'); })">
                <i class="fas fa-location-arrow"></i> Try Again
              </button>
              <button class="btn btn-secondary" onclick="FeedSystem.setFilter('all')" style="margin-left: 0.5rem;">
                <i class="fas fa-globe"></i> View All Activities
              </button>
            </div>
          </div>
        `;
      },
    };
    // Weather API integration for activity recommendations
    const WeatherSystem = {
      // Get weather data for a specific location and date
      async getWeatherData(lat, lng, date) {
        try {
          console.log(`🌤️ Fetching weather for: lat=${lat}, lng=${lng}, date=${date}`);
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,weathercode&timezone=auto&start_date=${date}&end_date=${date}`;
          console.log(`🌤️ Weather API URL: ${url}`);

          const response = await fetch(url);
          console.log(`🌤️ Weather API response status: ${response.status}`);

          if (!response.ok) {
            throw new Error(`Weather API responded with status: ${response.status}`);
          }

          const data = await response.json();
          console.log(`🌤️ Weather API response data:`, data);

          if (data.daily && data.daily.time && data.daily.time.length > 0) {
            const index = 0; // First (and only) day

            // Validate that all required fields exist
            if (data.daily.temperature_2m_max &&
              data.daily.temperature_2m_min &&
              data.daily.precipitation_probability_max &&
              data.daily.weathercode) {

              const weatherData = {
                maxTemp: data.daily.temperature_2m_max[index],
                minTemp: data.daily.temperature_2m_min[index],
                precipitation: data.daily.precipitation_probability_max[index],
                weatherCode: data.daily.weathercode[index],
                date: data.daily.time[index]
              };
              console.log(`🌤️ Parsed weather data:`, weatherData);
              return weatherData;
            } else {
              console.log(`🌤️ Missing required weather fields in API response`);
              return null;
            }
          }
          console.log(`🌤️ No weather data found in response`);
          return null;
        } catch (error) {
          console.error('🌤️ Error fetching weather data from Open-Meteo:', error);
        }
      },

      // Get weather for multiple days
      async getWeatherForDays(lat, lng, dates) {
        try {
          console.log(`🌤️ Getting weather for ${dates.length} days`);
          const weatherPromises = dates.map(date => this.getWeatherData(lat, lng, date));
          const results = await Promise.all(weatherPromises);
          console.log(`🌤️ Weather results:`, results);

          // Filter out null results and ensure we have valid data
          const validResults = results.filter(result => result !== null);
          console.log(`🌤️ Valid weather results:`, validResults);

          return validResults;
        } catch (error) {
          console.error(`🌤️ Error getting weather for multiple days:`, error);
          return [];
        }
      },

      // Get weather description from WMO code
      getWeatherDescription(code) {
        const weatherCodes = {
          0: "Clear sky",
          1: "Mainly clear",
          2: "Partly cloudy",
          3: "Overcast",
          45: "Foggy",
          48: "Depositing rime fog",
          51: "Light drizzle",
          53: "Moderate drizzle",
          55: "Dense drizzle",
          56: "Light freezing drizzle",
          57: "Dense freezing drizzle",
          61: "Slight rain",
          63: "Moderate rain",
          65: "Heavy rain",
          66: "Light freezing rain",
          67: "Heavy freezing rain",
          71: "Slight snow",
          73: "Moderate snow",
          75: "Heavy snow",
          77: "Snow grains",
          80: "Slight rain showers",
          81: "Moderate rain showers",
          82: "Violent rain showers",
          85: "Slight snow showers",
          86: "Heavy snow showers",
          95: "Thunderstorm",
          96: "Thunderstorm with slight hail",
          99: "Thunderstorm with heavy hail"
        };
        return weatherCodes[code] || "Unknown";
      },

      // Get activity weather suitability score (0-10)
      getActivityWeatherScore(activity, weather) {
        if (!weather) return 5; // Neutral if no weather data

        const activityType = activity.category?.toLowerCase() || '';
        const temp = (weather.maxTemp + weather.minTemp) / 2;
        const precipitation = weather.precipitation;
        const isRainy = weather.weatherCode >= 51 && weather.weatherCode <= 67;
        const isSnowy = weather.weatherCode >= 71 && weather.weatherCode <= 86;
        const isStormy = weather.weatherCode >= 95;

        let score = 5; // Base score

        // Temperature considerations
        if (activityType.includes('outdoor') || activityType.includes('park') || activityType.includes('hiking')) {
          if (temp >= 15 && temp <= 25) score += 3; // Perfect outdoor weather
          else if (temp >= 10 && temp <= 30) score += 1; // Acceptable
          else score -= 2; // Too hot/cold
        }

        // Precipitation considerations
        if (activityType.includes('outdoor') || activityType.includes('park') || activityType.includes('hiking')) {
          if (precipitation < 20) score += 3; // Low chance of rain - clear weather bonus
          else if (precipitation < 50) score += 0; // Moderate chance
          else score -= 3; // High chance of rain
        }

        // Indoor activities are less affected by weather
        if (activityType.includes('indoor') || activityType.includes('museum') || activityType.includes('cafe') || activityType.includes('restaurant')) {
          // Indoor activities are neutral to weather - no bonus for rain
          score += 0; // Neutral
        }

        // General weather bonuses/penalties
        if (precipitation < 20 && !isRainy && !isSnowy) score += 2; // Strong bonus for clear weather
        if (isRainy) score -= 1; // Penalty for rainy weather
        if (isStormy) score -= 2;
        if (temp < -10 || temp > 35) score -= 1;

        return Math.max(0, Math.min(10, score)); // Clamp between 0-10
      },

      // Get best weather day from multiple options
      async getBestWeatherDay(lat, lng, dates, activities) {
        // Validate that we have dates to process
        if (!dates || dates.length === 0) {
          console.error(`🌤️ No dates provided to getBestWeatherDay`);
          return null;
        }

        const weatherData = await this.getWeatherForDays(lat, lng, dates);
        const scores = [];

        for (let i = 0; i < dates.length; i++) {
          const weather = weatherData[i];

          // Skip if no weather data for this day
          if (!weather) {
            continue;
          }

          let dayScore = 0;

          // Calculate average weather score for all activities
          for (const activity of activities) {
            dayScore += this.getActivityWeatherScore(activity, weather);
          }

          const finalScore = dayScore / activities.length;

          // Ensure the date is one of the input dates
          if (!dates.includes(dates[i])) {
            console.error(`🌤️ Date ${dates[i]} is not in input dates:`, dates);
            continue;
          }

          scores.push({
            date: dates[i],
            weather: weather,
            score: finalScore,
            weatherDescription: weather ? this.getWeatherDescription(weather.weatherCode) : 'Unknown'
          });
        }

        // Check if we have any valid scores
        if (scores.length === 0) {
          console.log(`🌤️ No valid weather scores found`);
          return null;
        }

        // Find the best day
        const bestDay = scores.reduce((best, current) =>
          current.score > best.score ? current : best
        );



        // Validate bestDay has weather data
        if (!bestDay || !bestDay.weather) {
          console.log(`🌤️ Best day has no weather data`);
          return null;
        }

        // Ensure the selected date is one of the input dates
        if (!dates.includes(bestDay.date)) {
          console.error(`🌤️ Selected date ${bestDay.date} is not in input dates:`, dates);
          return null;
        }

        // Generate reason for selection
        const temp = (bestDay.weather.maxTemp + bestDay.weather.minTemp) / 2;
        const precipitation = bestDay.weather.precipitation;
        const weatherCode = bestDay.weather.weatherCode;

        let reason = '';

        // Temperature-based reasoning
        if (temp >= 15 && temp <= 25) {
          reason += 'Perfect temperature for outdoor activities';
        } else if (temp >= 10 && temp <= 30) {
          reason += 'Comfortable temperature range';
        } else if (temp < 10) {
          reason += 'Cooler weather, good for indoor activities';
        } else {
          reason += 'Warm weather, suitable for various activities';
        }

        // Precipitation-based reasoning
        if (precipitation < 20) {
          reason += ' with very low chance of rain';
        } else if (precipitation < 50) {
          reason += ' with moderate weather conditions';
        } else {
          reason += ' despite higher precipitation chance';
        }

        // Weather condition reasoning
        if (weatherCode >= 0 && weatherCode <= 3) {
          reason += '. Clear to partly cloudy skies provide ideal conditions.';
        } else if (weatherCode >= 51 && weatherCode <= 67) {
          reason += '. Rainy weather is perfect for indoor activities.';
        } else if (weatherCode >= 71 && weatherCode <= 86) {
          reason += '. Snowy conditions are great for winter activities.';
        } else {
          reason += '. Weather conditions are suitable for your planned activities.';
        }

        return {
          ...bestDay,
          reason: reason
        };
      }
    };

    // AI Itinerary Generator
    const AIItineraryGenerator = {
      generateItinerary: async (groupData, tripDetails) => {
        const prompt = `You are an expert trip planner. Based on the following group information and trip details, create a detailed day-by-day itinerary.

Group Information:
- Group Name: ${groupData.name}
- Group Description: ${groupData.description}
- Group Size: ${groupData.members.length} people
- Members and their personality types:
${groupData.members
            .map(
              (member) =>
                `  • ${addCrownToPremiumUser(member.displayName, member.userId)}: ${member.personalityType} (Adjustment Factor: ${member.adjustmentFactor})`
            )
            .join("\n")}

Trip Details:
- Duration: ${tripDetails.duration} days
- Location: ${tripDetails.location}
- Budget Level: ${tripDetails.budget}
- Interests: ${tripDetails.interests}
- Special Requirements: ${tripDetails.requirements || "None"}

Based on the group's personality mix and preferences, create EXACTLY ${tripDetails.duration} days (no more, no less) that balances social activities for extroverts and quieter experiences for introverts. 

IMPORTANT SCHEDULING RULES:
1. Account for travel time between activities (typically 15-45 minutes depending on distance)
2. If an activity takes 2 hours and starts at 9:00 AM, the next activity should start no earlier than 11:30 AM (2 hours + 30 minutes travel time)
3. Include realistic travel times in the duration field
4. Don't schedule activities too close together - allow buffer time for travel and preparation
5. Consider opening hours and peak times for venues

Include specific venue suggestions, timing, and explain why each activity suits the group's energy levels.

Return your response in the following JSON format:
{
  "overview": "Brief overview of the itinerary approach",
  "tripDetails": {
    "duration": ${tripDetails.duration},
    "location": "${tripDetails.location}",
    "budget": "${tripDetails.budget}",
    "interests": "${tripDetails.interests}",
    "requirements": "${tripDetails.requirements || ""}"
  },
  "days": [
    {
      "day": 1,
      "theme": "Day theme",
      "activities": [
        {
          "time": "9:00 AM",
          "activity": "Activity name",
          "location": "Venue/Location",
          "duration": "2 hours",
          "description": "Brief description",
          "energyLevel": "low/medium/high",
          "socialIntensity": "low/medium/high",
          "whyThisWorks": "Explanation for this group"
        }
      ]
    }
  ],
  "tips": ["Tip 1", "Tip 2", "Tip 3"]
}

IMPORTANT: Create exactly ${tripDetails.duration} days in the "days" array, numbered from 1 to ${tripDetails.duration}.

Only return the JSON, no additional text.`;

        try {
          const payload = {
            messages: [{ role: "user", content: prompt }],
          };

          const response = await fetch(
            "https://ai.hackclub.com/chat/completions",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(`API request failed: ${response.status}`);
          }

          const data = await response.json();
          const content = data.choices[0].message.content;

          // Clean and parse the response - handle <think> tags and code blocks
          let cleanedContent = content
            .replace(/```json\n?|\n?```/g, "")
            .trim();

          // Remove <think> tags and everything before the first {
          if (cleanedContent.includes("<think>")) {
            const jsonStart = cleanedContent.indexOf("{");
            if (jsonStart !== -1) {
              cleanedContent = cleanedContent.substring(jsonStart);
            }
          }

          // Remove any trailing </think> or similar tags
          const jsonEnd = cleanedContent.lastIndexOf("}");
          if (jsonEnd !== -1) {
            cleanedContent = cleanedContent.substring(0, jsonEnd + 1);
          }

          return JSON.parse(cleanedContent);
        } catch (error) {
          console.error("AI Itinerary Generation Error:", error);
          throw new Error("Failed to generate itinerary. Please try again.");
        }
      },
    };

    // Enhanced Groups System with AI Premium Features


    function showAIPremiumModal(groupId) {
      if (!AI_PREMIUM_ENABLED) {
        NotificationSystem.show(
          "Premium features are currently disabled.",
          "warning"
        );
        return;
      }

      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) return;

      const currentUser = DataLayer.load("currentUser");

      // Check if all group members have premium access
      const allMembersHavePremium = group.members.every(member => {
        if (member.userId === currentUser.id) {
          return currentUser.isPremium;
        } else {
          // Demo users removed - Firebase only
          return false;
        }
      });

      // Check if any members have premium access
      const anyMembersHavePremium = group.members.some(member => {
        if (member.userId === currentUser.id) {
          return currentUser.isPremium;
        } else {
          // Demo users removed - Firebase only
          return false;
        }
      });

      // If no members have premium, show upgrade modal
      if (!anyMembersHavePremium) {
        showPremiumUpgradeModal();
        return;
      }

      // If not all members have premium, show upgrade modal
      if (!allMembersHavePremium) {
        showPremiumUpgradeModal();
        return;
      }

      const modalHtml = `
    <div id="ai-premium-modal" class="modal">
      <div class="modal-content" style="max-width: 600px;">
        <button class="modal-close" onclick="closeAIPremiumModal()">&times;</button>
        <div class="modal-header">
          <h2 style="color: var(--secondary-color); display: flex; align-items: center; gap: 0.5rem;">
            <i class="fas fa-robot"></i> AI Premium Trip Planner
          </h2>
          <div style="background: var(--primary-gradient); color: var(--inverted-text-color); padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.8rem; font-weight: bold;">
            PREMIUM
          </div>
        </div>
        <div class="modal-body">
          <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--secondary-color);">✨ AI-Powered Group Itinerary</h4>
            <p style="margin: 0; font-size: 0.9rem; color: #666;">
              Our AI will analyze your group's personality types and create a personalized day-by-day itinerary 
              that balances everyone's energy preferences and interests.
            </p>
          </div>

          <form id="ai-trip-form" onsubmit="generateAIItinerary(event, ${groupId})">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
              <div class="form-group">
                <label for="trip-duration">Trip Duration *</label>
                <select id="trip-duration" class="form-control" required onchange="handleTripDurationChange()">
                  <option value="">Select duration</option>
                  <option value="1">1 Day</option>
                  <option value="2">2 Days</option>
                  <option value="3">3 Days</option>
                  <option value="4">4 Days</option>
                  <option value="5">5 Days</option>
                  <option value="7">1 Week</option>
                  <option value="custom">Custom Duration</option>
                </select>
                <input type="number" id="custom-duration" class="form-control" 
                       placeholder="Enter number of days" min="1" max="30" 
                       style="display: none; margin-top: 0.5rem;">
              </div>
              <div class="form-group">
                <label for="trip-budget">Budget Level *</label>
                <select id="trip-budget" class="form-control" required>
                  <option value="">Select budget</option>
                  <option value="budget">Budget-Friendly</option>
                  <option value="moderate">Moderate</option>
                  <option value="premium">Premium</option>
                  <option value="luxury">Luxury</option>
                </select>
              </div>
            </div>

            <div class="form-group">
              <label for="trip-location">Location/City *</label>
              <input type="text" id="trip-location" class="form-control" 
                     placeholder="e.g., New York City, Paris, Tokyo" required>
            </div>

            <div class="form-group">
              <label for="trip-interests">Group Interests *</label>
              <textarea id="trip-interests" class="form-control" rows="3" 
                        placeholder="e.g., museums, nightlife, food tours, outdoor activities, shopping, historical sites..." required></textarea>
            </div>

            <div class="form-group">
              <label for="trip-requirements">Special Requirements (Optional)</label>
              <textarea id="trip-requirements" class="form-control" rows="2" 
                        placeholder="e.g., dietary restrictions, accessibility needs, transportation preferences..."></textarea>
            </div>

            <div style="text-align: center; margin-top: 2rem;">
              <button type="submit" class="btn" style="background: var(--primary-gradient); color: var(--inverted-text-color); padding: 12px 24px;">
                <i class="fas fa-magic"></i> Generate AI Itinerary
              </button>
              <button type="button" class="btn btn-secondary" onclick="closeAIPremiumModal()">Cancel</button>
            </div>
          </form>

          <div id="ai-loading" class="ai-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>AI is crafting your perfect itinerary...</p>
          </div>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Prevent body scrolling when modal is open
      document.body.classList.add('modal-open');

      // Add ESC and click-outside functionality
      addModalListeners("ai-premium-modal", closeAIPremiumModal);
    }

    function closeAIPremiumModal() {
      const modal = document.getElementById("ai-premium-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function handleTripDurationChange() {
      const durationSelect = document.getElementById("trip-duration");
      const customDurationInput = document.getElementById("custom-duration");

      if (durationSelect.value === "custom") {
        customDurationInput.style.display = "block";
        customDurationInput.required = true;
      } else {
        customDurationInput.style.display = "none";
        customDurationInput.required = false;
      }
    }

    async function generateAIItinerary(event, groupId) {
      event.preventDefault();

      let duration = document.getElementById("trip-duration").value;
      if (duration === "custom") {
        duration = document.getElementById("custom-duration").value;
        if (!duration || duration < 1 || duration > 30) {
          NotificationSystem.show("Please enter a valid custom duration (1-30 days)", "error");
          return;
        }
      }
      const budget = document.getElementById("trip-budget").value;
      const location = document.getElementById("trip-location").value;
      const interests = document.getElementById("trip-interests").value;
      const requirements = document.getElementById("trip-requirements").value;

      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) return;

      // Show loading state
      document.getElementById("ai-trip-form").style.display = "none";
      document.getElementById("ai-loading").style.display = "block";

      const tripDetails = {
        duration,
        budget,
        location,
        interests,
        requirements,
      };

      // Retry logic - try up to 3 times
      let lastError = null;
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          console.log(`AI Itinerary generation attempt ${attempt}/3`);

          const itinerary = await AIItineraryGenerator.generateItinerary(
            group,
            tripDetails
          );

          // Save itinerary to group
          const groupIndex = groups.findIndex((g) => g.id === groupId);
          if (groupIndex !== -1) {
            groups[groupIndex].aiItinerary = {
              ...itinerary,
              tripDetails,
              generatedAt: new Date().toISOString(),
            };
            DataLayer.save("groups", groups);

            // Save to Firebase
            try {
              const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
              await wrapWrite(
                updateDoc(doc(authManager.db, 'groups', groupId), {
                  aiItinerary: {
                    ...itinerary,
                    tripDetails,
                    generatedAt: serverTimestamp()
                  },
                  updatedAt: serverTimestamp()
                }),
                'updateDoc',
                `groups/${groupId}`,
                { aiItinerary: true }
              );
              console.log('AI Itinerary saved to Firebase');
            } catch (error) {
              console.error('Error saving AI itinerary to Firebase:', error);
            }
          }

          closeAIPremiumModal();
          GroupsSystem.displayGroups();
          NotificationSystem.show(
            "AI Itinerary generated successfully!",
            "success"
          );

          // Scroll to the group with the new itinerary
          setTimeout(() => {
            const groupCard = document.querySelector(
              `[data-group-id="${groupId}"]`
            );
            if (groupCard) {
              groupCard.scrollIntoView({ behavior: "smooth" });
            }
          }, 500);

          return; // Success - exit the function

        } catch (error) {
          console.error(`AI Itinerary generation attempt ${attempt}/3 failed:`, error);
          lastError = error;

          // If this is not the last attempt, wait a bit before retrying
          if (attempt < 3) {
            console.log(`Retrying in 2 seconds...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
      }

      // All attempts failed
      console.error("All AI Itinerary generation attempts failed:", lastError);
      NotificationSystem.show(
        "Failed to generate itinerary after 3 attempts. Please try again later.",
        "error"
      );

      // Reset form
      document.getElementById("ai-loading").style.display = "none";
      document.getElementById("ai-trip-form").style.display = "block";
    }

    function renderAIItinerary(group) {
      if (!group.aiItinerary) return "";

      const itinerary = group.aiItinerary;

      return `
    <div class="ai-itinerary-section" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(31, 59, 115, 0.05) 0%, rgba(74, 144, 226, 0.05) 100%); border-radius: 15px; border: 2px solid rgba(31, 59, 115, 0.2);">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
        <h4 style="margin: 0; color: var(--secondary-color); display: flex; align-items: center; gap: 0.5rem;">
          <i class="fas fa-robot"></i> AI Generated Itinerary
        </h4>
        <button class="btn btn-secondary" onclick="GroupsSystem.saveItineraryToFirebase('${group.id}')" style="font-size: 0.8rem; padding: 6px 12px;">
          <i class="fas fa-save"></i> Save
        </button>
      </div>
      
      <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.8rem; font-size: 0.8rem;">
          <div><strong>Duration:</strong> ${itinerary.tripDetails.duration} days</div>
          <div><strong>Location:</strong> ${itinerary.tripDetails.location.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ')}</div>
          <div><strong>Budget:</strong> ${itinerary.tripDetails.budget.charAt(0).toUpperCase() + itinerary.tripDetails.budget.slice(1).toLowerCase()}</div>
        </div>
      </div>

      <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
        <p style="margin: 0; font-style: italic; color: #666; font-size: 0.9rem;">${itinerary.overview
        }</p>
      </div>

      <div class="itinerary-timeline" style="position: relative;">
        ${itinerary.days
          .map(
            (day, index) => `
          <div class="day-card" style="background: white; border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; border-left: 4px solid var(--secondary-color); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
              <div style="width: 40px; height: 40px; background: var(--primary-gradient); color: var(--inverted-text-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                ${day.day}
              </div>
              <div>
                <h5 style="margin: 0; color: #333;">Day ${day.day}</h5>
                <div style="color: var(--secondary-color); font-weight: bold; font-size: 0.9rem;">${day.theme
              }</div>
              </div>
            </div>
            
            <div class="activities-list">
              ${day.activities
                .map(
                  (activity, activityIndex) => `
    <div class="activity-item" style="display: flex; gap: 1rem; padding: 1rem; background: rgba(31, 59, 115, 0.05); border-radius: 8px; margin-bottom: 0.8rem; position: relative;">
      <div style="width: 60px; text-align: center; font-weight: bold; color: var(--secondary-color); flex-shrink: 0;">
        ${activity.time}
      </div>
      <div style="flex: 1;">
        <div style="font-weight: bold; margin-bottom: 0.3rem;">${activity.activity
                    }</div>
        <div style="color: #666; font-size: 0.9rem; margin-bottom: 0.3rem;">
          📍 ${activity.location} • ⏱️ ${activity.duration}
        </div>
        <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.5rem;">${activity.description
                    }</div>
        <div style="display: flex; gap: 1rem; font-size: 0.7rem;">
          <span style="background: ${activity.energyLevel === "high"
                      ? "#ff6b6b"
                      : activity.energyLevel === "medium"
                        ? "#ffd43b"
                        : "#51cf66"
                    }; color: white; padding: 0.2rem 0.5rem; border-radius: 10px;">
            Energy: ${activity.energyLevel}
          </span>
          <span style="background: ${activity.socialIntensity === "high"
                      ? "#ff6b6b"
                      : activity.socialIntensity === "medium"
                        ? "#ffd43b"
                        : "#51cf66"
                    }; color: white; padding: 0.2rem 0.5rem; border-radius: 10px;">
            Social: ${activity.socialIntensity}
          </span>
        </div>
        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--secondary-color); font-style: italic;">
          💡 ${activity.whyThisWorks}
        </div>
      </div>
      <div style="position: absolute; top: 0.5rem; right: 0.5rem; display: flex; gap: 0.3rem;">
        <button onclick="showAIEditModal(${group.id}, ${index}, ${activityIndex})" 
                style="background: var(--secondary-color); color: var(--inverted-text-color); border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center;" 
                title="Edit activity">
          ✏️
        </button>
        <button onclick="deleteActivity(${group.id}, ${index}, ${activityIndex})" 
                style="background: #ff6b6b; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center;" 
                title="Delete activity">
          🗑️
        </button>
      </div>
    </div>
  `
                )
                .join("")}
            </div>
          </div>
        `
          )
          .join("")}
      </div>

      <div style="background: white; padding: 1rem; border-radius: 10px; margin-top: 1rem;">
        <h5 style="margin: 0 0 0.8rem 0; color: var(--secondary-color);">💡 AI Tips for Your Group</h5>
        <ul style="margin: 0; padding-left: 1.2rem;">
          ${itinerary.tips
          .map(
            (tip) =>
              `<li style="margin-bottom: 0.3rem; color: #666; font-size: 0.9rem;">${tip}</li>`
          )
          .join("")}
        </ul>
      </div>

      <div style="text-align: center; margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
  <button class="btn" onclick="showAIAssistantModal(${group.id})" 
          style="font-size: 0.8rem; padding: 6px 12px; background: var(--primary-gradient); color: var(--inverted-text-color);">
    <i class="fas fa-robot"></i> AI Assistant
  </button>
  <button class="btn btn-secondary" onclick="regenerateItinerary(${group.id
        })" style="font-size: 0.8rem; padding: 6px 12px;">
    <i class="fas fa-redo"></i> Regenerate
  </button>
</div>
    </div>
  `;
    }

    async function renderGroupScheduling(group) {
      const currentUser = DataLayer.load("currentUser");
      const currentUserId = currentUser.id;

      // Check if all group members have premium access
      const allMembersHavePremium = group.members.every(member => {
        if (member.userId === currentUser.id) {
          return currentUser.isPremium;
        } else {
          // Demo users removed - Firebase only
          return false;
        }
      });

      // Check if any members have premium access
      const anyMembersHavePremium = group.members.some(member => {
        if (member.userId === currentUser.id) {
          return currentUser.isPremium;
        } else {
          // Demo users removed - Firebase only
          return false;
        }
      });

      // If no members have premium, don't show the scheduling section at all
      if (!anyMembersHavePremium) {
        return "";
      }

      // If not all members have premium, show upgrade message
      if (!allMembersHavePremium) {
        return `
          <div class="group-scheduling-section" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(74, 144, 226, 0.05) 0%, rgba(160, 200, 240, 0.05) 100%); border-radius: 15px; border: 2px solid rgba(74, 144, 226, 0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
              <h4 style="margin: 0; color: var(--primary-color); display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-calendar-alt"></i> Group Scheduling
              </h4>
            </div>
            <div style="background: white; padding: 2rem; border-radius: 10px; margin-bottom: 1rem; text-align: center;">
              <div style="font-size: 3rem; margin-bottom: 1rem;"><i class="fas fa-crown"></i></div>
              <h5 style="margin: 0 0 1rem 0; color: var(--primary-color);">Premium Feature</h5>
              <p style="margin: 0 0 1.5rem 0; color: #666; font-size: 0.9rem; line-height: 1.5;">
                All group members need Premium to use Group Scheduling. This ensures everyone can coordinate their availability together!
              </p>
              <div style="margin-top: 1rem; padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 8px;">
                <h6 style="margin: 0 0 0.5rem 0; color: var(--primary-color);">Group Members Premium Status:</h6>
                ${group.members.map(member => {
          const isPremium = member.userId === currentUser.id ?
            currentUser.isPremium :
            false; // Demo users removed - Firebase only
          return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem; font-size: 0.8rem;">
                      <span>${addCrownToPremiumUser(member.displayName, member.userId)}</span>
                      <span style="color: ${isPremium ? 'var(--success-color)' : 'var(--warning-color)'}; font-weight: bold;">
                        ${isPremium ? '✓ Premium' : '✗ Free'}
                      </span>
                    </div>
                  `;
        }).join('')}
              </div>
              <button class="btn" onclick="showPremiumUpgradeModal()" style="background: var(--primary-gradient); margin-top: 1rem;">
                <i class="fas fa-crown"></i> Upgrade to Premium
              </button>
            </div>
          </div>
        `;
      }

      // Initialize availability if not exists
      if (!group.availability) {
        group.availability = {};
      }

      // Get current week dates (next 7 days)
      const weekDates = [];
      const today = new Date();
      console.log('Today is:', today.toISOString().split('T')[0], '(', today.toLocaleDateString('en-US', { weekday: 'long' }), ')');
      console.log('Today raw:', today);
      console.log('Today getTime():', today.getTime());
      console.log('Today getDate():', today.getDate());
      console.log('Today getMonth():', today.getMonth());
      console.log('Today getFullYear():', today.getFullYear());

      for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + i);

        // Ensure we're getting the correct day name by using the date object directly
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const fullDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        // Use local date methods to avoid timezone issues
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateString = `${year}-${month}-${day}`;

        const dayInfo = {
          date: date,
          dayName: dayName,
          fullDate: fullDate,
          dateString: dateString
        };
        weekDates.push(dayInfo);
        console.log(`Day ${i}: ${dayInfo.dayName} (${dayInfo.dateString}) - ${date.toLocaleDateString('en-US', { weekday: 'long' })}`);
      }

      // Count available members for each day
      const availabilityCounts = weekDates.map(weekDate => {
        const availableMembers = group.members.filter(member => {
          const memberAvailability = group.availability[member.userId] || [];
          return memberAvailability.includes(weekDate.dateString);
        });
        return {
          ...weekDate,
          availableCount: availableMembers.length,
          totalCount: group.members.length
        };
      });

      // Debug: Log availability counts for each day
      console.log('Availability counts by day:');
      availabilityCounts.forEach(day => {
        console.log(`${day.dayName} (${day.dateString}): ${day.availableCount}/${day.totalCount} votes`);
      });

      // Debug: Log current user's availability
      const currentUserAvailability = group.availability[currentUser.id] || [];
      console.log('Current user availability:', currentUserAvailability);
      console.log('All group availability:', group.availability);

      // Debug: Check what each selected date corresponds to
      console.log('Week dates generated:');
      weekDates.forEach((day, index) => {
        console.log(`Day ${index}: ${day.dayName} (${day.dateString}) - ${day.date.toLocaleDateString('en-US', { weekday: 'long' })}`);
      });

      currentUserAvailability.forEach(dateString => {
        const dayInfo = weekDates.find(day => day.dateString === dateString);
        if (dayInfo) {
          console.log(`Selected date ${dateString} corresponds to ${dayInfo.dayName} (${dayInfo.fullDate})`);
        } else {
          console.log(`Selected date ${dateString} not found in week dates`);
        }
      });
      console.log('Group members:', group.members.map(m => ({ id: m.userId, name: m.displayName })));

      // Debug: Log each member's availability
      group.members.forEach(member => {
        const memberAvailability = group.availability[member.userId] || [];
        console.log(`Member ${member.displayName} (${member.userId}) availability:`, memberAvailability);
      });

      // Find best meeting day (most members available)
      // First, filter to only days that have at least 1 vote
      const daysWithVotes = availabilityCounts.filter(day => day.availableCount > 0);

      // If no days have votes, return null or default
      if (daysWithVotes.length === 0) {
        return `
          <div class="group-scheduling-section" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(74, 144, 226, 0.05) 0%, rgba(160, 200, 240, 0.05) 100%); border-radius: 15px; border: 2px solid rgba(74, 144, 226, 0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
              <h4 style="margin: 0; color: var(--primary-color); display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-calendar-alt"></i> Group Scheduling
              </h4>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="background: var(--primary-gradient); color: var(--inverted-text-color); padding: 0.2rem 0.6rem; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">
                  PREMIUM
                </div>
                ${allMembersHavePremium ? `
                  <button class="btn btn-secondary" onclick="showAvailabilityModal(${group.id})" style="font-size: 0.8rem; padding: 8px 16px;">
                    <i class="fas fa-edit"></i> Set My Availability
                  </button>
                ` : ''}
              </div>
            </div>
            <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
              <h5 style="margin: 0 0 1rem 0; color: var(--primary-color);">This Week's Availability</h5>
              <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 0.5rem;">
                ${availabilityCounts.map(day => `
                  <div style="
                    text-align: center; 
                    padding: 0.8rem 0.5rem; 
                    border-radius: 8px; 
                    border: 2px solid #e0e0e0;
                    background: white;
                    position: relative;
                  ">
                    <div style="font-weight: bold; font-size: 0.9rem; color: var(--primary-color);">${day.dayName}</div>
                    <div style="font-size: 0.8rem; color: #666; margin: 0.3rem 0;">${day.fullDate}</div>
                    <div style="font-size: 0.7rem; color: #666;">
                      ${day.availableCount}/${day.totalCount}
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div style="background: white; padding: 1rem; border-radius: 10px; border-left: 4px solid var(--warning-color);">
              <h5 style="margin: 0 0 0.5rem 0; color: var(--warning-color);">
                <i class="fas fa-info-circle"></i> No Availability Set
              </h5>
              <p style="margin: 0; font-size: 0.9rem; color: #666;">
                No members have set their availability for this week. Please set your availability to see recommendations.
              </p>
            </div>
          </div>
        `;
      }

      // Find the maximum availability count among days with votes
      const maxAvailability = Math.max(...daysWithVotes.map(day => day.availableCount));

      // Find all days that have the maximum availability count
      const tiedDays = daysWithVotes.filter(day => day.availableCount === maxAvailability);

      // Select the first tied day as the initial best day
      let bestDay = tiedDays[0];

      // Debug logging to understand what's happening
      console.log('Days with votes:', daysWithVotes.map(d => `${d.dayName}: ${d.availableCount}`));
      console.log('Tied days:', tiedDays.map(d => `${d.dayName}: ${d.availableCount}`));
      console.log('Selected best day:', bestDay.dayName);

      // Store tie information for display
      const wasTie = tiedDays.length > 1;
      const tieCount = tiedDays.length;

      // If there are ties, use weather to break the tie
      if (tiedDays.length > 1) {
        try {
          // Get location from group activities, user location, or group center
          let lat, lng;

          // Try to get location from first activity
          const firstActivity = group.activities && group.activities.length > 0 ? group.activities[0] : null;
          if (firstActivity && firstActivity.coordinates) {
            lat = firstActivity.coordinates.lat;
            lng = firstActivity.coordinates.lng;
          } else {
            // Try to get location from current user
            const currentUser = DataLayer.load("currentUser");
            if (currentUser && currentUser.location) {
              lat = currentUser.location.lat;
              lng = currentUser.location.lng;
            } else {
              // Calculate group center from member locations
              const memberLocations = group.members.map(member => {
                if (member.userId === currentUser.id) {
                  return currentUser.location;
                } else {
                  // Demo users removed - Firebase only
                  return null;
                }
              }).filter(loc => loc !== null);

              if (memberLocations.length > 0) {
                const avgLat = memberLocations.reduce((sum, loc) => sum + loc.lat, 0) / memberLocations.length;
                const avgLng = memberLocations.reduce((sum, loc) => sum + loc.lng, 0) / memberLocations.length;
                lat = avgLat;
                lng = avgLng;
              } else {
                // Fallback to Waterloo if no location data available
                lat = 43.4643;
                lng = -80.5204;
              }
            }
          }

          const tiedDates = tiedDays.map(day => day.dateString);

          console.log('Weather tie-breaker: evaluating dates:', tiedDates);
          console.log('Tied days for weather evaluation:', tiedDays.map(d => `${d.dayName} (${d.dateString}): ${d.availableCount} votes`));

          // Use group activities or create default activities for weather comparison
          let activitiesForWeather = group.activities || [];
          if (activitiesForWeather.length === 0) {
            activitiesForWeather = [
              { name: "Outdoor Activity", category: "Outdoor", coordinates: null },
              { name: "Park Visit", category: "Outdoor", coordinates: null },
              { name: "Restaurant", category: "Restaurant", coordinates: null },
              { name: "Cafe", category: "Cafe", coordinates: null }
            ];
          }

          const weatherBestDay = await WeatherSystem.getBestWeatherDay(lat, lng, tiedDates, activitiesForWeather);

          if (weatherBestDay) {
            console.log('Weather system selected:', weatherBestDay.date);
            bestDay = availabilityCounts.find(day => day.dateString === weatherBestDay.date) || bestDay;
            bestDay.weatherInfo = weatherBestDay;
            console.log('Final best day after weather:', bestDay.dayName);
          } else {
            console.log('No weather data available, keeping original selection:', bestDay.dayName);
          }
        } catch (error) {
          console.error('Error getting weather data for tie-breaking:', error);
        }
      }

      return `
        <div class="group-scheduling-section" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(74, 144, 226, 0.05) 0%, rgba(160, 200, 240, 0.05) 100%); border-radius: 15px; border: 2px solid rgba(74, 144, 226, 0.2);">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
            <h4 style="margin: 0; color: var(--primary-color); display: flex; align-items: center; gap: 0.5rem;">
              <i class="fas fa-calendar-alt"></i> Group Scheduling
            </h4>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <div style="background: var(--primary-gradient); color: var(--inverted-text-color); padding: 0.2rem 0.6rem; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">
                PREMIUM
              </div>
              ${allMembersHavePremium ? `
                <button class="btn btn-secondary" onclick="showAvailabilityModal(${group.id})" style="font-size: 0.8rem; padding: 8px 16px;">
                  <i class="fas fa-edit"></i> Set My Availability
                </button>
              ` : ''}
            </div>
          </div>
          
          ${allMembersHavePremium ? `
            <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem;">
              <h5 style="margin: 0 0 1rem 0; color: var(--primary-color);">This Week's Availability</h5>
              <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 0.5rem;">
                ${availabilityCounts.map(day => {
        const isAvailable = (group.availability[currentUserId] || []).includes(day.dateString);
        const availabilityPercent = (day.availableCount / day.totalCount) * 100;
        const isBestDay = day.dateString === bestDay.dateString && day.availableCount > 0;
        const wasTied = wasTie && day.availableCount === bestDay.availableCount && day.availableCount > 0;

        return `
                    <div style="
                      text-align: center; 
                      padding: 0.8rem 0.5rem; 
                      border-radius: 8px; 
                      border: 2px solid ${isBestDay ? 'var(--success-color)' : wasTied ? 'var(--warning-color)' : '#e0e0e0'};
                      background: ${isAvailable ? 'rgba(74, 144, 226, 0.1)' : 'white'};
                      position: relative;
                      ${isBestDay ? 'box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);' : wasTied ? 'box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);' : ''}
                    ">
                      <div style="font-weight: bold; font-size: 0.9rem; color: var(--primary-color);">${day.dayName}</div>
                      <div style="font-size: 0.8rem; color: #666; margin: 0.3rem 0;">${day.fullDate}</div>
                      <div style="font-size: 0.7rem; color: ${availabilityPercent >= 80 ? 'var(--success-color)' : availabilityPercent >= 50 ? 'var(--warning-color)' : '#666'};">
                        ${day.availableCount}/${day.totalCount}
                      </div>
                      ${isAvailable ? '<div style="position: absolute; top: 2px; right: 2px; color: var(--secondary-color); font-size: 0.6rem;">✓</div>' : ''}
                      ${isBestDay ? '<div style="position: absolute; bottom: -7px; left: 50%; transform: translateX(-50%); background: var(--success-color); color: white; padding: 1px 4px; border-radius: 4px; font-size: 0.6rem;">BEST</div>' : ''}
                      ${wasTied && !isBestDay ? '<div style="position: absolute; bottom: -7px; left: 50%; transform: translateX(-50%); background: var(--warning-color); color: white; padding: 1px 4px; border-radius: 4px; font-size: 0.6rem;">TIED</div>' : ''}
                    </div>
                  `;
      }).join('')}
              </div>
            </div>
          ` : `
            <div style="background: white; padding: 2rem; border-radius: 10px; margin-bottom: 1rem; text-align: center;">
              <div style="font-size: 3rem; margin-bottom: 1rem;"><i class="fas fa-crown"></i></div>
              <h5 style="margin: 0 0 1rem 0; color: var(--primary-color);">Premium Feature</h5>
              <p style="margin: 0 0 1.5rem 0; color: #666; font-size: 0.9rem; line-height: 1.5;">
                All group members need Premium to use Group Scheduling. This ensures everyone can coordinate their availability together!
              </p>
              <div style="margin-top: 1rem; padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 8px;">
                <h6 style="margin: 0 0 0.5rem 0; color: var(--primary-color);">Group Members Premium Status:</h6>
                ${group.members.map(member => {
        const isPremium = member.userId === currentUser.id ?
          currentUser.isPremium :
          false; // Demo users removed - Firebase only
        return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem; font-size: 0.8rem;">
                      <span>${addCrownToPremiumUser(member.displayName, member.userId)}</span>
                      <span style="color: ${isPremium ? 'var(--success-color)' : 'var(--warning-color)'}; font-weight: bold;">
                        ${isPremium ? '✓ Premium' : '✗ Free'}
                      </span>
                    </div>
                  `;
      }).join('')}
              </div>
              <button class="btn" onclick="showPremiumUpgradeModal()" style="background: var(--primary-gradient); margin-top: 1rem;">
                <i class="fas fa-crown"></i> Upgrade to Premium
              </button>
            </div>
          `}
          
          ${allMembersHavePremium ? `
            ${bestDay.availableCount > 0 ? `
              <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem; border-left: 4px solid var(--success-color);">
                <h5 style="margin: 0 0 0.5rem 0; color: var(--success-color);">
                  <i class="fas fa-check-circle"></i> Recommended Meeting Day
                </h5>
                <p style="margin: 0; font-size: 0.9rem; color: #666;">
                  <strong>${bestDay.dayName}, ${bestDay.fullDate}</strong> - ${bestDay.availableCount} out of ${bestDay.totalCount} members available
                  
                </p>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #666;">
                  Available members: ${group.members.filter(member => {
        const memberAvailability = group.availability[member.userId] || [];
        return memberAvailability.includes(bestDay.dateString);
      }).map(member => addCrownToPremiumUser(member.displayName, member.userId)).join(', ')}
                </div>
                ${bestDay.weatherInfo ? `
                  <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(74, 144, 226, 0.1); border-radius: 5px; font-size: 0.8rem;">
                                    <div style="margin-bottom: 0.5rem; font-weight: bold; color: var(--primary-color);">
                  <i class="fas fa-cloud-sun"></i> Weather Tie-Breaker Applied
                </div>
                <div style="margin-bottom: 0.3rem; font-size: 0.75rem; color: #666;">
                  ${tieCount} days had the same availability (${bestDay.availableCount}/${bestDay.totalCount}). 
                  This day was selected based on weather conditions for your group's activities.
                </div>
                    <div style="font-size: 0.8rem;">
                      <strong>Weather Forecast:</strong> ${bestDay.weatherInfo.weatherDescription} | 
                      High: ${bestDay.weatherInfo.weather.maxTemp}°C | 
                      Low: ${bestDay.weatherInfo.weather.minTemp}°C | 
                      Rain: ${bestDay.weatherInfo.weather.precipitation}%
                    </div>
                  </div>
                ` : ''}
              </div>
            ` : `
              <div style="background: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem; border-left: 4px solid var(--warning-color);">
                <h5 style="margin: 0 0 0.5rem 0; color: var(--warning-color);">
                  <i class="fas fa-exclamation-triangle"></i> No Common Availability
                </h5>
                <p style="margin: 0; font-size: 0.9rem; color: #666;">
                  No day this week works for everyone. Set your availability to find the best time!
                </p>
              </div>
            `}


          ` : ''}
        </div>
      `;
    }

    // Manual handler to fetch and persist user's location
    async function handleUpdateUserLocation() {
      try {
        const location = await getUserLocation();
        // Persist to Firebase as well
        await updateUserLocation(location);
        NotificationSystem.show("Location updated successfully!", "success");
        // Refresh the profile page to show updated location
        showPage("profile");
      } catch (error) {
        NotificationSystem.show("Could not get your location. Please check your browser permissions.", "warning");
        console.error("Error updating location:", error);
      }
    }

    // Function to get user's current location
    function getUserLocation() {
      return new Promise(async (resolve, reject) => {
        try {
          const position = await getUserLocationWithFallback();
          const location = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
          };

          // Update current user's location
          const currentUser = DataLayer.load("currentUser");
          currentUser.location = location;
          DataLayer.save("currentUser", currentUser);

          resolve(location);
        } catch (error) {
          reject(error);
        }
      });
    }



    // Function to recommend activities based on weather
    async function recommendActivitiesForWeather(group) {
      console.log(`🌤️ Starting weather recommendations for group:`, group.id);

      // If no activities, create general activity recommendations based on weather
      let activitiesToUse = group.activities || [];
      if (activitiesToUse.length === 0) {
        console.log(`🌤️ No activities found, creating general recommendations`);
        activitiesToUse = [
          { name: "Outdoor Activity", category: "Outdoor", coordinates: null },
          { name: "Indoor Activity", category: "Indoor", coordinates: null },
          { name: "Restaurant", category: "Restaurant", coordinates: null },
          { name: "Cafe", category: "Cafe", coordinates: null },
          { name: "Entertainment", category: "Entertainment", coordinates: null }
        ];
      }

      try {
        // Get location from group activities, user location, or group center
        let lat, lng;

        // Try to get location from first activity
        const firstActivity = group.activities && group.activities.length > 0 ? group.activities[0] : null;
        console.log(`🌤️ First activity:`, firstActivity);

        if (firstActivity && firstActivity.coordinates) {
          lat = firstActivity.coordinates.lat;
          lng = firstActivity.coordinates.lng;
          console.log(`🌤️ Using activity coordinates: lat=${lat}, lng=${lng}`);
        } else {
          // Try to get location from current user
          const currentUser = DataLayer.load("currentUser");
          console.log(`🌤️ Current user:`, currentUser);

          if (currentUser && currentUser.location) {
            lat = currentUser.location.lat;
            lng = currentUser.location.lng;
            console.log(`🌤️ Using user location: lat=${lat}, lng=${lng}`);
          } else {
            // Calculate group center from member locations
            const memberLocations = group.members.map(member => {
              if (member.userId === currentUser.id) {
                return currentUser.location;
              }
            }).filter(loc => loc !== null);

            console.log(`🌤️ Member locations:`, memberLocations);

            if (memberLocations.length > 0) {
              const avgLat = memberLocations.reduce((sum, loc) => sum + loc.lat, 0) / memberLocations.length;
              const avgLng = memberLocations.reduce((sum, loc) => sum + loc.lng, 0) / memberLocations.length;
              lat = avgLat;
              lng = avgLng;
              console.log(`🌤️ Using group center: lat=${lat}, lng=${lng}`);
            } else {
              // Fallback to Waterloo if no location data available
              lat = 43.4643;
              lng = -80.5204;
              console.log(`🌤️ Using fallback Waterloo: lat=${lat}, lng=${lng}`);
            }
          }
        }

        // Get weather for today and next few days
        const today = new Date();
        const dates = [];
        for (let i = 0; i < 3; i++) {
          const date = new Date(today);
          date.setDate(today.getDate() + i);
          dates.push(date.toISOString().split('T')[0]);
        }

        console.log(`🌤️ Getting weather for dates:`, dates);
        const weatherData = await WeatherSystem.getWeatherForDays(lat, lng, dates);
        console.log(`🌤️ Weather data received:`, weatherData);

        // Check if weatherData is valid
        if (!weatherData || !Array.isArray(weatherData) || weatherData.length === 0) {
          console.log(`🌤️ No valid weather data received`);
          return null;
        }

        const recommendations = [];

        for (let i = 0; i < weatherData.length; i++) {
          const weather = weatherData[i];
          console.log(`🌤️ Processing weather for day ${i}:`, weather);

          if (!weather) {
            console.log(`🌤️ No weather data for day ${i}`);
            continue;
          }

          // Score each activity for this weather
          const activityScores = activitiesToUse.map(activity => ({
            activity: activity,
            score: WeatherSystem.getActivityWeatherScore(activity, weather),
            weather: weather
          }));

          console.log(`🌤️ Activity scores for day ${i}:`, activityScores);

          // Sort by score and get top 2
          activityScores.sort((a, b) => b.score - a.score);
          const topActivities = activityScores.slice(0, 2);

          console.log(`🌤️ Top activities for day ${i}:`, topActivities);

          if (topActivities.length > 0 && weather) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const recommendation = {
              date: date,
              dateString: date.toISOString().split('T')[0],
              activities: topActivities,
              weather: weather
            };
            recommendations.push(recommendation);
            console.log(`🌤️ Added recommendation for day ${i}:`, recommendation);
          } else {
            console.log(`🌤️ Skipping recommendation for day ${i} - no activities or invalid weather data`);
          }
        }

        console.log(`🌤️ Final recommendations:`, recommendations);
        return recommendations;
      } catch (error) {
        console.error('Error getting weather-based recommendations:', error);
        return null;
      }
    }

    function showAvailabilityModal(groupId) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) return;

      const currentUser = DataLayer.load("currentUser");

      // Check if all group members have premium access
      const allMembersHavePremium = group.members.every(member => {
        if (member.userId === currentUser.id) {
          return currentUser.isPremium;
        } else {
          // Demo users removed - Firebase only
          return false;
        }
      });

      // Check if all members have premium
      if (!allMembersHavePremium) {
        showPremiumUpgradeModal();
        return;
      }
      const currentUserId = currentUser.id;

      // Initialize availability if not exists
      if (!group.availability) {
        group.availability = {};
      }

      // Get current week dates (next 7 days)
      const weekDates = [];
      const today = new Date();

      for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + i);

        // Ensure we're getting the correct day name by using the date object directly
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const fullDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        // Use local date methods to avoid timezone issues
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const dateString = `${year}-${month}-${day}`;

        weekDates.push({
          date: date,
          dayName: dayName,
          fullDate: fullDate,
          dateString: dateString
        });
      }

      // Get current user's availability
      const currentAvailability = group.availability[currentUserId] || [];

      const modalHtml = `
        <div id="availability-modal" class="modal">
          <div class="modal-content" style="max-width: 600px;">
            <button class="modal-close" onclick="closeAvailabilityModal()">&times;</button>
            <div class="modal-header">
              <h2 style="color: var(--primary-color);">📅 Set Your Availability</h2>
            </div>
            <div class="modal-body">
              <p style="margin-bottom: 1.5rem; color: #666; font-size: 0.9rem;">
                Select the days when you're available to meet with the group. This helps find the best time for everyone.
              </p>
              
              <form id="availability-form" onsubmit="saveAvailability(event, ${groupId})">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                  ${weekDates.map(day => {
        const isSelected = currentAvailability.includes(day.dateString);
        return `
                      <div style="
                        border: 2px solid ${isSelected ? 'var(--primary-color)' : '#e0e0e0'};
                        border-radius: 12px;
                        padding: 1rem;
                        background: ${isSelected ? 'rgba(74, 144, 226, 0.1)' : 'white'};
                        cursor: pointer;
                        transition: all 0.2s ease;
                        text-align: center;
                      " onclick="toggleDaySelection('${day.dateString}')">
                        <input type="checkbox" 
                               id="day-${day.dateString}" 
                               value="${day.dateString}" 
                               ${isSelected ? 'checked' : ''} 
                               style="display: none;">
                        <div style="font-weight: bold; color: var(--primary-color); margin-bottom: 0.5rem;">
                          ${day.dayName}
                        </div>
                        <div style="font-size: 0.9rem; color: #666;">
                          ${day.fullDate}
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: ${isSelected ? 'var(--primary-color)' : '#999'};">
                          ${isSelected ? '✓ Available' : 'Click to select'}
                        </div>
                      </div>
                    `;
      }).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 2rem;">
                  <button type="submit" class="btn" style="background: var(--primary-gradient);">
                    <i class="fas fa-save"></i> Save Availability
                  </button>
                  <button type="button" class="btn btn-secondary" onclick="closeAvailabilityModal()">
                    Cancel
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("availability-modal", closeAvailabilityModal);
    }

    function closeAvailabilityModal() {
      const modal = document.getElementById("availability-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function toggleDaySelection(dateString) {
      const checkbox = document.getElementById(`day-${dateString}`);
      const dayDiv = checkbox.parentElement;

      if (checkbox.checked) {
        checkbox.checked = false;
        dayDiv.style.borderColor = '#e0e0e0';
        dayDiv.style.background = 'white';
        dayDiv.querySelector('div:last-child').textContent = 'Click to select';
        dayDiv.querySelector('div:last-child').style.color = '#999';
      } else {
        checkbox.checked = true;
        dayDiv.style.borderColor = 'var(--primary-color)';
        dayDiv.style.background = 'rgba(74, 144, 226, 0.1)';
        dayDiv.querySelector('div:last-child').textContent = '✓ Available';
        dayDiv.querySelector('div:last-child').style.color = 'var(--primary-color)';
      }
    }
    async function saveAvailability(event, groupId) {
      event.preventDefault();

      const groups = DataLayer.load("groups", []);
      const groupIndex = groups.findIndex((g) => g.id === groupId);
      if (groupIndex === -1) return;

      const currentUser = DataLayer.load("currentUser");
      const currentUserId = currentUser.id;

      // Get selected dates
      const selectedDates = [];
      const checkboxes = document.querySelectorAll('#availability-form input[type="checkbox"]:checked');
      checkboxes.forEach(checkbox => {
        selectedDates.push(checkbox.value);
      });

      // Store expansion state before updating
      const content = document.getElementById(`group-content-${groupId}`);
      const wasExpanded = content && content.style.maxHeight !== "0px" && content.style.maxHeight !== "";

      // Update availability
      if (!groups[groupIndex].availability) {
        groups[groupIndex].availability = {};
      }
      groups[groupIndex].availability[currentUserId] = selectedDates;

      DataLayer.save("groups", groups);
      closeAvailabilityModal();

      // Update only the specific group content instead of re-rendering all groups
      await GroupsSystem.updateGroupContent(groupId);

      // Restore expansion state if it was expanded - use a longer delay to ensure all async updates are complete
      if (wasExpanded) {
        setTimeout(() => {
          const newContent = document.getElementById(`group-content-${groupId}`);
          const newIcon = document.getElementById(`expand-icon-${groupId}`);
          if (newContent && newIcon) {
            // Force a recalculation of the height
            newContent.style.maxHeight = "none";
            requestAnimationFrame(() => {
              newContent.style.maxHeight = newContent.scrollHeight + "px";
              newIcon.style.transform = "rotate(180deg)";
            });
          }
        }, 200); // Increased delay to ensure all async updates are complete
      }

      NotificationSystem.show("Availability updated successfully!", "success");
    }

    function regenerateItinerary(groupId) {
      if (
        confirm(
          "Are you sure you want to regenerate the itinerary? This will replace the current one."
        )
      ) {
        showAIPremiumModal(groupId);
      }
    }
    function showAIEditModal(groupId, dayIndex, activityIndex) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group || !group.aiItinerary) return;

      const activity = group.aiItinerary.days[dayIndex].activities[activityIndex];

      const modalHtml = `
    <div id="ai-edit-modal" class="modal">
      <div class="modal-content" style="max-width: 500px;">
        <button class="modal-close" onclick="closeAIEditModal()">&times;</button>
        <div class="modal-header">
          <h2 style="color: var(--secondary-color);">✏️ Edit Activity</h2>
        </div>
        <div class="modal-body">
          <form id="ai-edit-form" onsubmit="updateActivity(event, ${groupId}, ${dayIndex}, ${activityIndex})">
            <div class="form-group">
              <label for="edit-activity-name">Activity Name *</label>
              <input type="text" id="edit-activity-name" class="form-control" value="${activity.activity}" required>
            </div>
            <div class="form-group">
              <label for="edit-activity-location">Location *</label>
              <input type="text" id="edit-activity-location" class="form-control" value="${activity.location}" required>
            </div>
            <div class="form-group">
              <label for="edit-activity-time">Time *</label>
              <input type="text" id="edit-activity-time" class="form-control" value="${activity.time}" required>
            </div>
            <div class="form-group">
              <label for="edit-activity-duration">Duration *</label>
              <input type="text" id="edit-activity-duration" class="form-control" value="${activity.duration}" required>
            </div>
            <div class="form-group">
              <label for="edit-activity-description">Description</label>
              <textarea id="edit-activity-description" class="form-control" rows="3">${activity.description}</textarea>
            </div>
            <div style="text-align: center; margin-top: 2rem;">
              <button type="submit" class="btn">Save Changes</button>
              <button type="button" class="btn btn-secondary" onclick="closeAIEditModal()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Prevent body scrolling when modal is open
      document.body.classList.add('modal-open');

      // Add ESC and click-outside functionality
      addModalListeners("ai-edit-modal", closeAIEditModal);
    }

    function closeAIEditModal() {
      const modal = document.getElementById("ai-edit-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    async function updateActivity(event, groupId, dayIndex, activityIndex) {
      event.preventDefault();

      const groups = DataLayer.load("groups", []);
      const groupIndex = groups.findIndex((g) => g.id === groupId);
      if (groupIndex === -1) return;

      // Store expansion state before updating
      const content = document.getElementById(`group-content-${groupId}`);
      const wasExpanded = content && content.style.maxHeight !== "0px" && content.style.maxHeight !== "";

      const activity = groups[groupIndex].aiItinerary.days[dayIndex].activities[activityIndex];

      activity.activity = document.getElementById("edit-activity-name").value;
      activity.location = document.getElementById("edit-activity-location").value;
      activity.time = document.getElementById("edit-activity-time").value;
      activity.duration = document.getElementById("edit-activity-duration").value;
      activity.description = document.getElementById("edit-activity-description").value;

      DataLayer.save("groups", groups);
      closeAIEditModal();

      // Update only the specific group content instead of re-rendering all groups
      await GroupsSystem.updateGroupContent(groupId);

      // Restore expansion state if it was expanded
      if (wasExpanded) {
        setTimeout(() => {
          const newContent = document.getElementById(`group-content-${groupId}`);
          const newIcon = document.getElementById(`expand-icon-${groupId}`);
          if (newContent && newIcon) {
            newContent.style.maxHeight = newContent.scrollHeight + "px";
            newIcon.style.transform = "rotate(180deg)";
          }
        }, 100); // Small delay to ensure DOM is updated
      }

      NotificationSystem.show("Activity updated successfully!", "success");
    }

    function parseDuration(durationStr) {
      // Parse duration strings like "2 hours", "30 minutes", "1.5 hours"
      const match = durationStr.match(/(\d+(?:\.\d+)?)\s*(hour|minute|hr|min)s?/i);
      if (!match) return 60; // Default to 1 hour if can't parse

      const value = parseFloat(match[1]);
      const unit = match[2].toLowerCase();

      if (unit.includes('hour') || unit.includes('hr')) {
        return value * 60; // Convert to minutes
      } else if (unit.includes('minute') || unit.includes('min')) {
        return value;
      }
      return 60; // Default
    }

    function addMinutesToTime(timeStr, minutesToAdd) {
      // Parse time like "9:00 AM" and add minutes
      const [time, period] = timeStr.split(' ');
      let [hours, minutes] = time.split(':').map(Number);

      if (period === 'PM' && hours !== 12) hours += 12;
      if (period === 'AM' && hours === 12) hours = 0;

      const totalMinutes = hours * 60 + minutes + minutesToAdd;
      const newHours = Math.floor(totalMinutes / 60);
      const newMinutes = totalMinutes % 60;

      let displayHours = newHours;
      let newPeriod = 'AM';

      if (newHours >= 12) {
        newPeriod = 'PM';
        if (newHours > 12) displayHours = newHours - 12;
      }
      if (displayHours === 0) displayHours = 12;

      return `${displayHours}:${newMinutes.toString().padStart(2, '0')} ${newPeriod}`;
    }

    function rescheduleActivities(activities) {
      if (activities.length === 0) return activities;

      const rescheduled = [];
      let currentTime = activities[0].time;

      for (let i = 0; i < activities.length; i++) {
        const activity = { ...activities[i] };
        activity.time = currentTime;
        rescheduled.push(activity);

        // Calculate next start time
        const durationMinutes = parseDuration(activity.duration);
        const travelTime = 30; // Assume 30 minutes travel time between activities
        const totalTime = durationMinutes + travelTime;

        if (i < activities.length - 1) {
          currentTime = addMinutesToTime(currentTime, totalTime);
        }
      }

      return rescheduled;
    }

    async function deleteActivity(groupId, dayIndex, activityIndex) {
      if (!confirm("Are you sure you want to delete this activity?")) return;

      const groups = DataLayer.load("groups", []);
      const groupIndex = groups.findIndex((g) => g.id === groupId);
      if (groupIndex === -1) return;

      // Store expansion state before updating
      const content = document.getElementById(`group-content-${groupId}`);
      const wasExpanded = content && content.style.maxHeight !== "0px" && content.style.maxHeight !== "";

      // Remove the activity
      groups[groupIndex].aiItinerary.days[dayIndex].activities.splice(activityIndex, 1);

      // Reschedule remaining activities for this day
      if (groups[groupIndex].aiItinerary.days[dayIndex].activities.length > 0) {
        groups[groupIndex].aiItinerary.days[dayIndex].activities =
          rescheduleActivities(groups[groupIndex].aiItinerary.days[dayIndex].activities);
      }

      DataLayer.save("groups", groups);

      // Update only the specific group content instead of re-rendering all groups
      await GroupsSystem.updateGroupContent(groupId);

      // Restore expansion state if it was expanded
      if (wasExpanded) {
        setTimeout(() => {
          const newContent = document.getElementById(`group-content-${groupId}`);
          const newIcon = document.getElementById(`expand-icon-${groupId}`);
          if (newContent && newIcon) {
            newContent.style.maxHeight = newContent.scrollHeight + "px";
            newIcon.style.transform = "rotate(180deg)";
          }
        }, 100); // Small delay to ensure DOM is updated
      }

      NotificationSystem.show("Activity deleted and schedule updated!", "success");
    }

    function showAIAssistantModal(groupId) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group || !group.aiItinerary) return;

      const modalHtml = `
    <div id="ai-assistant-modal" class="modal">
      <div class="modal-content" style="max-width: 600px;">
        <button class="modal-close" onclick="closeAIAssistantModal()">&times;</button>
        <div class="modal-header">
          <h2 style="color: var(--secondary-color); display: flex; align-items: center; gap: 0.5rem;">
            <i class="fas fa-robot"></i> AI Assistant
          </h2>
        </div>
        <div class="modal-body">
          <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--secondary-color);">🤖 Ask me to modify your itinerary!</h4>
            <p style="margin: 0; font-size: 0.9rem; color: #666;">
              Examples: "Make day 2 more relaxing", "Replace the museum with outdoor activities", "Add more food options"
            </p>
          </div>

          <form id="ai-assistant-form" onsubmit="handleAIAssistantRequest(event, ${groupId})">
            <div class="form-group">
              <label for="ai-request">What would you like me to change? *</label>
              <textarea id="ai-request" class="form-control" rows="4" 
                        placeholder="e.g., Make the first day less crowded, add more restaurants, replace nightlife with quiet activities..." required></textarea>
            </div>

            <div style="text-align: center; margin-top: 2rem;">
              <button type="submit" class="btn" style="background: var(--primary-gradient); color: var(--inverted-text-color); padding: 12px 24px;">
                <i class="fas fa-magic"></i> Apply Changes
              </button>
              <button type="button" class="btn btn-secondary" onclick="closeAIAssistantModal()">Cancel</button>
            </div>
          </form>

          <div id="ai-assistant-loading" class="ai-loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>AI is updating your itinerary...</p>
          </div>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("ai-assistant-modal", closeAIAssistantModal);
    }

    function closeAIAssistantModal() {
      const modal = document.getElementById("ai-assistant-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function showGroupLocationRecommendations(groupId) {
      const recommendations = getGroupLocationRecommendations(groupId);
      if (!recommendations || recommendations.recommendations.length === 0) {
        NotificationSystem.show("No nearby places found for this group.", "warning");
        return;
      }

      const modalHtml = `
        <div id="group-location-modal" class="modal">
          <div class="modal-content" style="max-width: 700px;">
            <button class="modal-close" onclick="closeGroupLocationModal()">&times;</button>
            <div class="modal-header">
              <h2 style="color: var(--secondary-color); display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-map-marker-alt"></i> Places Near Your Group
              </h2>
            </div>
            <div class="modal-body">
              <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
                <h4 style="margin: 0 0 0.5rem 0; color: var(--secondary-color);">📍 Group Center</h4>
                <p style="margin: 0; font-size: 0.9rem; color: #666;">
                  Based on the average location of all group members in Waterloo, Ontario
                </p>
              </div>

              <div style="display: grid; gap: 1rem;">
                ${recommendations.recommendations.map((place, index) => `
                  <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; border: 1px solid #eee; border-radius: 8px; background: white;">
                    <div style="flex: 1;">
                      <div style="font-weight: bold; margin-bottom: 0.3rem; color: var(--primary-color);">${place.name}</div>
                      <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.3rem;">${place.category} • ${place.location}</div>
                      <div style="font-size: 0.8rem; color: #888;">
                        <i class="fas fa-map-marker-alt"></i> ${place.distanceFromGroup.toFixed(1)} km from group center
                      </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <div style="text-align: center; margin-right: 1rem;">
                        <div style="font-size: 0.9rem; font-weight: bold; color: var(--secondary-color);">${place.adjustedScore.toFixed(1)}</div>
                        <div style="font-size: 0.7rem; color: #666;">Rating</div>
                      </div>
                      <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;" 
                              onclick="fillActivityForm('${place.name}', '${place.category}', '${place.location}', '${place.description}')">
                        Rate This Place
                      </button>
                    </div>
                  </div>
                `).join('')}
              </div>

              <div style="text-align: center; margin-top: 2rem;">
                <button type="button" class="btn btn-secondary" onclick="closeGroupLocationModal()">Close</button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("group-location-modal", closeGroupLocationModal);
    }

    function closeGroupLocationModal() {
      const modal = document.getElementById("group-location-modal");
      if (modal) {
        modal.remove();
        // Remove any remaining event listeners
        document.removeEventListener('keydown', (event) => {
          if (event.key === 'Escape') closeGroupLocationModal();
        });
      }
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function showPremiumUpgradeModal() {
      const modalHtml = `
        <div id="premium-upgrade-modal" class="modal">
          <div class="modal-content" style="max-width: 500px;">
            <button class="modal-close" onclick="closePremiumUpgradeModal()">&times;</button>
            <div class="modal-header">
              <h2 style="color: var(--secondary-color); display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-crown"></i> Upgrade to Premium
              </h2>
            </div>
            <div class="modal-body">
              <div style="background: linear-gradient(135deg, #FFD700, #FFA500); color: white; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; text-align: center;">
                <h3 style="margin: 0 0 1rem 0;">✨ Premium Features</h3>
                <div style="display: grid; gap: 1rem; text-align: left;">
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-infinity"></i>
                    <span><strong>Unlimited Groups</strong> - Create as many groups as you want</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-robot"></i>
                    <span><strong>AI Trip Planner</strong> - Get personalized itineraries</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-magic"></i>
                    <span><strong>AI Assistant</strong> - Modify plans with AI help</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-chart-line"></i>
                    <span><strong>Advanced Analytics</strong> - Detailed group insights</span>
                  </div>
                </div>
              </div>

              <div style="text-align: center; margin-top: 2rem;">
                <button class="btn" style="background: linear-gradient(135deg, #FFD700, #FFA500); color: #333; padding: 12px 24px; font-weight: bold;">
                  <i class="fas fa-crown"></i> Upgrade Now - $9.99/month
                </button>
                <button type="button" class="btn btn-secondary" onclick="closePremiumUpgradeModal()">Maybe Later</button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);

      // Prevent body scrolling when modal is open
      document.body.classList.add('modal-open');

      // Add ESC and click-outside functionality
      addModalListeners("premium-upgrade-modal", closePremiumUpgradeModal);
    }

    function closePremiumUpgradeModal() {
      const modal = document.getElementById("premium-upgrade-modal");
      if (modal) {
        modal.remove();
        // Remove any remaining event listeners
        document.removeEventListener('keydown', (event) => {
          if (event.key === 'Escape') closePremiumUpgradeModal();
        });
      }
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }



    async function handleAIAssistantRequest(event, groupId) {
      event.preventDefault();

      const request = document.getElementById("ai-request").value;
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group || !group.aiItinerary) return;

      // Show loading state
      document.getElementById("ai-assistant-form").style.display = "none";
      document.getElementById("ai-assistant-loading").style.display = "block";

      try {
        const prompt = `You are an expert trip planner. I have an existing itinerary and need you to modify it based on a specific request.

Current Group Information:
- Group Name: ${group.name}
- Group Description: ${group.description}
- Members and their personality types:
${group.members
            .map(
              (member) =>
                `  • ${addCrownToPremiumUser(member.displayName, member.userId)}: ${member.personalityType} (Adjustment Factor: ${member.adjustmentFactor})`
            )
            .join("\n")}

Current Itinerary:
${JSON.stringify(group.aiItinerary, null, 2)}

User Request: "${request}"

IMPORTANT INSTRUCTIONS:
1. If the user requests changes to duration, location, or budget, update the tripDetails accordingly
2. If the user asks for a different number of days, create exactly that many days (no more, no less)
3. Maintain the same JSON structure and format
4. Keep the balance for the group's personality mix
5. Return the COMPLETE modified itinerary including updated tripDetails if needed

SCHEDULING RULES:
- Account for travel time between activities (15-45 minutes)
- If an activity takes 2 hours and starts at 9:00 AM, next activity should start no earlier than 11:30 AM
- Include realistic travel times in duration fields
- Don't schedule activities too close together
- Consider opening hours and peak times

Only return the JSON, no additional text.`;

        const payload = {
          messages: [{ role: "user", content: prompt }],
        };

        const response = await fetch("https://ai.hackclub.com/chat/completions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        const content = data.choices[0].message.content;

        // Clean and parse the response
        let cleanedContent = content.replace(/```json\n?|\n?```/g, "").trim();

        if (cleanedContent.includes("<think>")) {
          const jsonStart = cleanedContent.indexOf("{");
          if (jsonStart !== -1) {
            cleanedContent = cleanedContent.substring(jsonStart);
          }
        }

        const jsonEnd = cleanedContent.lastIndexOf("}");
        if (jsonEnd !== -1) {
          cleanedContent = cleanedContent.substring(0, jsonEnd + 1);
        }

        const updatedItinerary = JSON.parse(cleanedContent);

        // Update the group's itinerary
        const groupIndex = groups.findIndex((g) => g.id === groupId);
        if (groupIndex !== -1) {
          // Preserve existing tripDetails if the AI didn't update them
          const preservedTripDetails = updatedItinerary.tripDetails || group.aiItinerary.tripDetails;

          groups[groupIndex].aiItinerary = {
            ...updatedItinerary,
            tripDetails: preservedTripDetails,
            generatedAt: group.aiItinerary.generatedAt,
            lastModified: new Date().toISOString(),
          };
          DataLayer.save("groups", groups);
        }

        closeAIAssistantModal();
        GroupsSystem.displayGroups();
        NotificationSystem.show("Itinerary updated successfully!", "success");

      } catch (error) {
        console.error("Error updating itinerary:", error);
        NotificationSystem.show("Failed to update itinerary. Please try again.", "error");

        // Reset form
        document.getElementById("ai-assistant-loading").style.display = "none";
        document.getElementById("ai-assistant-form").style.display = "block";
      }
    }

    // Add CSS for AI Premium features
    const aiPremiumStyles = document.createElement("style");
    aiPremiumStyles.textContent = `
  .ai-loading {
    text-align: center;
    padding: 3rem 1rem;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .itinerary-timeline::before {
    content: '';
    position: absolute;
    left: 20px;
    top: 60px;
    bottom: 20px;
    width: 2px;
    background: var(--primary-gradient);
    z-index: 0;
  }

  .day-card {
    position: relative;
    z-index: 1;
  }

  .activity-item:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow-small);
    transition: all 0.2s ease;
  }

  @media (max-width: 768px) {
    .ai-itinerary-section {
      margin: 1rem -1rem;
      border-radius: 0;
    }
    
    .day-card {
      margin: 0 -0.5rem 1rem;
      border-radius: 8px;
    }
    
    .activity-item {
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .activity-item > div:first-child {
      width: auto;
      text-align: left;
    }
  }
`;
    document.head.appendChild(aiPremiumStyles);

    // Groups System with Firebase Integration
    const GroupsSystem = {
      // Group limits for non-premium users
      FREE_GROUP_LIMIT: 3,
      pageSize: 10,
      store: { items: [], hasMore: true, isLoading: false, cacheKey: 'GROUPS_PAGINATED' },

      init: async () => {
        if (GroupsSystem._initInFlight) return;
        GroupsSystem._initInFlight = true;
        setTimeout(async () => {
          try {
            await GroupsSystem.resetAndLoad();
            GroupsSystem.displayGroups();
          } finally {
            GroupsSystem._initInFlight = false;
          }
        }, 150);
      },

      resetAndLoad: async () => {
        GroupsSystem.store = { items: [], hasMore: true, isLoading: false, cacheKey: 'GROUPS_PAGINATED' };
        GroupsSystem._lastGroupDocSnap = null;
        const cached = CacheSystem.get(GroupsSystem.store.cacheKey, CacheSystem.CACHE_DURATIONS.GROUPS);
        if (cached) {
          GroupsSystem.store = { ...GroupsSystem.store, ...cached };
          DataLayer.save('groups', GroupsSystem.store.items);
        } else {
          await GroupsSystem.loadNextPage();
        }
      },

      loadNextPage: async () => {
        if (GroupsSystem.store.isLoading || !GroupsSystem.store.hasMore) return;
        if (!currentFirebaseUser || !authManager) return;
        GroupsSystem.store.isLoading = true;
        try {
          const { collection, query, where, limit, startAfter, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          let q = query(
            collection(authManager.db, 'groups'),
            where('members', 'array-contains', currentFirebaseUser.uid),
            limit(GroupsSystem.pageSize)
          );

          if (GroupsSystem._lastGroupDocSnap) {
            q = query(q, startAfter(GroupsSystem._lastGroupDocSnap));
          }

          const snapshot = await wrapRead(getDocs(q), 'getDocs', 'groups', { paginated: true });
          const page = [];
          for (const docSnap of snapshot.docs) {
            const data = docSnap.data();
            // Prefer embedded memberDetails if present to avoid extra reads
            let members = Array.isArray(data.memberDetails) && data.memberDetails.length > 0 ? data.memberDetails : null;
            if (!members) {
              // Fallback minimal members list (IDs only) to keep UI functional without extra reads
              members = (data.members || []).map(id => ({ userId: id, displayName: 'Member', personalityType: '', adjustmentFactor: 0, avatar: '?' }));
            }
            page.push({
              id: docSnap.id,
              ...data,
              members,
              createdAt: data.createdAt?.toDate?.() || new Date(),
              updatedAt: data.updatedAt?.toDate?.() || new Date()
            });
          }

          GroupsSystem.store.items = [...GroupsSystem.store.items, ...page];
          GroupsSystem._lastGroupDocSnap = snapshot.docs[snapshot.docs.length - 1] || GroupsSystem._lastGroupDocSnap;
          GroupsSystem.store.hasMore = snapshot.size === GroupsSystem.pageSize;

          // Persist and cache
          DataLayer.save('groups', GroupsSystem.store.items);
          CacheSystem.set(GroupsSystem.store.cacheKey, {
            items: GroupsSystem.store.items,
            hasMore: GroupsSystem.store.hasMore
          });
        } catch (error) {
          console.error('Paginated groups load failed:', error);
        } finally {
          GroupsSystem.store.isLoading = false;
        }
      },

      // Load groups (compat). Loads first page if none loaded
      loadGroupsFromFirebase: async () => {
        if (GroupsSystem.store.items.length === 0) {
          await GroupsSystem.resetAndLoad();
        }
      },

      // Check if user can create more groups
      canCreateGroup: () => {
        if (AI_PREMIUM_ENABLED) return true; // Premium users have unlimited groups

        const groups = DataLayer.load("groups", []);
        const currentMonth = new Date().getFullYear() + "-" + (new Date().getMonth() + 1);

        // Count groups created this month
        const groupsThisMonth = groups.filter(group => {
          const groupDate = new Date(group.createdAt);
          const groupMonth = groupDate.getFullYear() + "-" + (groupDate.getMonth() + 1);
          return groupMonth === currentMonth;
        });

        return groupsThisMonth.length < GroupsSystem.FREE_GROUP_LIMIT;
      },

      // Get group usage info
      getGroupUsage: () => {
        const groups = DataLayer.load("groups", []);
        const currentMonth = new Date().getFullYear() + "-" + (new Date().getMonth() + 1);

        // Count groups created this month
        const groupsThisMonth = groups.filter(group => {
          const groupDate = new Date(group.createdAt);
          const groupMonth = groupDate.getFullYear() + "-" + (groupDate.getMonth() + 1);
          return groupMonth === currentMonth;
        });

        return {
          current: groupsThisMonth.length,
          limit: AI_PREMIUM_ENABLED ? "∞" : GroupsSystem.FREE_GROUP_LIMIT,
          isPremium: AI_PREMIUM_ENABLED,
          canCreate: GroupsSystem.canCreateGroup()
        };
      },

      // Check if current user is admin of a group
      isGroupAdmin: (groupId) => {
        const groups = DataLayer.load('groups', []);
        const group = groups.find(g => g.id === groupId);
        return group && group.admin === currentFirebaseUser.uid;
      },

      // Check if current user is member of a group
      isGroupMember: (groupId) => {
        const groups = DataLayer.load('groups', []);
        const group = groups.find(g => g.id === groupId);
        return group && group.members.includes(currentFirebaseUser.uid);
      },

      // Transfer admin role to another member
      transferAdmin: async (groupId, newAdminId) => {
        if (!GroupsSystem.isGroupAdmin(groupId)) {
          NotificationSystem.show('Only the admin can transfer admin role.', 'error');
          return false;
        }

        try {
          const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Update admin in Firebase
          await wrapWrite(
            updateDoc(doc(authManager.db, 'groups', groupId), {
              admin: newAdminId,
              updatedAt: new Date()
            }),
            'updateDoc',
            `groups/${groupId}`,
            { adminChanged: true }
          );

          // Update local data
          const groups = DataLayer.load('groups', []);
          const groupIndex = groups.findIndex(g => g.id === groupId);
          if (groupIndex !== -1) {
            groups[groupIndex].admin = newAdminId;
            groups[groupIndex].updatedAt = new Date();

            // Update member roles
            groups[groupIndex].memberDetails.forEach(member => {
              if (member.userId === currentFirebaseUser.uid) {
                member.role = 'member';
              } else if (member.userId === newAdminId) {
                member.role = 'admin';
              }
            });

            DataLayer.save('groups', groups);
          }

          // Invalidate cache
          CacheSystem.invalidateGroupsCache();

          NotificationSystem.show('Admin role transferred successfully!', 'success');
          return true;
        } catch (error) {
          console.error('Error transferring admin:', error);
          NotificationSystem.show('Failed to transfer admin role.', 'error');
          return false;
        }
      },

      // Remove member from group (admin only)
      removeMember: async (groupId, memberId) => {
        if (!GroupsSystem.isGroupAdmin(groupId)) {
          NotificationSystem.show('Only the admin can remove members.', 'error');
          return false;
        }

        if (memberId === currentFirebaseUser.uid) {
          NotificationSystem.show('Admin cannot remove themselves. Transfer admin role first.', 'error');
          return false;
        }

        try {
          const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Get current group data
          const groups = DataLayer.load('groups', []);
          const group = groups.find(g => g.id === groupId);

          if (!group) {
            NotificationSystem.show('Group not found.', 'error');
            return false;
          }

          // Remove member from arrays
          const updatedMembers = group.members.filter(id => id !== memberId);
          const updatedMemberDetails = group.memberDetails.filter(member => member.userId !== memberId);

          // Update Firebase
          await wrapWrite(
            updateDoc(doc(authManager.db, 'groups', groupId), {
              members: updatedMembers,
              memberDetails: updatedMemberDetails,
              updatedAt: new Date()
            }),
            'updateDoc',
            `groups/${groupId}`,
            { memberListUpdated: true }
          );

          // Update local data
          const groupIndex = groups.findIndex(g => g.id === groupId);
          if (groupIndex !== -1) {
            groups[groupIndex].members = updatedMembers;
            groups[groupIndex].memberDetails = updatedMemberDetails;
            groups[groupIndex].updatedAt = new Date();
            DataLayer.save('groups', groups);
          }

          // Invalidate cache
          CacheSystem.invalidateGroupsCache();

          NotificationSystem.show('Member removed successfully!', 'success');
          return true;
        } catch (error) {
          console.error('Error removing member:', error);
          NotificationSystem.show('Failed to remove member.', 'error');
          return false;
        }
      },

      createGroup: async (name, description, members) => {
        const currentUser = DataLayer.load("currentUser");
        const personalityData = DataLayer.load("personalityScore");

        if (!personalityData) {
          NotificationSystem.show(
            "Please complete the personality assessment first!",
            "warning"
          );
          return;
        }

        // Check group creation limit for non-premium users
        if (!GroupsSystem.canCreateGroup()) {
          const usage = GroupsSystem.getGroupUsage();
          NotificationSystem.show(
            `You've reached your monthly limit of ${usage.current}/${usage.limit} groups. Upgrade to Premium for unlimited groups!`,
            "warning"
          );
          return;
        }

        // Ensure current user has location data
        if (!currentUser.location) {
          console.log(`🌤️ Current user has no location, attempting to get it...`);
          // Try to get user's location if not already set
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (position) => {
                currentUser.location = {
                  lat: position.coords.latitude,
                  lng: position.coords.longitude
                };
                DataLayer.save("currentUser", currentUser);
                console.log(`🌤️ Updated current user location:`, currentUser.location);
              },
              (error) => {
                console.log(`🌤️ Could not get user location:`, error.message);
                // Keep default location
              }
            );
          }
        }

        const groupData = {
          name: name.trim(),
          description: description.trim(),
          createdBy: currentFirebaseUser.uid,
          admin: currentFirebaseUser.uid, // Creator is the admin
          members: [currentFirebaseUser.uid, ...members.map(member => member.userId)],
          memberDetails: [
            {
              userId: currentFirebaseUser.uid,
              displayName: currentUser.displayName,
              personalityType: currentUser.personalityType,
              adjustmentFactor: personalityData.adjustmentFactor,
              avatar: currentUser.avatar,
              importance: 1.0,
              role: 'admin', // Creator has admin role
              location: currentUser.location || { lat: 43.4643, lng: -80.5204 }, // Waterloo default
            },
            ...members.map(member => ({
              ...member,
              role: 'member', // Other members have member role
              location: { lat: 43.4643, lng: -80.5204 } // Default location - Firebase only
            })),
          ],
          votes: {},
          itineraries: [],
          createdAt: new Date(),
          updatedAt: new Date()
        };

        try {
          // Save to Firebase
          const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const docRef = await wrapWrite(
            addDoc(collection(authManager.db, 'groups'), {
              ...groupData,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp()
            }),
            'addDoc',
            'groups',
            { name: groupData.name }
          );

          // Add to local storage for immediate UI update
          const localGroup = {
            id: docRef.id,
            ...groupData,
            createdAt: new Date(),
            updatedAt: new Date()
          };

          DataLayer.push("groups", localGroup);

          // Invalidate groups cache
          CacheSystem.invalidateGroupsCache();

          NotificationSystem.show("Group created successfully!", "success");
          GroupsSystem.displayGroups();
          closeModal();

          console.log('Group saved to Firebase with ID:', docRef.id);
        } catch (error) {
          console.error('Error creating group:', error);
          NotificationSystem.show("Failed to create group. Please try again.", "error");
        }
      },

      deleteGroup: async (groupId) => {
        // Only admin can delete the group
        if (!GroupsSystem.isGroupAdmin(groupId)) {
          NotificationSystem.show('Only the admin can delete the group.', 'error');
          return;
        }

        if (confirm("Are you sure you want to delete this group? This action cannot be undone.")) {
          DataLayer.remove("groups", (group) => group.id === groupId);

          // Delete from Firebase
          try {
            const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            await wrapWrite(
              deleteDoc(doc(authManager.db, 'groups', groupId)),
              'deleteDoc',
              `groups/${groupId}`,
              { reason: 'deleteGroup' }
            );

            // Invalidate cache
            CacheSystem.invalidateGroupsCache();

            NotificationSystem.show('Group deleted successfully!', 'success');
            console.log('Group deleted from Firebase');
          } catch (error) {
            console.error('Error deleting group from Firebase:', error);
            NotificationSystem.show('Failed to delete group. Please try again.', 'error');
          }

          GroupsSystem.displayGroups();
        }
      },

      // Save itinerary to Firebase
      saveItineraryToFirebase: async (groupId) => {
        const groups = DataLayer.load("groups", []);
        const group = groups.find(g => g.id === groupId);

        if (!group || !group.aiItinerary) {
          NotificationSystem.show("No itinerary to save.", "warning");
          return;
        }

        try {
          const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          await wrapWrite(
            updateDoc(doc(authManager.db, 'groups', groupId), {
              aiItinerary: {
                ...group.aiItinerary,
                savedAt: serverTimestamp()
              },
              updatedAt: serverTimestamp()
            }),
            'updateDoc',
            `groups/${groupId}`,
            { saveItinerary: true }
          );

          NotificationSystem.show("Itinerary saved to cloud!", "success");
          console.log('Itinerary saved to Firebase');
        } catch (error) {
          console.error('Error saving itinerary to Firebase:', error);
          NotificationSystem.show("Failed to save itinerary. Please try again.", "error");
        }
      },

      getGroupRecommendations: (group) => {
        const allExperiences = ActivitySystem.getAllExperiences();
        const userExperiences = DataLayer.load("userExperiences", []);
        const userExperienceNames = userExperiences.map((exp) =>
          exp.name.toLowerCase()
        );

        // Calculate group center for location-based scoring
        const groupCenter = calculateGroupCenter(group);

        const recommendations = [];

        // Group experiences by name to avoid duplicates
        const experienceGroups = {};
        allExperiences.forEach((exp) => {
          const key = exp.name.toLowerCase();
          if (!experienceGroups[key]) {
            experienceGroups[key] = [];
          }
          experienceGroups[key].push(exp);
        });

        Object.entries(experienceGroups).forEach(([name, experiences]) => {
          let groupScore = 0;
          let individualScores = [];
          let totalWeight = 0;
          let hasValidPredictions = false;

          group.members.forEach((member) => {
            let memberScore = 0;
            let memberPredictions = 0;

            experiences.forEach((exp) => {
              // Skip demo user lookups - no longer using demo data
              const ratingUser = null; // Only use Firebase user data going forward
              if (false) { // Disabled demo prediction logic
                const prediction = ActivitySystem.predictRating(
                  member.adjustmentFactor,
                  exp,
                  ratingUser.adjustmentFactor,
                  exp.rawScore
                );
                memberScore += prediction.prediction * prediction.confidence;
                memberPredictions++;
                hasValidPredictions = true;
              }
            });

            if (memberPredictions > 0) {
              const avgMemberScore = memberScore / memberPredictions;
              individualScores.push({
                member: member,
                score: avgMemberScore,
              });
              groupScore += avgMemberScore * member.importance;
              totalWeight += member.importance;
            }
          });

          if (hasValidPredictions && totalWeight > 0) {
            const finalGroupScore = groupScore / totalWeight;
            const scoreVariance = GroupsSystem.calculateVariance(
              individualScores.map((s) => s.score)
            );
            const confidence = Math.max(0.1, 1 - scoreVariance / 10);

            // Calculate location score
            let locationScore = 1.0; // Default score for experiences without coordinates
            if (experiences[0].coordinates) {
              const distance = calculateDistance(
                groupCenter.lat, groupCenter.lng,
                experiences[0].coordinates.lat, experiences[0].coordinates.lng
              );
              // Score based on distance: closer = higher score
              // 0km = 1.0, 25km = 0.5, 50km+ = 0.1
              locationScore = Math.max(0.1, 1 - (distance / 50));
            }

            // Combine personality score with location score (70% personality, 30% location)
            const combinedScore = (finalGroupScore * 0.7) + (locationScore * 0.3);

            recommendations.push({
              experience: experiences[0],
              groupScore: combinedScore,
              confidence: confidence,
              individualScores: individualScores,
              variance: scoreVariance,
              locationScore: locationScore,
              distanceFromGroup: experiences[0].coordinates ?
                calculateDistance(groupCenter.lat, groupCenter.lng,
                  experiences[0].coordinates.lat, experiences[0].coordinates.lng) : null
            });
          }
        });

        return recommendations.sort(
          (a, b) => b.groupScore * b.confidence - a.groupScore * a.confidence
        );
      },

      calculateVariance: (scores) => {
        if (scores.length === 0) return 0;
        const mean =
          scores.reduce((sum, score) => sum + score, 0) / scores.length;
        const variance =
          scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) /
          scores.length;
        return Math.sqrt(variance);
      },

      displayGroups: () => {
        const groups = DataLayer.load("groups", []);
        const groupsContent = document.getElementById("groups-content");

        // Store which groups are currently expanded
        const expandedGroups = new Set();
        groups.forEach(group => {
          const groupContent = document.getElementById(`group-content-${group.id}`);
          if (groupContent && groupContent.style.maxHeight !== "0px" && groupContent.style.maxHeight !== "") {
            expandedGroups.add(group.id);
          }
        });

        // Update group usage display
        const usage = GroupsSystem.getGroupUsage();
        const usageText = document.getElementById("group-usage-text");
        console.log("Usage text element found:", !!usageText, "Usage:", usage);
        if (usageText) {
          usageText.textContent = `${usage.current}/${usage.limit}`;
          console.log("Updated usage text to:", `${usage.current}/${usage.limit}`);

          // Change color based on usage
          if (usage.isPremium) {
            usageText.style.background = "var(--primary-color)";
            usageText.style.color = "white";
          } else if (usage.current >= usage.limit) {
            usageText.style.background = "#f44336";
          } else if (usage.current >= usage.limit * 0.8) {
            usageText.style.background = "#FF9800";
          } else {
            usageText.style.background = "var(--primary-color)";
          }
        } else {
          console.log("Usage text element not found!");
        }

        // Update premium status display
        const premiumStatusText = document.getElementById("premium-status-text");
        if (premiumStatusText) {
          if (usage.isPremium) {
            premiumStatusText.innerHTML = "Premium - Unlimited Groups";
          } else {
            premiumStatusText.innerHTML = '<a href="#" onclick="showPremiumUpgradeModal()" style="color: var(--secondary-color); text-decoration: none;">Upgrade to Premium for unlimited groups</a>';
          }
        }

        // Update create button state
        const createBtn = document.getElementById("create-group-btn");
        if (createBtn) {
          if (!usage.canCreate) {
            createBtn.style.background = "#f44336";
            createBtn.style.cursor = "not-allowed";
            createBtn.onclick = () => {
              NotificationSystem.show(
                `You've reached your monthly limit of ${usage.current}/${usage.limit} groups. Upgrade to Premium for unlimited groups!`,
                "warning"
              );
            };
          } else {
            createBtn.style.background = "";
            createBtn.style.cursor = "pointer";
            createBtn.onclick = () => showCreateGroupModal().catch(error => {
              console.error('Error showing create group modal:', error);
              NotificationSystem.show('Error loading friends. Please try again.', 'error');
            });
          }
        }

        if (groups.length === 0) {
          groupsContent.innerHTML = `
      <div class="empty-state">
        <h3>No groups yet</h3>
        <p>Create your first group to start planning activities with friends!</p>
      </div>
    `;
          return;
        }

        // Render groups loaded so far (server-side pagination via Load More)
        groupsContent.innerHTML = groups
          .map((group) => {
            const currentUser = DataLayer.load("currentUser");
            const recommendations =
              GroupsSystem.getGroupRecommendations(group);
            const topRecommendations = recommendations.slice(0, 3);

            // Initialize votes if not exists
            if (!group.votes) group.votes = {};

            // Find most voted activity
            let mostVoted = null;
            let maxVotes = 0;
            Object.entries(group.votes).forEach(([activityName, votes]) => {
              if (votes.length > maxVotes) {
                maxVotes = votes.length;
                mostVoted = activityName;
              }
            });

            return `
        <div class="group-card" data-group-id="${group.id}" style="
          border: 1px solid #eee; 
          border-radius: 16px; 
          margin-bottom: 1.5rem; 
          background: white;
          box-shadow: 0 2px 8px rgba(0,0,0,0.05);
          overflow: hidden;
          transition: all 0.2s ease;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
          
          <!-- Collapsible Header -->
          <div class="group-header" onclick="GroupsSystem.toggleGroupExpansion('${group.id}')" style="
            padding: 1.5rem; 
            cursor: pointer; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            background: var(--secondary-gradient);
            color: white;
            border-radius: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          ">
            <div style="flex: 1;">
              <h3 style="margin: 0; font-size: 1.4rem; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.1);">${group.name}</h3>
              <p style="margin: 0.5rem 0 0 0; opacity: 0.95; font-size: 1rem; line-height: 1.4;">${group.description}</p>
              <div style="display: flex; gap: 1.5rem; margin-top: 0.8rem; font-size: 0.9rem; opacity: 0.9;">
                <span style="display: flex; align-items: center; gap: 0.3rem;"><i class="fas fa-users"></i> ${group.members.length} members</span>
                <span style="display: flex; align-items: center; gap: 0.3rem; cursor: help;" 
                      title="${formatFullDate(group.createdAt)}">
                  <i class="fas fa-calendar"></i> ${new Date(group.createdAt).toLocaleDateString()}
                </span>
              </div>
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <i class="fas fa-chevron-down" id="expand-icon-${group.id}" style="
                transition: transform 0.2s ease; 
                font-size: 1.2rem; 
                opacity: 0.9;
                padding: 0.5rem;
                border-radius: 50%;
                background: rgba(255,255,255,0.5);
              "></i>
            </div>
          </div>

          <!-- Expandable Content -->
          <div class="group-content" id="group-content-${group.id}" style="
            max-height: 0; 
            overflow: hidden; 
            transition: max-height 0.3s ease;
            background: white;
          ">
            <div style="padding: 1.5rem;">
              
              <!-- Action Buttons -->
              <div style="display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                ${(() => {
                // Check if all group members have premium access
                const allMembersHavePremium = group.members.every(member => {
                  if (member.userId === currentUser.id) {
                    return currentUser.isPremium;
                  } else {
                    // Demo users removed - Firebase only
                    return false;
                  }
                });

                // Check if any members have premium access
                const anyMembersHavePremium = group.members.some(member => {
                  if (member.userId === currentUser.id) {
                    return currentUser.isPremium;
                  } else {
                    // Demo users removed - Firebase only
                    return false;
                  }
                });

                if (!anyMembersHavePremium) {
                  return `<button class="btn btn-secondary" onclick="showPremiumUpgradeModal()" style="background: var(--warning-color); color: var(--inverted-text-color);">
                      <i class="fas fa-crown"></i> Get Premium for AI Trip Planner
                    </button>`;
                } else if (!allMembersHavePremium) {
                  return "";
                } else if (AI_PREMIUM_ENABLED) {
                  return `<button class="btn" style="background: var(--primary-gradient); color: var(--inverted-text-color);" onclick="showAIPremiumModal('${group.id}')">
                      <i class="fa-solid fa-crown"></i> AI Trip Planner
                    </button>`;
                } else {
                  return "";
                }
              })()}
                <button class="btn btn-info" onclick="showGroupLocationRecommendations('${group.id}')" style="background: var(--info-color);">
                  <i class="fas fa-map-marker-alt"></i> Find Places Near Group
                </button>
                ${GroupsSystem.isGroupAdmin(group.id) ? `
                  <button class="btn btn-secondary" onclick="GroupsSystem.editGroup('${group.id}')">
                  <i class="fas fa-edit"></i> Edit Group
                </button>
                  <button class="btn btn-danger" onclick="GroupsSystem.deleteGroup('${group.id}')">
                    <i class="fas fa-trash"></i> Delete Group
                </button>
                ` : ''}
              </div>

              <!-- Members Section -->
              <div style="margin-bottom: 1.5rem;">
                <h4 style="margin-bottom: 1rem; color: var(--primary-color);">
                  <i class="fas fa-users"></i> Group Members
                </h4>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                  ${group.members
                .map(
                  (member) => `
                    <div style="
                      display: flex; 
                      align-items: center; 
                      gap: 0.5rem; 
                      padding: 0.5rem 0.8rem; 
                      background: #f8f9fa; 
                      border-radius: 20px; 
                      font-size: 0.9rem;
                      border: 1px solid #e9ecef;
                    ">
                      <div style="
                        width: 25px; 
                        height: 25px; 
                        border-radius: 50%; 
                        background: var(--secondary-color); 
                        color: white; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        font-size: 0.8rem;
                      ">${member.avatar}</div>
                      <span style="font-weight: 500;">${addCrownToPremiumUser(member.displayName, member.userId)}</span>
                      <span style="color: #666; font-size: 0.8rem;">(${member.personalityType})</span>
                    </div>
                  `
                )
                .join("")}
                </div>
              </div>

              <!-- Group Scheduling Section -->
              ${(() => {
                // Check if any members have premium access
                const anyMembersHavePremium = group.members.some(member => {
                  if (member.userId === currentUser.id) {
                    return currentUser.isPremium;
                  } else {
                    // Demo users removed - Firebase only
                    return false;
                  }
                });

                // Only show scheduling section if at least one member has premium
                if (anyMembersHavePremium) {
                  return `<div id="scheduling-placeholder-${group.id}" style="margin-top: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(74, 144, 226, 0.05) 0%, rgba(160, 200, 240, 0.05) 100%); border-radius: 15px; border: 2px solid rgba(74, 144, 226, 0.2);">
                    <div style="text-align: center; color: #666;">
                      <i class="fas fa-spinner fa-spin" style="font-size: 1.5rem; margin-bottom: 0.5rem;"></i>
                      <p>Loading scheduling information...</p>
                    </div>
                  </div>`;
                } else {
                  return "";
                }
              })()}

              <!-- AI Itinerary Section -->
              ${renderAIItinerary(group)}

              <!-- Recommendations Section -->
              ${topRecommendations.length > 0 && !group.aiItinerary
                ? `
                <div style="margin-top: 1.5rem;">
                  <h4 style="margin-bottom: 1rem; color: var(--primary-color);">
                    <i class="fas fa-star"></i> Top Recommendations
                  </h4>
                  <div class="activity-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
                    ${topRecommendations
                  .map((rec) => {
                    const activityName = rec.experience.name;
                    const votes = group.votes[activityName] || [];
                    const currentUserId = DataLayer.load("currentUser").id;
                    const hasVoted = votes.includes(currentUserId);
                    const isMostVoted =
                      mostVoted === activityName && maxVotes > 0;

                    return `
                        <div class="activity-card ${isMostVoted ? "most-voted" : ""
                      }" style="
                          border: 1px solid #eee; 
                          border-radius: 12px; 
                          padding: 1.5rem; 
                          background: white;
                          box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                          transition: all 0.2s ease;
                          ${isMostVoted ? 'border: 2px solid var(--secondary-color);' : ''}
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
                           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
                          
                          <div style="background: var(--secondary-gradient); color: white; padding: 0.8rem; margin: -1.5rem -1.5rem 1rem -1.5rem; border-radius: 12px 12px 0 0;">
                            <div style="font-weight: bold; font-size: 1.1rem;">Combined Score: ${rec.groupScore.toFixed(1)}/10</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">Confidence: ${(rec.confidence * 100).toFixed(0)}%</div>
                          </div>
                          
                          <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">${rec.experience.name}</div>
                          <div style="color: #666; margin-bottom: 0.5rem;">
                            ${rec.experience.category} • ${rec.experience.location}
                            ${rec.distanceFromGroup ? ` • <i class="fas fa-map-marker-alt"></i> ${rec.distanceFromGroup.toFixed(1)}km away` : ''}
                          </div>
                          ${rec.experience.description
                        ? `<p style="font-size: 0.9rem; color: #666; margin: 0.5rem 0; line-height: 1.4;">${rec.experience.description}</p>`
                        : ""
                      }

                          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                            <strong style="font-size: 0.9rem;">Individual Predictions:</strong>
                            ${rec.individualScores
                        .map(
                          (score) => `
                              <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; margin-top: 0.3rem;">
                                <span>${addCrownToPremiumUser(score.member.displayName, score.member.userId)}</span>
                                <span style="font-weight: bold; color: ${score.score >= 7
                              ? "#4CAF50"
                              : score.score >= 5
                                ? "#FF9800"
                                : "#f44336"
                            }">${score.score.toFixed(1)}/10</span>
                              </div>
                            `
                        )
                        .join("")}
                            <div style="margin-top: 0.5rem; font-size: 0.85rem;">
                              Group Compatibility: 
                              <span style="font-weight: bold; color: ${rec.variance <= 1.5
                        ? "#4CAF50"
                        : rec.variance <= 3
                          ? "#FF9800"
                          : "#f44336"
                      }">
                                ${rec.variance <= 1.5
                        ? "High"
                        : rec.variance <= 3
                          ? "Medium"
                          : "Low"
                      }
                              </span>
                            </div>
                            
                            <!-- Voting section -->
                            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                              <button class="vote-button ${hasVoted ? "voted" : ""
                      }" 
                                      onclick="GroupsSystem.voteForActivity(${group.id}, '${activityName.replace(/'/g, "\\'")}')" style="
                                background: ${hasVoted ? 'var(--success-color)' : 'var(--primary-color)'}; 
                                color: white; 
                                border: none; 
                                padding: 0.5rem 1rem; 
                                border-radius: 6px; 
                                cursor: pointer; 
                                font-size: 0.9rem;
                                transition: all 0.2s ease;
                              ">
                                ${hasVoted ? "✓ Voted" : "Vote for this"}
                              </button>
                              <div class="vote-count" style="margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                                ${votes.length} vote${votes.length !== 1 ? "s" : ""}
                                ${votes.length > 0
                        ? `(${votes
                          .map((userId) => {
                            const member = group.members.find(
                              (m) => m.userId === userId
                            );
                            return member ? addCrownToPremiumUser(member.displayName, member.userId) : "Unknown";
                          })
                          .join(", ")})`
                        : ""
                      }
                              </div>
                            </div>
                          </div>
                        </div>
                      `;
                  })
                  .join("")}
                  </div>
                </div>
              `
                : '<p style="color: #666; text-align: center; padding: 2rem;">No recommendations available yet. More community data needed!</p>'
              }
            </div>
          </div>
        </div>
      `;
          })
          .join("");

        // Load more control for groups
        if (GroupsSystem.store && GroupsSystem.store.hasMore) {
          groupsContent.innerHTML += `
            <div style=\"display:flex; justify-content:center; margin:16px 0;\">
              <button class=\"btn btn-secondary\" onclick=\"(async()=>{await GroupsSystem.loadNextPage(); GroupsSystem.displayGroups();})()\">Load More Groups</button>
            </div>
          `;
        }

        // Load scheduling sections asynchronously after groups are rendered
        setTimeout(() => {
          groups.forEach(group => {
            const placeholder = document.getElementById(`scheduling-placeholder-${group.id}`);
            if (placeholder) {
              renderGroupScheduling(group).then(schedulingHtml => {
                placeholder.outerHTML = schedulingHtml;


              }).catch(error => {
                console.error('Error rendering group scheduling:', error);
                placeholder.innerHTML = '<p style="color: #666; text-align: center;">Unable to load scheduling information.</p>';
              });
            }
          });

          // Restore expanded state for groups that were expanded before
          setTimeout(() => {
            expandedGroups.forEach(groupId => {
              const groupContent = document.getElementById(`group-content-${groupId}`);
              const expandIcon = document.getElementById(`expand-icon-${groupId}`);
              if (groupContent && expandIcon) {
                groupContent.style.maxHeight = groupContent.scrollHeight + "px";
                expandIcon.style.transform = "rotate(180deg)";
              }
            });
          }, 200); // Wait a bit longer for scheduling to load
        }, 100);
      },
    };

    //GroupsSystem object
    GroupsSystem.voteForActivity = async function (groupId, activityName) {
      console.log('Voting for activity:', activityName, 'in group:', groupId);
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) {
        console.error('Group not found:', groupId);
        return;
      }

      // Initialize votes if not exists
      if (!group.votes) group.votes = {};

      const currentUserId = DataLayer.load("currentUser").id;

      // Remove user's vote from all other activities first
      Object.entries(group.votes).forEach(([activity, votes]) => {
        if (activity !== activityName) { // Only remove from other activities, not the current one
          const voteIndex = votes.indexOf(currentUserId);
          if (voteIndex > -1) {
            votes.splice(voteIndex, 1);
          }
        }
      });

      // Initialize the current activity's votes array if it doesn't exist
      if (!group.votes[activityName]) group.votes[activityName] = [];

      // Toggle vote for the current activity (add if not voted, remove if already voted)
      const currentVoteIndex = group.votes[activityName].indexOf(currentUserId);
      if (currentVoteIndex > -1) {
        // Remove vote if already voted
        group.votes[activityName].splice(currentVoteIndex, 1);
      } else {
        // Add vote if not voted
        group.votes[activityName].push(currentUserId);
      }

      // Update groups data
      DataLayer.save("groups", groups);

      // Save to Firebase
      try {
        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        await wrapWrite(
          updateDoc(doc(authManager.db, 'groups', groupId), {
            votes: group.votes,
            updatedAt: serverTimestamp()
          }),
          'updateDoc',
          `groups/${groupId}`,
          { votesUpdated: true }
        );
        console.log('Votes saved to Firebase');
      } catch (error) {
        console.error('Error saving votes to Firebase:', error);
      }

      // Update only the specific group's content instead of refreshing everything
      console.log('Updating group content for:', groupId);
      GroupsSystem.updateGroupContent(groupId);
    };

    GroupsSystem.updateGroupContent = async function (groupId) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) return;

      // Get the current group content element
      const groupContent = document.getElementById(`group-content-${groupId}`);
      if (!groupContent) return;

      // Check if the group is currently expanded
      const isExpanded = groupContent.style.maxHeight !== "0px" && groupContent.style.maxHeight !== "";

      // Generate the new content for this specific group
      const recommendations = GroupsSystem.getGroupRecommendations(group);
      const recommendationsHtml = recommendations
        .slice(0, 3)
        .map((rec) => {
          const activityName = rec.experience.name;
          const votes = group.votes && group.votes[activityName] ? group.votes[activityName] : [];
          const hasVoted = votes.includes(DataLayer.load("currentUser").id);
          const maxVotes = Math.max(...Object.values(group.votes || {}).map(v => v.length));
          const mostVoted = Object.entries(group.votes || {}).find(([name, votes]) => votes.length === maxVotes)?.[0];
          const isMostVoted = mostVoted === activityName && maxVotes > 0;

          return `
            <div class="activity-card ${isMostVoted ? "most-voted" : ""}" style="
              border: 1px solid #eee; 
              border-radius: 12px; 
              padding: 1.5rem; 
              background: white;
              box-shadow: 0 2px 8px rgba(0,0,0,0.05);
              transition: all 0.2s ease;
              ${isMostVoted ? 'border: 2px solid var(--secondary-color);' : ''}
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
              
              <div style="background: var(--secondary-gradient); color: white; padding: 0.8rem; margin: -1.5rem -1.5rem 1rem -1.5rem; border-radius: 12px 12px 0 0;">
                <div style="font-weight: bold; font-size: 1.1rem;">Combined Score: ${rec.groupScore.toFixed(1)}/10</div>
                <div style="font-size: 0.9rem; opacity: 0.9;">Confidence: ${(rec.confidence * 100).toFixed(0)}%</div>
              </div>
              
              <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">${rec.experience.name}</div>
              <div style="color: #666; margin-bottom: 0.5rem;">
                ${rec.experience.category} • ${rec.experience.location}
                ${rec.distanceFromGroup ? ` • <i class="fas fa-map-marker-alt"></i> ${rec.distanceFromGroup.toFixed(1)}km away` : ''}
              </div>
              ${rec.experience.description
              ? `<p style="font-size: 0.9rem; color: #666; margin: 0.5rem 0; line-height: 1.4;">${rec.experience.description}</p>`
              : ""
            }

              <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                <strong style="font-size: 0.9rem;">Individual Predictions:</strong>
                ${rec.individualScores
              .map(
                (score) => `
                  <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; margin-top: 0.3rem;">
                                                    <span>${addCrownToPremiumUser(score.member.displayName, score.member.userId)}</span>
                    <span style="font-weight: bold; color: ${score.score >= 7
                    ? "#4CAF50"
                    : score.score >= 5
                      ? "#FF9800"
                      : "#f44336"
                  }">${score.score.toFixed(1)}/10</span>
                  </div>
                `
              )
              .join("")}
                <div style="margin-top: 0.5rem; font-size: 0.85rem;">
                  Group Compatibility: 
                  <span style="font-weight: bold; color: ${rec.variance <= 1.5
              ? "#4CAF50"
              : rec.variance <= 3
                ? "#FF9800"
                : "#f44336"
            }">
                    ${rec.variance <= 1.5
              ? "High"
              : rec.variance <= 3
                ? "Medium"
                : "Low"
            }
                  </span>
                </div>
                
                <!-- Voting section -->
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                  <button class="vote-button ${hasVoted ? "voted" : ""}" 
                          onclick="GroupsSystem.voteForActivity(${group.id}, '${activityName.replace(/'/g, "\\'")}')" style="
                    background: ${hasVoted ? 'var(--success-color)' : 'var(--primary-color)'}; 
                    color: white; 
                    border: none; 
                    padding: 0.5rem 1rem; 
                    border-radius: 6px; 
                    cursor: pointer; 
                    font-size: 0.9rem;
                    transition: all 0.2s ease;
                  ">
                    ${hasVoted ? "✓ Voted" : "Vote for this"}
                  </button>
                  <div class="vote-count" style="margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                    ${votes.length} vote${votes.length !== 1 ? "s" : ""}
                    ${votes.length > 0
              ? `(${votes
                .map((userId) => {
                  const member = group.members.find(
                    (m) => m.userId === userId
                  );
                  return member ? addCrownToPremiumUser(member.displayName, member.userId) : "Unknown";
                })
                .join(", ")})`
              : ""
            }
                  </div>
                </div>
              </div>
            </div>
          `;
        })
        .join("");

      // Find the recommendations container within this group
      const recommendationsContainer = groupContent.querySelector('.activity-grid');
      if (recommendationsContainer) {
        recommendationsContainer.innerHTML = recommendationsHtml;
      }

      // Update AI itinerary section if it exists
      const aiItinerarySection = groupContent.querySelector('.ai-itinerary-section');
      if (aiItinerarySection && group.aiItinerary) {
        aiItinerarySection.innerHTML = renderAIItinerary(group);
      }

      // Update group scheduling section if it exists
      const groupSchedulingSection = groupContent.querySelector('.group-scheduling-section');
      if (groupSchedulingSection) {
        // Render the scheduling section asynchronously
        renderGroupScheduling(group).then(schedulingHtml => {
          groupSchedulingSection.innerHTML = schedulingHtml;

          // After updating the scheduling section, recalculate the height if expanded
          if (isExpanded) {
            // Use requestAnimationFrame to ensure DOM updates are complete
            requestAnimationFrame(() => {
              groupContent.style.maxHeight = groupContent.scrollHeight + "px";
            });
          }
        }).catch(error => {
          console.error('Error rendering group scheduling:', error);
          groupSchedulingSection.innerHTML = '<p style="color: #666;">Unable to load scheduling information.</p>';

          // Even if there's an error, still recalculate height if expanded
          if (isExpanded) {
            requestAnimationFrame(() => {
              groupContent.style.maxHeight = groupContent.scrollHeight + "px";
            });
          }
        });
      } else {
        // If no scheduling section to update, still recalculate height if expanded
        if (isExpanded) {
          requestAnimationFrame(() => {
            groupContent.style.maxHeight = groupContent.scrollHeight + "px";
          });
        }
      }
    };

    GroupsSystem.toggleGroupExpansion = function (groupId) {
      const content = document.getElementById(`group-content-${groupId}`);
      const icon = document.getElementById(`expand-icon-${groupId}`);

      if (content.style.maxHeight === "0px" || content.style.maxHeight === "") {
        // Expand
        content.style.maxHeight = content.scrollHeight + "px";
        icon.style.transform = "rotate(180deg)";
      } else {
        // Collapse
        content.style.maxHeight = "0px";
        icon.style.transform = "rotate(0deg)";
      }
    };

    GroupsSystem.editGroup = async function (groupId) {
      const groups = DataLayer.load("groups", []);
      const group = groups.find((g) => g.id === groupId);
      if (!group) return;

      const friends = await FriendsSystem.getFriends();
      const currentMembers = group.members.filter(
        (m) => m.userId !== DataLayer.load("currentUser").id
      );

      const modalHtml = `
    <div id="edit-group-modal" class="modal" onclick="handleEditModalBackdropClick(event)">
      <div class="modal-content" onclick="event.stopPropagation()">
        <button class="modal-close" onclick="closeEditModal()">&times;</button>
        <div class="modal-header">
          <h2>Edit Group</h2>
        </div>
        <div class="modal-body">
          <form id="edit-group-form" onsubmit="handleEditGroup(event, ${groupId})">
            <div class="form-group">
              <label for="edit-group-name">Group Name *</label>
              <input type="text" id="edit-group-name" class="form-control" value="${group.name
        }" required>
            </div>
            <div class="form-group">
              <label for="edit-group-description">Description</label>
              <textarea id="edit-group-description" class="form-control">${group.description
        }</textarea>
            </div>
            <div class="form-group">
              <label>Current Members</label>
              <div style="margin-bottom: 1rem;">
                ${currentMembers
          .map(
            (member) => `
                  <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #eee; border-radius: 8px;">
                    <input type="checkbox" id="keep-member-${member.userId}" checked>
                    <div class="feed-avatar" style="width: 30px; height: 30px; font-size: 0.8rem;">${member.avatar}</div>
                    <span>${addCrownToPremiumUser(member.displayName, member.userId)} (${member.personalityType})</span>
                  </div>
                `
          )
          .join("")}
              </div>
              <label>Add New Members</label>
              ${friends
          .filter(
            (friend) => !group.members.some((m) => m.userId === friend.id)
          )
          .map(
            (friend) => `
                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #eee; border-radius: 8px;">
                  <input type="checkbox" id="add-member-${friend.id}">
                  <div class="feed-avatar" style="width: 30px; height: 30px; font-size: 0.8rem;">${friend.avatar}</div>
                  <span>${addCrownToPremiumUser(friend.displayName, friend.id)} (${friend.personalityType})</span>
                </div>
              `
          )
          .join("")}
            </div>
            <div style="text-align: center; margin-top: 2rem;">
              <button type="submit" class="btn">Save Changes</button>
              <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);
      // Prevent body scrolling when modal is open
      document.body.classList.add('modal-open');
    };


    async function handleCreateGroup(event) {
      event.preventDefault();

      const name = document.getElementById("group-name").value;
      const description = document.getElementById("group-description").value;

      // Get selected friends
      const selectedMembers = [];
      const friends = await FriendsSystem.getFriends();

      if (!friends || !Array.isArray(friends)) {
        NotificationSystem.show('Error loading friends. Please try again.', 'error');
        return;
      }

      friends.forEach((friend) => {
        const checkbox = document.getElementById(`member-${friend.id}`);
        if (checkbox && checkbox.checked) {
          selectedMembers.push({
            userId: friend.id,
            displayName: friend.displayName,
            personalityType: friend.personalityType,
            adjustmentFactor: friend.adjustmentFactor, // Fixed: was user.adjustmentFactor
            avatar: friend.avatar, // Fixed: was user.avatar
            importance: 1.0,
          });
        }
      });

      if (selectedMembers.length === 0) {
        NotificationSystem.show(
          "Please select at least one member to add to the group.",
          "warning"
        );
        return;
      }

      GroupsSystem.createGroup(name, description, selectedMembers);
    }

    // Experiences Modal System
    function showExperiencesModal() {
      const userExperiences = DataLayer.load("userExperiences", []);
      console.log("SHOWING USERS!! ", userExperiences);

      const modalHtml = `
        <div id="experiences-modal" class="modal">
          <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeExperiencesModal()">&times;</button>
            <div class="modal-header">
              <h2>Your Experiences</h2>
              <p style="margin: 0; color: #666;">Manage and edit your shared experiences</p>
            </div>
            <div class="modal-body">
              ${userExperiences.length === 0 ? `
                <div style="text-align: center; padding: 3rem 1rem;">
                  <div style="font-size: 3rem; color: #ddd; margin-bottom: 1rem;">📝</div>
                  <h3 style="color: #666; margin-bottom: 0.5rem;">No Experiences Yet</h3>
                  <p style="color: #888; margin-bottom: 2rem;">Start sharing your experiences to see them here!</p>
                  <button class="btn" onclick="closeExperiencesModal(); showPage('activities');">
                    <i class="fas fa-plus-circle"></i> Add Your First Experience
                  </button>
                </div>
              ` : `
                <div style="display: grid; gap: 1.5rem;">
                  ${userExperiences.map((experience, index) => `
                    <div class="experience-card" style="
                      border: 1px solid #eee; 
                      border-radius: 12px; 
                      padding: 1.5rem; 
                      background: white;
                      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
                      transition: all 0.2s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
                      
                      <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                        <div style="flex: 1;">
                          <h3 style="margin: 0 0 0.5rem 0; color: var(--primary-color); font-size: 1.2rem;">
                            ${experience.name}
                          </h3>
                          <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;">
                            <span style="background: var(--secondary-color); color: white; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.8rem;">
                              ${experience.category}
                            </span>
                            <span style="color: #666;">
                              <i class="fas fa-map-marker-alt"></i> ${experience.location}
                            </span>
                          </div>
                          <p style="margin: 0; color: #555; line-height: 1.5; font-size: 0.95rem;">
                            ${experience.description}
                          </p>
                        </div>
                        <div style="text-align: right; min-width: 80px;">
                          <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">
                            ${experience.rawScore.toFixed(1)}
                          </div>
                          <div style="font-size: 0.8rem; color: #666;">Rating</div>
                        </div>
                      </div>
                      
                      <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; margin: 1rem 0; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                        <div style="text-align: center;">
                          <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.2rem;">Energy</div>
                          <div style="font-weight: bold; color: var(--primary-color);">${experience.responses.energy}/10</div>
                        </div>
                        <div style="text-align: center;">
                          <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.2rem;">Social</div>
                          <div style="font-weight: bold; color: var(--primary-color);">${experience.responses.social}/10</div>
                        </div>
                        <div style="text-align: center;">
                          <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.2rem;">Comfort</div>
                          <div style="font-weight: bold; color: var(--primary-color);">${experience.responses.comfort}/10</div>
                        </div>
                        <div style="text-align: center;">
                          <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.2rem;">Overwhelm</div>
                          <div style="font-weight: bold; color: var(--primary-color);">${experience.responses.overwhelm}/10</div>
                        </div>
                        <div style="text-align: center;">
                          <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.2rem;">Return</div>
                          <div style="font-weight: bold; color: var(--primary-color);">${experience.responses.return}/10</div>
                        </div>
                      </div>
                      
                      <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
                        <button class="btn btn-secondary" onclick="editExperience(${index})" style="font-size: 0.9rem; padding: 0.5rem 1rem;">
                          <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-danger" onclick="deleteExperience(${index})" style="font-size: 0.9rem; padding: 0.5rem 1rem;">
                          <i class="fas fa-trash"></i> Delete
                        </button>
                      </div>
                    </div>
                  `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #eee;">
                  <button class="btn" onclick="closeExperiencesModal(); showPage('activities');">
                    <i class="fas fa-plus-circle"></i> Add New Experience
                  </button>
                </div>
              `}
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("experiences-modal", closeExperiencesModal);
    }

    function closeExperiencesModal() {
      const modal = document.getElementById("experiences-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    function editExperience(index) {
      const userExperiences = DataLayer.load("userExperiences", []);
      const experience = userExperiences[index];

      if (!experience) return;

      const modalHtml = `
        <div id="edit-experience-modal" class="modal">
          <div class="modal-content" style="max-width: 600px;">
            <button class="modal-close" onclick="closeEditExperienceModal()">&times;</button>
            <div class="modal-header">
              <h2>Edit Experience</h2>
            </div>
            <div class="modal-body">
              <form id="edit-experience-form" onsubmit="handleEditExperience(event, ${index})">
                <div class="form-group">
                  <label for="edit-name">Experience Name *</label>
                  <input type="text" id="edit-name" class="form-control" value="${experience.name}" required>
                </div>
                <div class="form-group">
                  <label for="edit-category">Category *</label>
                  <select id="edit-category" class="form-control" required>
                    <option value="Restaurant" ${experience.category === 'Restaurant' ? 'selected' : ''}>Restaurant</option>
                    <option value="Bar/Pub" ${experience.category === 'Bar/Pub' ? 'selected' : ''}>Bar/Pub</option>
                    <option value="Cafe" ${experience.category === 'Cafe' ? 'selected' : ''}>Cafe</option>
                    <option value="Museum/Gallery" ${experience.category === 'Museum/Gallery' ? 'selected' : ''}>Museum/Gallery</option>
                    <option value="Library/Study" ${experience.category === 'Library/Study' ? 'selected' : ''}>Library/Study</option>
                    <option value="Park/Outdoor" ${experience.category === 'Park/Outdoor' ? 'selected' : ''}>Park/Outdoor</option>
                    <option value="Entertainment" ${experience.category === 'Entertainment' ? 'selected' : ''}>Entertainment</option>
                    <option value="Shopping" ${experience.category === 'Shopping' ? 'selected' : ''}>Shopping</option>
                    <option value="Other" ${experience.category === 'Other' ? 'selected' : ''}>Other</option>
                  </select>
                </div>
                <div class="form-group">
                  <label for="edit-location">Location *</label>
                  <input type="text" id="edit-location" class="form-control" value="${experience.location}" required>
                </div>
                <div class="form-group">
                  <label for="edit-description">Description *</label>
                  <textarea id="edit-description" class="form-control" rows="3" required>${experience.description}</textarea>
                </div>
                
                <div style="margin: 2rem 0;">
                  <h4 style="margin-bottom: 1rem; color: var(--primary-color);">Rate Your Experience</h4>
                  <div class="rating-questions">
                    <div class="rating-question">
                      <label>How energized did you feel?</label>
                      <input type="range" class="rating-slider" min="1" max="10" value="${experience.responses.energy}" oninput="updateSliderValue(this, 'edit-slider-energy')" id="edit-energy">
                      <div class="slider-value" id="edit-slider-energy">${experience.responses.energy}</div>
                    </div>
                    <div class="rating-question">
                      <label>How satisfied were you with the social interaction?</label>
                      <input type="range" class="rating-slider" min="1" max="10" value="${experience.responses.social}" oninput="updateSliderValue(this, 'edit-slider-social')" id="edit-social">
                      <div class="slider-value" id="edit-slider-social">${experience.responses.social}</div>
                    </div>
                    <div class="rating-question">
                      <label>How comfortable did you feel in this environment?</label>
                      <input type="range" class="rating-slider" min="1" max="10" value="${experience.responses.comfort}" oninput="updateSliderValue(this, 'edit-slider-comfort')" id="edit-comfort">
                      <div class="slider-value" id="edit-slider-comfort">${experience.responses.comfort}</div>
                    </div>
                    <div class="rating-question">
                      <label>How overwhelming was the environment? (Rate higher if it felt more overwhelming)</label>
                      <input type="range" class="rating-slider" min="1" max="10" value="${experience.responses.overwhelm}" oninput="updateSliderValue(this, 'edit-slider-overwhelm')" id="edit-overwhelm">
                      <div class="slider-value" id="edit-slider-overwhelm">${experience.responses.overwhelm}</div>
                    </div>
                    <div class="rating-question">
                      <label>How likely are you to return?</label>
                      <input type="range" class="rating-slider" min="1" max="10" value="${experience.responses.return}" oninput="updateSliderValue(this, 'edit-slider-return')" id="edit-return">
                      <div class="slider-value" id="edit-slider-return">${experience.responses.return}</div>
                    </div>
                  </div>
                </div>
                
                <div style="text-align: center; margin-top: 2rem;">
                  <button type="submit" class="btn">Save Changes</button>
                  <button type="button" class="btn btn-secondary" onclick="closeEditExperienceModal()">Cancel</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("edit-experience-modal", closeEditExperienceModal);
    }

    function closeEditExperienceModal() {
      const modal = document.getElementById("edit-experience-modal");
      if (modal) modal.remove();
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    async function handleEditExperience(event, index) {
      console.log("CALLING HANDLE!!")
      let responses = {};
      let rawScore = 0;

      event.preventDefault();

      const userExperiences = DataLayer.load("userExperiences", []);
      const experience = userExperiences[index];

      if (!experience) return;

      // Update experience data
      experience.name = document.getElementById("edit-name").value.trim();
      experience.category = document.getElementById("edit-category").value;
      experience.location = document.getElementById("edit-location").value.trim();
      experience.description = document.getElementById("edit-description").value.trim();

      if (!experience.name || !experience.category || !experience.location) {
        NotificationSystem.show(
          "Please fill in all required fields including location.",
          "warning"
        );
        return;
      }

      ActivitySystem.ratingQuestions.forEach((question) => {
        let value = parseInt(document.getElementById(`edit-${question.id}`).value);

        if (question.reverse) {
          value = 11 - value; // Reverse score for overwhelming
        }
        responses[question.id] = value;
        rawScore += value * question.weight;
      });

      experience.responses = responses;
      experience.rawScore = rawScore;
      experience.socialIntensity = ActivitySystem.estimateSocialIntensity(experience.category, responses);
      experience.noiseLevel = ActivitySystem.estimateNoiseLevel(experience.category, responses);
      experience.crowdSize = ActivitySystem.estimateCrowdSize(experience.category, responses);

      // Save updated experiences locally
      DataLayer.save("userExperiences", userExperiences);

      // Also update the allExperiences in DataLayer if it exists
      const allExperiences = DataLayer.load("allExperiences", []);
      const updatedAllExperiences = allExperiences.map(exp => {
        if (exp.id === experience.id) {
          return { ...exp, ...experience };
        }
        return exp;
      });
      DataLayer.save("allExperiences", updatedAllExperiences);

      // Function to refresh all UI components
      const refreshAllUI = () => {
        // Clear all relevant caches to force a fresh load
        if (typeof CacheSystem !== 'undefined') {
          CacheSystem.clear('EXPERIENCES');

          // Clear feed cache if FeedSystem exists
          if (typeof FeedSystem !== 'undefined' && FeedSystem.store && FeedSystem.store.cacheKey) {
            CacheSystem.clear(FeedSystem.store.cacheKey);
            console.log('✅ Cleared feed cache:', FeedSystem.store.cacheKey);
          }

          // Clear any nearby experiences cache
          const currentUser = DataLayer.load('currentUser');
          if (currentUser && currentUser.id) {
            CacheSystem.clear(`NEARBY_${currentUser.id}`);
            console.log('✅ Cleared nearby experiences cache');
          }

          console.log('✅ Cleared all experience-related caches');
        }

        // Refresh all UI components
        // updateDashboard();
        // updateProfile();

        // Update feed if it exists
        if (typeof FeedSystem !== 'undefined' && FeedSystem.displayFeed) {
          FeedSystem.displayFeed();
        }

        // Refresh experiences modal if it's open
        const experiencesModal = document.getElementById('experiences-modal');
        if (experiencesModal) {
          console.log('✅ Refreshing experiences modal');
          closeExperiencesModal();
          setTimeout(() => {
            const freshData = DataLayer.load("userExperiences", []);
            console.log('🔍 Fresh data before modal refresh:', freshData);

            showExperiencesModal();
          }, 200);
        }

        // Refresh any other experience-related displays
        const currentPage = document.querySelector('.page:not(.hidden)');
        if (currentPage) {
          const currentPageId = currentPage.id;
          console.log('✅ Refreshing current page:', currentPageId);

          // Re-trigger page-specific updates
          if (typeof updateOnPageVisit === 'function') {
            updateOnPageVisit(currentPageId);
          }
        }
      };

      // Update Firebase if user is authenticated
      if (currentFirebaseUser && authManager && experience.id) {
        try {
          const { doc, updateDoc, collection, query, where, getDocs, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Find the experience in Firebase and update it
          const experiencesCollection = collection(authManager.db, 'experiences');
          const experienceQuery = query(
            experiencesCollection,
            where('userId', '==', currentFirebaseUser.uid),
            where('id', '==', experience.id)
          );

          const experienceSnapshot = await wrapRead(getDocs(experienceQuery), 'getDocs', 'experiences', { userId: currentFirebaseUser.uid, id: experience.id });

          if (!experienceSnapshot.empty) {
            const experienceDoc = experienceSnapshot.docs[0];
            await wrapWrite(
              updateDoc(doc(authManager.db, 'experiences', experienceDoc.id), {
                name: experience.name,
                category: experience.category,
                location: experience.location,
                description: experience.description,
                responses: experience.responses,
                rawScore: experience.rawScore,
                socialIntensity: experience.socialIntensity,
                noiseLevel: experience.noiseLevel,
                crowdSize: experience.crowdSize,
                updatedAt: serverTimestamp()
              }),
              'updateDoc',
              `experiences/${experienceDoc.id}`,
              { reason: 'editExperience' }
            );
            console.log('Experience updated in Firebase');
          } else {
            // If we can't find by ID, try to find by other properties
            const fallbackQuery = query(
              experiencesCollection,
              where('userId', '==', currentFirebaseUser.uid),
              where('name', '==', experience.name),
              where('category', '==', experience.category)
            );

            const fallbackSnapshot = await wrapRead(getDocs(fallbackQuery), 'getDocs', 'experiences', { userId: currentFirebaseUser.uid, name: experience.name });
            if (!fallbackSnapshot.empty) {
              const experienceDoc = fallbackSnapshot.docs[0];
              await wrapWrite(
                updateDoc(doc(authManager.db, 'experiences', experienceDoc.id), {
                  name: experience.name,
                  category: experience.category,
                  location: experience.location,
                  description: experience.description,
                  responses: experience.responses,
                  rawScore: experience.rawScore,
                  socialIntensity: experience.socialIntensity,
                  noiseLevel: experience.noiseLevel,
                  crowdSize: experience.crowdSize,
                  updatedAt: serverTimestamp()
                }),
                'updateDoc',
                `experiences/${experienceDoc.id}`,
                { reason: 'editExperienceFallback' }
              );
              console.log('Experience updated in Firebase (fallback method)');
            }
          }

          // Refresh UI AFTER Firebase update completes
          setTimeout(() => {
            refreshAllUI();

            // Force reload of user experiences from Firebase AFTER the update
            if (typeof loadUserExperiencesWithCache === 'function') {
              loadUserExperiencesWithCache().then(() => {
                console.log('✅ Reloaded experiences from Firebase');
                // Final UI refresh after reload
                setTimeout(() => {
                  refreshAllUI();
                }, 50);
              }).catch(error => {
                console.error('Error reloading experiences:', error);
              });
            }
          }, 100);

        } catch (error) {
          console.error('Error updating experience in Firebase:', error);
          NotificationSystem.show('Experience updated locally, but failed to sync with server.', 'warning');

          // Still refresh UI even if Firebase update failed
          setTimeout(() => {
            refreshAllUI();
          }, 100);
        }
      } else {
        // No Firebase update needed, refresh UI immediately
        setTimeout(() => {
          refreshAllUI();
        }, 100);
      }

      // Close modal and show success message
      closeEditExperienceModal();
      NotificationSystem.show("Experience updated successfully!", "success");
    }
    
    async function deleteExperience(index) {
      if (confirm("Are you sure you want to delete this experience? This action cannot be undone.")) {
        const userExperiences = DataLayer.load("userExperiences", []);
        const experienceToDelete = userExperiences[index];

        // Remove from local storage
        userExperiences.splice(index, 1);
        DataLayer.save("userExperiences", userExperiences);

        // Delete from Firebase if user is authenticated and experience has Firebase ID
        if (currentFirebaseUser && authManager && experienceToDelete.id) {
          try {
            const { doc, deleteDoc, collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

            // Find the experience in Firebase and delete it
            const experiencesCollection = collection(authManager.db, 'experiences');
            const experienceQuery = query(
              experiencesCollection,
              where('userId', '==', currentFirebaseUser.uid),
              where('id', '==', experienceToDelete.id)
            );

            const experienceSnapshot = await wrapRead(getDocs(experienceQuery), 'getDocs', 'experiences', { userId: authManager.auth.currentUser.uid, name });

            if (!experienceSnapshot.empty) {
              const experienceDoc = experienceSnapshot.docs[0];
              await wrapWrite(
                deleteDoc(doc(authManager.db, 'experiences', experienceDoc.id)),
                'deleteDoc',
                `experiences/${experienceDoc.id}`,
                { reason: 'deleteExperience' }
              );
              console.log('Experience deleted from Firebase');
            } else {
              // If we can't find by ID, try to find by other properties
              const fallbackQuery = query(
                experiencesCollection,
                where('userId', '==', currentFirebaseUser.uid),
                where('name', '==', experienceToDelete.name),
                where('category', '==', experienceToDelete.category)
              );

              const fallbackSnapshot = await wrapRead(getDocs(fallbackQuery), 'getDocs', 'experiences', { userId: authManager.auth.currentUser.uid, category });
              if (!fallbackSnapshot.empty) {
                const experienceDoc = fallbackSnapshot.docs[0];
                await wrapWrite(
                  deleteDoc(doc(authManager.db, 'experiences', experienceDoc.id)),
                  'deleteDoc',
                  `experiences/${experienceDoc.id}`,
                  { reason: 'deleteExperienceFallback' }
                );
                console.log('Experience deleted from Firebase (fallback method)');
              }
            }
          } catch (error) {
            console.error('Error deleting experience from Firebase:', error);
            NotificationSystem.show('Experience deleted locally, but failed to sync with server.', 'warning');
          }
        }

        closeExperiencesModal();
        NotificationSystem.show("Experience deleted successfully!", "success");

        // Refresh the page data
        updateDashboard();
        updateProfile();
      }
    }

    // Updated showCreateGroupModal to limit to 3-6 friends displayed
    async function showCreateGroupModal() {
      const friends = await FriendsSystem.getFriends();

      if (!friends || friends.length === 0) {
        NotificationSystem.show(
          "Add some friends first before creating a group!",
          "warning"
        );
        showPage("feed");
        return;
      }

      // Limit to first 6 friends for better UI
      const displayFriends = friends.slice(0, 6);

      const modalHtml = `
    <div id="group-modal" class="modal">
      <div class="modal-content">
        <button class="modal-close" onclick="closeModal()">&times;</button>
        <div class="modal-header">
          <h2>Create New Group</h2>
        </div>
        <div class="modal-body">
          <form id="group-form" onsubmit="handleCreateGroup(event).catch(error => {
            console.error('Error creating group:', error);
            NotificationSystem.show('Error creating group. Please try again.', 'error');
          })">
            <div class="form-group">
              <label for="group-name">Group Name *</label>
              <input type="text" id="group-name" class="form-control" placeholder="e.g., Friday Night Crew, Study Group" required>
            </div>
            <div class="form-group">
              <label for="group-description">Description</label>
              <textarea id="group-description" class="form-control" placeholder="What's this group about?"></textarea>
            </div>
            <div class="form-group">
              <label>Add Friends to Group *</label>
              <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">Select friends to add to your group:</p>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 0.8rem;">
                ${displayFriends
          .map(
            (friend) => `
                    <div style="display: flex; align-items: center; gap: 1rem; padding: 0.8rem; border: 1px solid #eee; border-radius: 8px;">
                      <input type="checkbox" id="member-${friend.id}" value="${friend.id
              }">
                      <div class="feed-avatar" style="width: 35px; height: 35px; font-size: 1rem;">${friend.avatar
              }</div>
                                          <div style="flex: 1;">
                      <strong>${addCrownToPremiumUser(friend.displayName, friend.id)}</strong>
                      <div style="font-size: 0.8rem; color: var(--secondary-color);">${friend.personalityType
              }</div>
                      <div style="font-size: 0.8rem; color: #888;">AF: ${friend.adjustmentFactor.toFixed(
                2
              )}</div>
                    </div>
                    </div>
                `
          )
          .join("")}
              </div>
              ${friends.length > 6
          ? `<p style="font-size: 0.8rem; color: #888; margin-top: 0.5rem; font-style: italic;">Showing first 6 friends. You can add more after creating the group.</p>`
          : ""
        }
            </div>
            <div style="text-align: center; margin-top: 2rem;">
              <button type="submit" class="btn">Create Group</button>
              <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);

      // Add ESC and click-outside functionality
      addModalListeners("group-modal", closeModal);
    }

    // Enhanced closeModal function
    function closeModal() {
      const modal = document.getElementById("group-modal");
      if (modal) {
        modal.style.animation = "fadeOut 0.3s ease forwards";
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove();
          }
        }, 300);
      }
    }

    // Comprehensive caching system to reduce Firebase reads
    const CacheSystem = {
      // Cache durations in milliseconds (optimized for 1000+ users)
      CACHE_DURATIONS: {
        FRIENDS: 600000,        // 10 minutes (increased from 5)
        GROUPS: 900000,         // 15 minutes (increased from 10)
        FRIEND_REQUESTS: 300000, // 5 minutes (increased from 2)
        SIMILAR_USERS: 600000,  // 10 minutes (increased from 5)
        USER_PROFILES: 1800000, // 30 minutes (increased from 15)
        EXPERIENCES: 3600000,   // 60 minutes (increased from 30)
        LOCATIONS: 600000,      // 10 minutes (increased from 5)
        ACTIVITIES: 1800000,    // 30 minutes (new)
        RECOMMENDATIONS: 900000, // 15 minutes (new)
        FRIEND_STATUSES: 120000, // 2 minutes (short cache for status)
        ALL_USERS_BASIC: 300000  // 5 minutes (basic user data)
      },

      isInvalidating: false, // Prevent invalidation loops

      // Get cached data with timestamp validation
      get: (key, duration = 300000) => {
        const cache = DataLayer.load(`cache_${key}`, {});
        const now = Date.now();

        if (cache.timestamp && (now - cache.timestamp) < duration && cache.data) {
          console.log(`Using cached data for: ${key}`);
          return cache.data;
        }

        console.log(`Cache miss for: ${key}`);
        return null;
      },

      // Set cached data with timestamp
      set: (key, data) => {
        DataLayer.save(`cache_${key}`, {
          timestamp: Date.now(),
          data: data
        });
        console.log(`Cached data for: ${key}`);
      },

      // Clear specific cache
      clear: (key) => {
        DataLayer.remove(`cache_${key}`);
        console.log(`Cleared cache for: ${key}`);
      },

      // Clear all caches
      clearAll: () => {
        Object.keys(CacheSystem.CACHE_DURATIONS).forEach(key => {
          CacheSystem.clear(key);
        });
        console.log('Cleared all caches');
      },

      // Invalidate specific caches when data changes
      invalidateFriendsCache: () => {
        if (!CacheSystem.isInvalidating) {
          CacheSystem.isInvalidating = true;
          CacheSystem.clear('FRIENDS');
          CacheSystem.clear('SIMILAR_USERS'); // Friends list affects similar users
          CacheSystem.clear('FRIEND_REQUESTS');
          CacheSystem.clear('ALL_USERS_BASIC');
          // Reset friends system initialization flag
          if (typeof FriendsDiscoverySystem !== 'undefined') {
            FriendsDiscoverySystem.isInitialized = false;
          }
          CacheSystem.isInvalidating = false;
        }
      },

      invalidateGroupsCache: () => {
        if (!CacheSystem.isInvalidating) {
          CacheSystem.isInvalidating = true;
          CacheSystem.clear('GROUPS');
          CacheSystem.isInvalidating = false;
        }
      },

      invalidateUserCache: () => {
        if (!CacheSystem.isInvalidating) {
          CacheSystem.isInvalidating = true;
          CacheSystem.clear('SIMILAR_USERS');
          CacheSystem.clear('USER_PROFILES');
          CacheSystem.isInvalidating = false;
        }
      },

      // Batch operations to reduce Firebase calls
      batchUpdate: async (operations) => {
        try {
          const { writeBatch } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const batch = writeBatch(authManager.db);
          // Log batch start (without awaiting a promise)
          FirebaseWriteLogger.log('writeBatch', 'batch', { operations: operations.length }, null, null);

          operations.forEach(op => {
            if (op.type === 'set') {
              batch.set(op.ref, op.data);
            } else if (op.type === 'update') {
              batch.update(op.ref, op.data);
            } else if (op.type === 'delete') {
              batch.delete(op.ref);
            }
          });

          await batch.commit();
          console.log(`Batch operation completed: ${operations.length} operations`);
        } catch (error) {
          console.error('Batch operation failed:', error);
        }
      },

      // Pagination for large datasets
      getPaginatedData: async (collectionName, pageSize = 20, lastDoc = null) => {
        try {
          const { collection, query, orderBy, limit, startAfter, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          let q = query(collection(authManager.db, collectionName), orderBy('createdAt'), limit(pageSize));

          if (lastDoc) {
            q = query(q, startAfter(lastDoc));
          }

          const snapshot = await wrapRead(getDocs(q), 'getDocs', collectionName, { pageSize, lastDoc: !!lastDoc });
          const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

          return {
            data,
            lastDoc: snapshot.docs[snapshot.docs.length - 1],
            hasMore: snapshot.docs.length === pageSize
          };
        } catch (error) {
          console.error('Pagination error:', error);
          return { data: [], lastDoc: null, hasMore: false };
        }
      }
    };

    // Function to manage Firebase listeners based on current page
    function manageFirebaseListeners() {
      const currentPage = document.querySelector('.page:not(.hidden)').id;

      // Only initialize listeners for relevant pages to reduce reads
      if (currentPage === 'groups' && !realtimeListeners.groups) {
        initializeGroupUpdateListeners();
      } else if ((currentPage === 'friendship' || currentPage === 'dashboard') && !realtimeListeners.friendRequests) {
        initializeFriendRequestListeners();
      }
    }

    const fadeOutStyle = document.createElement("style");
    fadeOutStyle.textContent = `
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
`;
    document.head.appendChild(fadeOutStyle);
    function closeModal() {
      const modal = document.getElementById("group-modal");
      if (modal) {
        modal.remove();
      }
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    // Recommendation System
    const RecommendationSystem = {
      displayRecommendations: () => {
        const personalityData = DataLayer.load("personalityScore");
        if (!personalityData) return "";

        const recommendations = ActivitySystem.getRecommendations(
          personalityData.adjustmentFactor
        );
        const friends = []; // Fallback to empty array for now

        if (recommendations.length === 0) {
          if (friends.length === 0) {
            return `
          <div style="margin-bottom: 2rem;">
            <h3>No Recommendations Yet</h3>
            <p style="color: #666;">Add friends to get personalized recommendations based on places they've visited!</p>

          </div>
        `;
          } else {
            return `
          <div style="margin-bottom: 2rem;">
            <h3>No New Recommendations</h3>
            <p style="color: #666;">Your friends haven't shared new places recently. Check the community feed for more experiences!</p>
          </div>
        `;
          }
        }

        return `
      <div style="margin-bottom: 2rem;">
        <h3>Recommended For You (From Friends)</h3>
        <p style="color: #666; margin-bottom: 1rem;">Based on places your friends have visited and enjoyed</p>
        <div class="activity-grid">
          ${recommendations
            .slice(0, 4)
            .map(
              (rec) => `
            <div class="activity-card" style="border: 2px solid var(--secondary-color);">
                              <div style="background: var(--secondary-gradient); color: white; padding: 0.5rem; margin: -1.5rem -1.5rem 1rem -1.5rem; border-radius: 15px 15px 0 0;">
                <div style="font-weight: bold;">Recommended: ${rec.predictedScore.toFixed(
                1
              )}/10</div>
                <div style="font-size: 0.8rem; opacity: 0.9;">Confidence: ${(
                  rec.confidence * 100
                ).toFixed(0)}%</div>
              </div>
              <div class="activity-title">${rec.experience.name}</div>
              <div class="activity-category">${rec.experience.category} • ${rec.experience.location
                }</div>
              <div class="activity-details">
                ${rec.experience.description
                  ? `<p style="margin: 0.5rem 0; color: #666;">"${rec.experience.description}"</p>`
                  : ""
                }
                <div style="font-size: 0.9rem; color: #888; margin-top: 0.5rem;">
                  Social Intensity: ${rec.experience.socialIntensity.toFixed(
                  1
                )}/10 |
                  Noise Level: ${rec.experience.noiseLevel.toFixed(1)}/10 |
                  Crowd Size: ${rec.experience.crowdSize.toFixed(1)}/10
                </div>
              </div>
              <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                <div style="font-size: 0.9rem; color: #666; margin-bottom: 0.5rem;">
                  Recommended by friends:
                </div>
                ${rec.predictions
                  .slice(0, 2)
                  .map(
                    (p) => `
                  <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; margin-bottom: 0.3rem;">
                    <span>${addCrownToPremiumUser(p.user.displayName, p.user.id)} (${p.user.personalityType})</span>
                    <span style="font-weight: bold;">${p.experience.adjustedScore}/10</span>
                  </div>
                `
                  )
                  .join("")}
                <div style="text-align: center; margin-top: 1rem;">
                  <button class="btn" style="font-size: 0.9rem; padding: 8px 16px;"
                          onclick="fillActivityForm('${rec.experience.name.replace(/'/g, "\\'")}', '${rec.experience.category.replace(/'/g, "\\'")}', '${rec.experience.location.replace(/'/g, "\\'")}', '${rec.experience.description ? rec.experience.description.replace(/'/g, "\\'") : ""}')">
                    Rate This Place
                  </button>
                </div>
              </div>  
            </div>
          `
            )
            .join("")}
        </div>
      </div>
    `;
      },
    };
    // Similar Users System
    const SimilarUsersSystem = {
      displaySimilarUsers: async () => {
        console.log('SimilarUsersSystem.displaySimilarUsers() called');
        const personalityData = DataLayer.load("personalityScore");
        if (!personalityData) {
          console.log('No personality data found, returning empty string');
          return "";
        }

        try {
          console.log('Finding similar users for adjustment factor:', personalityData.adjustmentFactor);
          const similarUsers = await ActivitySystem.findSimilarUsers(
            personalityData.adjustmentFactor
          );
          console.log('Found similar users:', similarUsers.length, similarUsers);

          // Get current friends
          console.log('Getting current friends...');
          const friends = await FriendsSystem.getFriends();
          const friendIds = friends.map(friend => friend.id);
          console.log('Current friends:', friends.length, friendIds);

          // Filter out users who are already friends
          const nonFriendUsers = similarUsers.filter(
            (user) => !friendIds.includes(user.id)
          );
          console.log('Non-friend users:', nonFriendUsers.length, nonFriendUsers);

          return `
      <div style="margin-bottom: 2rem;">
        <h3>Users Similar to You</h3>
        <p style="color: #666; margin-bottom: 1rem;">Connect with people who have similar social energy preferences</p>



        <div class="similar-users-grid">
          ${nonFriendUsers.length > 0
              ? nonFriendUsers
                .slice(0, 6)
                .map((user) => {
                  return `
              <div class="similar-user-card">
                <div style="display: flex; align-items: center; gap: 0.8rem; margin-bottom: 0.8rem;">
                  <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--secondary-gradient); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                      ${user.avatar || user.displayName.charAt(0)}
                  </div>
                  <div style="text-align: left;">
                      <div style="font-weight: bold;">${addCrownToPremiumUser(user.displayName, user.id)}</div>
                      <div style="font-size: 0.8rem; color: var(--highlight);">${user.personalityType || 'Unknown'}</div>
                  </div>
                </div>
                <div class="similarity-score">
                    ${(user.similarityScore * 100).toFixed(0)}% Similar
                </div>    
                <div style="font-size: 0.8rem; color: #666; margin: 0.8rem 0;">
                    AF: ${user.adjustmentFactor.toFixed(2)}
                </div>
                  ${user.bio ? `<div style="font-size: 0.9rem; color: #666; margin-bottom: 0.8rem;">"${user.bio}"</div>` : ''}
                  <div style="text-align: center;">
                    ${(() => {
                      // Check pending status first
                      const hasPendingRequest = typeof FriendsDiscoverySystem !== 'undefined' &&
                        Array.isArray(FriendsDiscoverySystem.pendingRequests) &&
                        FriendsDiscoverySystem.pendingRequests.some(r => r.toUserId === user.id);

                      if (hasPendingRequest) {
                        return `<button class=\"btn\" data-pending-for=\"${user.id}\" style=\"font-size: 0.8rem; padding: 6px 12px; background: #fbbf24; color: #1f2937; border: 1px solid #f59e0b;\" onclick=\"FriendsDiscoverySystem.cancelPendingRequest('${user.id}')\"><i class=\"fas fa-clock\"></i> Pending</button>`;
                      } else {
                        return `<button class="btn" style="font-size: 0.8rem; padding: 6px 12px;" onclick="FriendsSystem.addFriend('${user.id}')">Add Friend</button>`;
                      }
                    })()}
                </div>
                </div>
              `;
                }).join("")
              : '<div style="grid-column: 1 / -1; color: #666; text-align: center; padding: 2rem;">No similar users found. Try expanding your search or check back later!</div>'
            }
                </div>
              </div>
            `;
        } catch (error) {
          console.error('Error displaying similar users:', error);
          return `
      <div style="margin-bottom: 2rem;">
        <h3>Users Similar to You</h3>
        <p style="color: #666; text-align: center; padding: 2rem;">Unable to load similar users at this time.</p>
      </div>
    `;
        }
      },
    };

    function updateDashboard() {
      const personalityData = DataLayer.load("personalityScore");
      const personalityType = DataLayer.load("personalityType");
      const currentUser = DataLayer.load("currentUser");

      console.log('updateDashboard called with:', { personalityData, personalityType, currentUser });

      // Check if user has completed personality assessment
      const hasCompletedAssessment = personalityData &&
        personalityType &&
        personalityData.adjustmentFactor !== undefined &&
        personalityType.type !== 'Not Set';

      console.log('hasCompletedAssessment:', hasCompletedAssessment);

      if (hasCompletedAssessment && DataLayer.exists("currentUser")) {
        document.getElementById("user-avatar").textContent =
          currentUser.avatar;
        document.getElementById(
          "welcome-message"
        ).innerHTML = `Welcome back, <strong>${currentUser.displayName}</strong>! You're a ${personalityType.type}`;

        const userExperiences = DataLayer.load("userExperiences", []);
        const groups = DataLayer.load("groups", []);

        // Set initial dashboard content without similar users
        document.getElementById("dashboard-content").innerHTML = `
      <div style="margin-bottom: 2rem;">
        <h2>Your Social Energy Profile</h2>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value">${personalityData?.adjustmentFactor?.toFixed(2) || '0.00'}</div>
            <div class="stat-label">Adjustment Factor</div>
          </div>
          <div class="stat-card" onclick="showExperiencesModal()" style="cursor: pointer;">
            <div class="stat-value">${userExperiences.length}</div>
            <div class="stat-label">Experiences</div>
          </div>
          <div class="stat-card" onclick="showPage('groups')" style="cursor: pointer;">
            <div class="stat-value">${groups.length}</div>
            <div class="stat-label">Groups</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${personalityType.type}</div>
            <div class="stat-label">Personality Type</div>
          </div>
        </div>
        <p style="font-style: italic; color: #666; margin: 1.5rem 0; text-align: center;">"${personalityType?.description || 'You have a balanced approach to social energy.'}"</p>
        <div class="action-buttons">
          <button class="btn" onclick="showPage('activities')"><i class="fas fa-plus-circle"></i> Add Experience</button>
          <button class="btn btn-secondary" onclick="showPage('feed')"><i class="fas fa-users"></i> Explore Community</button>
          <button class="btn btn-info" onclick="getLocationBasedRecommendations()" style="background: var(--info-color);">
            <i class="fas fa-map-marker-alt"></i> Find Places Near Me
          </button>
        </div>
      </div>

              ${RecommendationSystem.displayRecommendations()}
      
      <div id="similar-users-container">
        <div style="text-align: center; padding: 2rem;">
          <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite;"></div>
          <p style="margin-top: 1rem; color: #666;">Loading similar users...</p>
        </div>
      </div>
    `;

        // Load similar users asynchronously
        SimilarUsersSystem.displaySimilarUsers()
          .then(similarUsersHtml => {
            const container = document.getElementById('similar-users-container');
            if (container) {
              container.innerHTML = similarUsersHtml;
            }
          })
          .catch(error => {
            console.error('Error loading similar users:', error);
            const container = document.getElementById('similar-users-container');
            if (container) {
              container.innerHTML = `
                <div style="text-align: center; padding: 2rem; color: #666;">
                  <p>Unable to load similar users at this time.</p>
                </div>
              `;
            }
          });
      } else {
        // User hasn't completed assessment yet
        document.getElementById("user-avatar").textContent = currentUser?.avatar || "?";
        document.getElementById("welcome-message").innerHTML =
          `Welcome, <strong>${currentUser?.displayName || 'User'}</strong>! Complete the personality assessment to get started.`;

        document.getElementById("dashboard-content").innerHTML = `
          <div style="margin-bottom: 2rem;">
            <h2>Get Started with Senergy</h2>
            <p style="padding: 1.2rem; text-align: center;">
              Take the personality assessment to discover your social energy preferences and get personalized recommendations.
            </p>
            <div class="action-buttons">
              <button class="btn" onclick="showPage('assessment')">
                <i class="fas fa-play-circle"></i> Start Assessment
              </button>
            </div>
          </div>
        `;
      }
    }

    function updateProfile() {
      const personalityData = DataLayer.load("personalityScore");
      const personalityType = DataLayer.load("personalityType");
      const userExperiences = DataLayer.load("userExperiences", []);
      const groups = DataLayer.load("groups", []);
      const currentUser = DataLayer.load("currentUser");

      const profileContent = document.getElementById("profile-content");

      // Use the same condition as updateDashboard for consistency
      const hasCompletedAssessment = personalityData &&
        personalityType &&
        personalityData.adjustmentFactor !== undefined &&
        personalityType.type !== 'Not Set';

      if (!hasCompletedAssessment) {
        profileContent.innerHTML = `
      <div class="centered">
        <p style="padding: 1.2rem;">Complete the personality assessment to see your profile.</p>
        <button class="btn" onclick="showPage('assessment')">Take Assessment</button>
      </div>
    `;
        return;
      }

      const avgRating =
        userExperiences.length > 0
          ? userExperiences.reduce(
            (sum, exp) => sum + parseFloat(exp.adjustedScore),
            0
          ) / userExperiences.length
          : 0;

      // Get recommendations for profile (only from real users)
      const recommendations = ActivitySystem.getRecommendations(
        personalityData.adjustmentFactor
      );
      const unratedRecommendations = recommendations.filter(
        (rec) =>
          !userExperiences.some(
            (userExp) =>
              userExp.name.toLowerCase() === rec.experience.name.toLowerCase()
          )
      );

      // Get similar users (only real users) - handle async
      let similarUsers = [];
      ActivitySystem.findSimilarUsers(personalityData.adjustmentFactor)
        .then(users => {
          similarUsers = users;
          // Update the profile content with similar users if needed
          const profileContent = document.getElementById('profile-content');
          if (profileContent) {
            // Re-render the similar users section
            const similarUsersSection = profileContent.querySelector('.similar-users-section');
            if (similarUsersSection) {
              similarUsersSection.innerHTML = `
                <h3>Most Compatible Users</h3>
                <div class="similar-users-grid">
                  ${similarUsers.length > 0
                  ? similarUsers.slice(0, 6).map(user => `
                      <div class="similar-user-card">
                        <div style="display: flex; align-items: center; gap: 0.8rem; margin-bottom: 0.8rem;">
                          <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--secondary-gradient); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                            ${user.avatar || user.displayName.charAt(0)}
                          </div>
                          <div style="text-align: left;">
                            <div style="font-weight: bold;">${addCrownToPremiumUser(user.displayName, user.id)}</div>
                            <div style="font-size: 0.8rem; color: var(--highlight);">${user.personalityType || 'Unknown'}</div>
                          </div>
                        </div>
                        <div class="similarity-score">
                          ${(user.similarityScore * 100).toFixed(0)}% Similar
                        </div>
                        <div style="text-align: center;">
                          <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;" onclick="FriendsSystem.addFriend('${user.id}')">Add Friend</button>
                        </div>
                      </div>
                    `).join("")
                  : '<div style="grid-column: 1 / -1; color: #666; text-align: center; padding: 2rem;">No similar users found. Try expanding your search or check back later!</div>'
                }
                </div>
              `;
            }
          }
        })
        .catch(error => {
          console.error('Error loading similar users for profile:', error);
        });

      profileContent.innerHTML = `
    <div class="user-info" style="margin-bottom: 2rem;">
      <div class="avatar" style="width: 80px; height: 80px; font-size: 2rem;">${currentUser.avatar
        }</div>
      <div>
        <h2 style="margin: 0;">${personalityType.type}</h2>
        <div style="color: var(--secondary-color); font-weight: bold; margin: 0.5rem 0;">Adjustment Factor: ${personalityData.adjustmentFactor.toFixed(
          2
        )}</div>
        <div style="color: #666; font-style: italic;">"${personalityType?.description || 'You have a balanced approach to social energy.'}"</div>
      </div>
    </div>

    <div class="location-info" style="margin-bottom: 2rem; padding: 1rem; background: rgba(74, 144, 226, 0.1); border-radius: 10px;">
      <h4 style="margin: 0 0 0.5rem 0; color: var(--primary-color);">
        <i class="fas fa-map-marker-alt"></i> Your Location
      </h4>
      <div style="display: flex; align-items: center; gap: 1rem;">
        <div style="flex: 1;">
          <div style="font-size: 0.9rem; color: #666;">
            ${currentUser.location ?
          `Latitude: ${currentUser.location.lat.toFixed(4)}, Longitude: ${currentUser.location.lng.toFixed(4)}` :
          'Location not set'
        }
          </div>
          <div style="font-size: 0.8rem; color: #888; margin-top: 0.2rem;">
            This location is used for weather-based activity recommendations
          </div>
        </div>
        <button class="btn btn-secondary" onclick="handleUpdateUserLocation()" style="font-size: 0.8rem; padding: 8px 16px;">
          <i class="fas fa-location-arrow"></i> Update Location
        </button>
      </div>
    </div>

    <div class="stats-grid" style="margin-bottom: 2rem;">
      <div class="stat-card" onclick="showExperiencesModal()" style="cursor: pointer;">
        <div class="stat-value">${userExperiences.length}</div>
        <div class="stat-label">Experiences</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${avgRating > 0 ? avgRating.toFixed(1) : "0.0"
        }</div>
        <div class="stat-label">Avg Rating</div>
      </div>
      <div class="stat-card" onclick="showPage('groups')" style="cursor: pointer;">
        <div class="stat-value">${groups.length}</div>
        <div class="stat-label">Groups</div>
      </div>
      <div class="stat-card" onclick="getLocationBasedRecommendations()" style="cursor: pointer;">
        <div class="stat-value">${unratedRecommendations.length}</div>
        <div class="stat-label">New Recommendations</div>
      </div>
    </div>

    ${userExperiences.length > 0
          ? `
    <div class="card" style="margin-bottom: 2rem;">
      <h3>Your Experiences</h3>
      <div style="max-height: 400px; overflow-y: auto;">
        ${userExperiences
            .map(
              (exp) => `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; border: 1px solid #eee; border-radius: 10px; margin-bottom: 0.5rem;">
              <div style="flex: 1;">
                <div style="font-weight: bold; margin-bottom: 0.2rem;">${exp.name
                }</div>
                <div style="color: var(--secondary-color); font-size: 0.9rem; margin-bottom: 0.2rem;">${exp.category
                } • ${exp.location}</div>
                ${exp.description
                  ? `<div style="color: #666; font-size: 0.8rem; margin-bottom: 0.2rem;">"${exp.description}"</div>`
                  : ""
                }
                <div style="color: #888; font-size: 0.8rem;">
                  <span title="${formatFullDate(exp.timestamp)}" style="cursor: help;">
                    ${new Date(exp.timestamp).toLocaleDateString()}
                  </span> •
                  Social: ${exp.socialIntensity.toFixed(1)}/10 •
                  Noise: ${exp.noiseLevel.toFixed(1)}/10 •
                  Crowd: ${exp.crowdSize.toFixed(1)}/10
                </div>
              </div>
              <div style="text-align: right; margin-left: 1rem;">
                <div style="font-weight: bold; font-size: 1.3rem; color: var(--secondary-color);">${exp.adjustedScore
                }/10</div>

              </div>
            </div>
        `
            )
            .join("")}
      </div>
    </div>`
          : `
    <div class="card" style="margin-bottom: 2rem;">
      <h3>Your Experiences</h3>
      <div class="empty-state">
        <p>You haven't added any experiences yet.</p>
        <button class="btn" onclick="showPage('activities')">Add Your First Experience</button>
      </div>
    </div>`
        }

    <div class="card" style="margin-bottom: 2rem;">
      <h3>Personality Breakdown</h3>
      <div style="margin-bottom: 1rem;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
          <span>Introversion</span>
          <span>Ambiversion</span>
          <span>Extroversion</span>
        </div>
        <div style="width: 100%; height: 20px; background: #f0f0f0; border-radius: 10px; position: relative;">
          <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 2px; height: 100%; background: #ccc;"></div>
          <div style="width: ${((personalityData.adjustmentFactor + 1) / 2) * 100
        }%; height: 100%; background: var(--primary-gradient); border-radius: 10px; position: relative;">
            <div style="position: absolute; right: -10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; background: white; border: 3px solid var(--secondary-color); border-radius: 50%;"></div>
          </div>
        </div>
        <div style="text-align: center; margin-top: 0.5rem; font-weight: bold; color: var(--secondary-color);">
          ${personalityData.adjustmentFactor.toFixed(2)}
        </div>
      </div>
    </div>

            <div class="card similar-users-section" style="margin-bottom: 2rem;">
          <h3>Most Compatible Users</h3>
          <div class="similar-users-grid">
            <p style="color: #666; text-align: center; padding: 2rem;">Loading similar users...</p>
          </div>
        </div>

    <div class="action-buttons">
      <button class="btn" onclick="showPage('activities')"><i class="fas fa-plus-circle"></i> Add Experience</button>
      <button class="btn btn-secondary" onclick="showPage('dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
      <button class="btn btn-secondary" onclick="showPage('groups')"><i class="fas fa-users"></i> Groups</button>
      <button class="btn btn-info" onclick="showEditProfileModal()"><i class="fas fa-edit"></i> Edit Profile</button>
    </div>
  `;
    }

    // Manage navigation visibility based on authentication
    function updateNavigationVisibility() {
      const nav = document.querySelector('nav');
      if (nav) {
        if (currentFirebaseUser) {
          nav.style.display = 'flex';
        } else {
          nav.style.display = 'none';
        }
      }
    }

    // UI Management
    function showPage(pageId) {
      console.log('📱 showPage() called with pageId:', pageId);
      // Check authentication for protected pages
      const protectedPages = ['dashboard', 'assessment', 'activities', 'feed', 'groups', 'friends', 'profile'];
      if (protectedPages.includes(pageId) && !currentFirebaseUser) {
        // Don't redirect if we're already on an auth page
        const currentPage = document.querySelector('.page:not(.hidden)');
        if (currentPage && ['login', 'register'].includes(currentPage.id)) {
          return;
        }
        showPage('login');
        return;
      }

      // Hide all pages
      document.querySelectorAll(".page").forEach((page) => {
        page.classList.add("hidden");
      });

      // Update active navigation
      document.querySelectorAll(".nav-links a").forEach((link) => {
        link.classList.remove("active");
      });
      const navElement = document.getElementById(`nav-${pageId}`);
      if (navElement) {
        navElement.classList.add("active");
      }

      // Show selected page
      document.getElementById(pageId).classList.remove("hidden");

      // Update navigation visibility
      updateNavigationVisibility();

      // Page-specific initialization
      switch (pageId) {
        case "login":
          // Reset forms (check if they exist first)
          const loginForm = document.getElementById('login-form');
          const registerForm = document.getElementById('register-form');

          if (loginForm) loginForm.reset();
          if (registerForm) registerForm.reset();

          showLoginForm();
          break;
        case "dashboard":
          updateOnPageVisit('dashboard');
          break;
        case "assessment":
          PersonalityAssessment.init();
          break;
        case "activities":
          if (!DataLayer.exists("personalityScore")) {
            NotificationSystem.show(
              "Please complete the personality assessment first!",
              "warning"
            );
            showPage("assessment");
            return;
          }
          // Initialize location functionality immediately
          setTimeout(() => {
            initializeLocationAutocomplete();
            // Auto-get current location when page opens
            autoFillCurrentLocation();
          }, 500);
          break;
        case "feed":
          console.log('📱 Feed page selected, calling updateOnPageVisit');
          updateOnPageVisit('feed');
          break;
        case "groups":
          updateOnPageVisit('groups');
          // Also update usage display immediately
          setTimeout(() => {
            const usage = GroupsSystem.getGroupUsage();
            const usageText = document.getElementById("group-usage-text");
            const premiumStatusText = document.getElementById("premium-status-text");

            if (usageText) {
              usageText.textContent = `${usage.current}/${usage.limit}`;
              if (usage.isPremium) {
                usageText.style.background = "var(--primary-color)";
                usageText.style.color = "white";
              } else {
                usageText.style.background = "var(--primary-color)";
                usageText.style.color = "white";
              }
            }

            if (premiumStatusText) {
              if (usage.isPremium) {
                premiumStatusText.innerHTML = "Premium - Unlimited Groups";
              } else {
                premiumStatusText.innerHTML = '<a href="#" onclick="showPremiumUpgradeModal()" style="color: var(--secondary-color); text-decoration: none;">Upgrade to Premium for unlimited groups</a>';
              }
            }
          }, 50);
          break;

        case "friends":
          updateOnPageVisit('friends');
          // Initialize friends system only when tab is clicked (optimized loading)
          if (typeof FriendsDiscoverySystem !== 'undefined') {
            FriendsDiscoverySystem.init();
          }
          break;

        case "profile":
          updateOnPageVisit('profile');
          break;
      }
    }

    function nextQuestion() {
      PersonalityAssessment.currentQuestion++;

      if (
        PersonalityAssessment.currentQuestion >=
        PersonalityAssessment.questions.length
      ) {
        PersonalityAssessment.showResults();
      } else {
        PersonalityAssessment.displayQuestion();
        document.getElementById("next-btn").disabled = true;
      }
    }

    async function completeAssessment() {
      // Ensure personality data is properly loaded from Firebase if user is authenticated
      if (currentFirebaseUser && authManager) {
        try {
          const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const userDoc = await getDoc(doc(authManager.db, 'users', currentFirebaseUser.uid));

          if (userDoc.exists()) {
            const userData = userDoc.data();

            // Update local storage with Firebase data
            if (userData.adjustmentFactor !== undefined) {
              DataLayer.save('personalityScore', { adjustmentFactor: userData.adjustmentFactor });
              DataLayer.save('personalityType', { type: userData.personalityType });
            }

            // Update current user data
            let currentUser = DataLayer.load('currentUser') || {};
            currentUser.adjustmentFactor = userData.adjustmentFactor;
            currentUser.personalityType = userData.personalityType;
            currentUser.avatar = userData.avatar;
            DataLayer.save('currentUser', currentUser);

            console.log('Personality data synced from Firebase');
          }
        } catch (error) {
          console.error('Error syncing personality data from Firebase:', error);
        }
      }

      console.log('Completing assessment, redirecting to dashboard');

      // Update both dashboard and profile to ensure consistency
      updateDashboard();
      updateProfile();

      // Debug: Check what data is available
      const debugScores = DataLayer.load("personalityScore");
      const debugType = DataLayer.load("personalityType");
      const debugUser = DataLayer.load("currentUser");
      console.log('Debug data before dashboard:', { debugScores, debugType, debugUser });

      // Show success message
      NotificationSystem.show('Assessment completed successfully! Welcome to your personalized dashboard.', 'success');

      showPage("dashboard");
    }

    function updateSliderValue(slider, targetId) {
      document.getElementById(targetId).textContent = slider.value;
    }

    function resetActivityForm() {
      document.getElementById("activity-form").reset();

      // Reset all sliders to 5
      ActivitySystem.ratingQuestions.forEach((question) => {
        const slider = document.getElementById(`rating-${question.id}`);
        const display = document.getElementById(`slider-${question.id}`);
        if (slider && display) {
          slider.value = 5;
          display.textContent = "5";
        }
      });
    }

    // Function to get location-based recommendations
    function getLocationBasedRecommendations() {
      locationFound = false; // Reset flag at start

      NotificationSystem.show("Getting your location for nearby recommendations...", "info");

      getUserLocationWithFallback()
        .then((position) => {
          locationFound = true; // Set flag when location is found
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          // Get all experiences from the community
          const allExperiences = ActivitySystem.getAllExperiences();
          const userExperiences = DataLayer.load("userExperiences", []);
          const friends = []; // Fallback to empty array for now
          const friendIds = []; // Fallback to empty array for now

          // Get user's experience names to exclude them
          const userExperienceNames = userExperiences.map(exp => exp.name.toLowerCase());

          // Filter experiences that are within 50km of user's location and exclude user's own experiences
          const nearbyExperiences = allExperiences.filter(exp => {
            if (!exp.coordinates) return false;

            const distance = calculateDistance(lat, lng, exp.coordinates.lat, exp.coordinates.lng);
            const isUserExperience = userExperienceNames.includes(exp.name.toLowerCase());

            return distance <= 50 && !isUserExperience; // Within 50km and not user's own experience
          });

          // Sort by distance and rating
          nearbyExperiences.sort((a, b) => {
            const distanceA = calculateDistance(lat, lng, a.coordinates.lat, a.coordinates.lng);
            const distanceB = calculateDistance(lat, lng, b.coordinates.lat, b.coordinates.lng);

            // Prioritize by rating first, then distance
            if (Math.abs(a.adjustedScore - b.adjustedScore) > 1) {
              return b.adjustedScore - a.adjustedScore; // Higher rating first
            }
            return distanceA - distanceB; // Closer distance first
          });

          // Get top 10 nearby experiences
          const topNearbyExperiences = nearbyExperiences.slice(0, 10);

          if (topNearbyExperiences.length === 0) {
            // No nearby experiences found
            const modalHtml = `
              <div id="nearby-modal" class="modal">
                <div class="modal-content" style="max-width: 600px;">
                  <button class="modal-close" onclick="closeNearbyModal()">&times;</button>
                  <div class="modal-header">
                    <h2><i class="fas fa-map-marker-alt"></i> Places Near You</h2>
                    <p style="margin: 0; color: #666;">Based on your current location</p>
                  </div>
                  <div class="modal-body">
                    <div style="text-align: center; padding: 3rem 1rem;">
                      <div style="font-size: 3rem; color: #ddd; margin-bottom: 1rem;">📍</div>
                      <h3 style="color: #666; margin-bottom: 0.5rem;">No Nearby Experiences Yet</h3>
                      <p style="color: #888; margin-bottom: 2rem;">
                        No places have been rated by the community within 50km of your location. 
                        Be the first to share experiences in your area!
                      </p>
                      <button class="btn" onclick="closeNearbyModal(); showPage('activities');">
                        <i class="fas fa-plus-circle"></i> Add Your First Experience
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            `;

            document.body.insertAdjacentHTML("beforeend", modalHtml);
            addModalListeners("nearby-modal", closeNearbyModal);
            NotificationSystem.show("No nearby experiences found. Be the first to share!", "info");
            return;
          }

          // Create a modal to show nearby recommendations
          const modalHtml = `
            <div id="nearby-modal" class="modal">
              <div class="modal-content" style="max-width: 600px;">
                <button class="modal-close" onclick="closeNearbyModal()">&times;</button>
                <div class="modal-header">
                  <h2><i class="fas fa-map-marker-alt"></i> Places Near You</h2>
                  <p style="margin: 0; color: #666;">Rated by friends and community within 50km</p>
                </div>
                <div class="modal-body">
                  <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
                    <p style="margin: 0; font-size: 0.9rem; color: #666;">
                      <i class="fas fa-info-circle"></i> 
                      Showing ${topNearbyExperiences.length} places rated by the community near your location.
                    </p>
                  </div>
                  
                  <div style="display: grid; gap: 1rem;">
                    ${topNearbyExperiences.map((exp, index) => {
            const distance = calculateDistance(lat, lng, exp.coordinates.lat, exp.coordinates.lng);
            const user = null; // Demo users removed - Firebase only
            const isFriend = friendIds.includes(exp.userId);
            const hasVisited = userExperiences.some(userExp =>
              userExp.name.toLowerCase() === exp.name.toLowerCase()
            );

            return `
                        <div style="border: 1px solid #eee; border-radius: 8px; padding: 1rem; background: white;">
                          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1;">
                              <div style="font-weight: bold; margin-bottom: 0.3rem; font-size: 1.1rem;">
                                ${exp.name} ${hasVisited ? '<span style="color: var(--primary-color);">✓ Visited</span>' : ''}
                              </div>
                              <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.5rem;">
                                ${exp.category} • ${exp.location} • ${distance.toFixed(1)}km away
                              </div>
                              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-size: 0.8rem;">
                                <div style="width: 20px; height: 20px; border-radius: 50%; background: var(--secondary-gradient); color: white; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: bold;">
                                  ${user ? user.avatar : '?'}
                                </div>
                                <span>${addCrownToPremiumUser(user ? user.displayName : 'Unknown', exp.userId)}</span>
                                ${isFriend ? '<span style="color: var(--primary-color);">★</span>' : ''}
                                <span style="color: #888;">• Rated ${exp.adjustedScore}/10</span>
                              </div>
                              ${exp.description ? `<p style="font-size: 0.9rem; color: #666; margin: 0.5rem 0; font-style: italic;">"${exp.description}"</p>` : ''}
                            </div>
                            <div style="text-align: right;">
                              <div style="font-weight: bold; color: ${exp.adjustedScore >= 7 ? '#4CAF50' : exp.adjustedScore >= 5 ? '#FF9800' : '#f44336'}; font-size: 1.2rem;">
                                ${exp.adjustedScore}/10
                              </div>
                            </div>
                          </div>
                          <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                            ${hasVisited ?
                `<span style="background: #e8f5e8; color: #2e7d32; font-size: 0.8rem; font-weight: bold; padding: 6px 12px; border-radius: 12px; border: 1px solid #4caf50; flex: 1; text-align: center;">
                                ✓ Already Rated
                              </span>` :
                `<button class="btn" style="font-size: 0.8rem; padding: 6px 12px; flex: 1;" 
                                      onclick="closeNearbyModal(); fillActivityForm('${exp.name}', '${exp.category}', '${exp.location}', 'Found through location-based search')">
                                Rate This Place
                              </button>`
              }
                            <button class="btn btn-secondary" style="font-size: 0.8rem; padding: 6px 12px;" 
                                    data-user-id="${exp.userId}" data-experience-name="${exp.name}" onclick="closeNearbyModal(); showExperienceDetailsFromButton(this);">
                              View Details
                            </button>
                          </div>
                        </div>
                      `;
          }).join('')}
                  </div>
                  
                  <div style="text-align: center; margin-top: 2rem;">
                    <button class="btn" onclick="closeNearbyModal(); showPage('activities');">
                      <i class="fas fa-plus-circle"></i> Add Your Own Experience
                    </button>
                  </div>
                </div>
              </div>
            </div>
          `;

          document.body.insertAdjacentHTML("beforeend", modalHtml);

          // Add ESC and click-outside functionality
          addModalListeners("nearby-modal", closeNearbyModal);

          NotificationSystem.show(`Found ${topNearbyExperiences.length} nearby places rated by the community!`, "success");
        })
        .catch((error) => {
          console.error('Location error:', error);
          // Add 1 second delay before showing error
          setTimeout(() => {
            // Only show error if location wasn't found
            if (!locationFound) {
              let message = 'Unable to get your location: ';
              if (error.code) {
                switch (error.code) {
                  case error.PERMISSION_DENIED:
                    message += 'Please allow location access to find nearby places.';
                    break;
                  case error.POSITION_UNAVAILABLE:
                    message += 'Location information is unavailable.';
                    break;
                  case error.TIMEOUT:
                    message += 'Location request timed out.';
                    break;
                  default:
                    message += 'An unknown error occurred.';
                    break;
                }
              } else {
                message += error.message || 'An unknown error occurred.';
              }
              NotificationSystem.show(message, "error");
            }
          }, 1000);
        });
    }

    function closeNearbyModal() {
      const modal = document.getElementById("nearby-modal");
      if (modal) {
        modal.remove();
        // Remove any remaining event listeners
        document.removeEventListener('keydown', (event) => {
          if (event.key === 'Escape') closeNearbyModal();
        });
      }
      // Re-enable body scrolling
      document.body.classList.remove('modal-open');
    }

    // Function to show detailed experience information
    function showExperienceDetails(userId, experienceName) {
      console.log('🔍 Looking for experience:', { userId, experienceName });

      // Find the experience in all experiences
      const allExperiences = ActivitySystem.getAllExperiences();
      console.log('🔍 All experiences:', allExperiences);

      // Try different matching strategies
      let experience = allExperiences.find(exp =>
        String(exp.userId) === String(userId) && exp.name === experienceName
      );

      // If not found, try partial name matching
      if (!experience) {
        experience = allExperiences.find(exp =>
          String(exp.userId) === String(userId) &&
          exp.name.toLowerCase().includes(experienceName.toLowerCase())
        );
      }

      // If still not found, try just by name
      if (!experience) {
        experience = allExperiences.find(exp =>
          exp.name === experienceName
        );
      }

      console.log('🔍 Found experience:', experience);

      if (!experience) {
        console.log('❌ Experience not found. Available experiences:', allExperiences.map(exp => ({ userId: exp.userId, name: exp.name })));
        NotificationSystem.show("Experience details not found.", "error");
        return;
      }

      const user = null; // Demo users removed - Firebase only
      const friends = FriendsSystem.getFriends();
      const isFriend = friends.some(friend => friend.id === userId);

      // Map the experience data to the expected format
      const mappedExperience = {
        ...experience,
        energyLevel: experience.responses?.energy || 0,
        socialSatisfaction: experience.responses?.social || 0,
        comfortLevel: experience.responses?.comfort || 0,
        overwhelmLevel: experience.responses?.overwhelm || 0,
        returnLikelihood: experience.responses?.return || 0
      };

      // Calculate confidence based on rating consistency
      const ratings = [
        mappedExperience.energyLevel,
        mappedExperience.socialSatisfaction,
        mappedExperience.comfortLevel,
        mappedExperience.overwhelmLevel,
        mappedExperience.returnLikelihood
      ];

      const averageRating = ratings.reduce((sum, rating) => sum + rating, 0) / ratings.length;
      const variance = ratings.reduce((sum, rating) => sum + Math.pow(rating - averageRating, 2), 0) / ratings.length;
      const confidence = Math.max(0.1, Math.min(1.0, 1 - (variance / 25))); // Higher variance = lower confidence

      mappedExperience.confidence = confidence;

      const modalHtml = `
        <div id="experience-details-modal" class="modal">
          <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeExperienceDetailsModal()">&times;</button>
            <div class="modal-header">
              <h2><i class="fas fa-star"></i> Experience Details</h2>
              <p style="margin: 0; color: #666;">Detailed rating and experience information</p>
            </div>
            <div class="modal-body">
              <!-- User Info Section -->
              <div style="background: rgba(74, 144, 226, 0.1); padding: 1rem; border-radius: 10px; margin-bottom: 1.5rem;">
                <div style="display: flex; align-items: center; gap: 1rem;">
                  <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--secondary-gradient); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                    ${user ? user.avatar : '?'}
                  </div>
                  <div>
                    <div style="font-weight: bold; font-size: 1.1rem;">
                      ${addCrownToPremiumUser(user ? user.displayName : 'Unknown', userId)}
                      
                    </div>
                    <div style="font-size: 0.9rem; color: #666;">
                      ${user ? user.personalityType : 'Unknown Type'} • ${new Date(mappedExperience.timestamp).toLocaleDateString()}
                    </div>
                  </div>
                </div>
              </div>

              <!-- Experience Basic Info -->
              <div style="background: white; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; border: 1px solid #eee;">
                <h3 style="margin: 0 0 1rem 0; color: var(--primary-color);">${mappedExperience.name}</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                  <div>
                    <strong>Category:</strong> ${mappedExperience.category}
                  </div>
                  <div>
                    <strong>Location:</strong> ${mappedExperience.location}
                  </div>
                  <div>
                    <strong>Overall Rating:</strong> 
                    <span style="font-weight: bold; color: ${mappedExperience.adjustedScore >= 7 ? '#4CAF50' : mappedExperience.adjustedScore >= 5 ? '#FF9800' : '#f44336'};">
                      ${mappedExperience.adjustedScore}/10
                    </span>
                  </div>
                  <div>
                    <strong>Confidence:</strong> ${(mappedExperience.confidence * 100).toFixed(0)}%
                  </div>
                </div>
                ${mappedExperience.description ? `
                  <div style="margin-top: 1rem; padding: 1rem; background: rgba(74, 144, 226, 0.05); border-radius: 8px;">
                    <strong>Description:</strong>
                    <p style="margin: 0.5rem 0 0 0; font-style: italic; color: #666;">"${mappedExperience.description}"</p>
                  </div>
                ` : ''}
              </div>

              <!-- Detailed Rating Breakdown -->
              <div style="background: white; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; border: 1px solid #eee;">
                <h4 style="margin: 0 0 1rem 0; color: var(--primary-color);">
                  <i class="fas fa-chart-bar"></i> Detailed Rating Breakdown
                </h4>
                
                <div style="display: grid; gap: 1rem;">
                  <!-- Energy Level -->
                  <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <strong>Energy Level:</strong>
                      <span style="font-weight: bold; color: ${mappedExperience.energyLevel >= 7 ? '#4CAF50' : mappedExperience.energyLevel >= 5 ? '#FF9800' : '#f44336'};">
                        ${mappedExperience.energyLevel}/10
                      </span>
                    </div>
                    <div style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                      <div style="background: var(--secondary-gradient); height: 100%; width: ${mappedExperience.energyLevel * 10}%;"></div>
                    </div>
                  </div>

                  <!-- Social Satisfaction -->
                  <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <strong>Social Satisfaction:</strong>
                      <span style="font-weight: bold; color: ${mappedExperience.socialSatisfaction >= 7 ? '#4CAF50' : mappedExperience.socialSatisfaction >= 5 ? '#FF9800' : '#f44336'};">
                        ${mappedExperience.socialSatisfaction}/10
                      </span>
                    </div>
                    <div style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                      <div style="background: var(--secondary-gradient); height: 100%; width: ${mappedExperience.socialSatisfaction * 10}%;"></div>
                    </div>
                  </div>

                  <!-- Comfort Level -->
                  <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <strong>Comfort Level:</strong>
                      <span style="font-weight: bold; color: ${mappedExperience.comfortLevel >= 7 ? '#4CAF50' : mappedExperience.comfortLevel >= 5 ? '#FF9800' : '#f44336'};">
                        ${mappedExperience.comfortLevel}/10
                      </span>
                    </div>
                    <div style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                      <div style="background: var(--secondary-gradient); height: 100%; width: ${mappedExperience.comfortLevel * 10}%;"></div>
                    </div>
                  </div>

                  <!-- Overwhelm Level -->
                  <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <strong>Overwhelm Level:</strong>
                      <span style="font-weight: bold; color: ${mappedExperience.overwhelmLevel >= 7 ? '#f44336' : mappedExperience.overwhelmLevel >= 5 ? '#FF9800' : '#4CAF50'};">
                        ${mappedExperience.overwhelmLevel}/10
                      </span>
                    </div>
                    <div style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                      <div style="background: var(--secondary-gradient); height: 100%; width: ${mappedExperience.overwhelmLevel * 10}%;"></div>
                    </div>
                  </div>

                  <!-- Return Likelihood -->
                  <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <strong>Return Likelihood:</strong>
                      <span style="font-weight: bold; color: ${mappedExperience.returnLikelihood >= 7 ? '#4CAF50' : mappedExperience.returnLikelihood >= 5 ? '#FF9800' : '#f44336'};">
                        ${mappedExperience.returnLikelihood}/10
                      </span>
                    </div>
                    <div style="background: #f0f0f0; height: 8px; border-radius: 4px; overflow: hidden;">
                      <div style="background: var(--secondary-gradient); height: 100%; width: ${mappedExperience.returnLikelihood * 10}%;"></div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Environment Metrics -->
              <div style="background: white; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; border: 1px solid #eee;">
                <h4 style="margin: 0 0 1rem 0; color: var(--primary-color);">
                  <i class="fas fa-users"></i> Environment Metrics
                </h4>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                  <div>
                    <strong>Social Intensity:</strong> ${mappedExperience.socialIntensity.toFixed(1)}/10
                  </div>
                  <div>
                    <strong>Noise Level:</strong> ${mappedExperience.noiseLevel.toFixed(1)}/10
                  </div>
                  <div>
                    <strong>Crowd Size:</strong> ${mappedExperience.crowdSize.toFixed(1)}/10
                  </div>
                  <div>
                    <strong>Activity Type:</strong> ${mappedExperience.activityType || 'Not specified'}
                  </div>
                </div>
              </div>

              <!-- Personality Adjustment -->
              <div style="background: white; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; border: 1px solid #eee;">
                <h4 style="margin: 0 0 1rem 0; color: var(--primary-color);">
                  <i class="fas fa-brain"></i> Personality Adjustment
                </h4>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                  <div>
                    <strong>Raw Score:</strong> ${mappedExperience.rawScore.toFixed(1)}/10
                  </div>
                  <div>
                    <strong>Adjustment Factor:</strong> ${user ? user.adjustmentFactor.toFixed(2) : 'Unknown'}
                  </div>
                  <div>
                    <strong>Personality Type:</strong> ${user ? user.personalityType : 'Unknown'}
                  </div>
                  <div>
                    <strong>Adjusted Score:</strong> 
                    <span style="font-weight: bold; color: ${mappedExperience.adjustedScore >= 7 ? '#4CAF50' : mappedExperience.adjustedScore >= 5 ? '#FF9800' : '#f44336'};">
                      ${mappedExperience.adjustedScore}/10
                    </span>
                  </div>
                </div>
              </div>

              <!-- Action Buttons -->
              <div style="text-align: center; margin-top: 2rem;">
                <button class="btn" onclick="closeExperienceDetailsModal(); fillActivityForm('${mappedExperience.name}', '${mappedExperience.category}', '${mappedExperience.location}', 'Found through experience details')">
                  <i class="fas fa-star"></i> Rate This Place Too
                </button>
                <button class="btn btn-secondary" onclick="closeExperienceDetailsModal();">
                  <i class="fas fa-times"></i> Close
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);
      addModalListeners("experience-details-modal", closeExperienceDetailsModal);
    }

    function closeExperienceDetailsModal() {
      const modal = document.getElementById("experience-details-modal");
      if (modal) {
        modal.remove();
      }
      document.body.classList.remove('modal-open');
    }

    // Helper function to get experience details from button data attributes
    function showExperienceDetailsFromButton(button) {
      const userId = button.getAttribute('data-user-id');
      const experienceName = button.getAttribute('data-experience-name');
      showExperienceDetails(userId, experienceName);
    }

    // Function to use current location
    function useCurrentLocation() {
      locationFound = false; // Reset flag at start
      const locationInput = document.getElementById("activity-location");
      const useLocationBtn = document.getElementById("use-current-location-btn");

      if (!locationInput || !useLocationBtn) return;

      // Show loading state
      useLocationBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Getting Location...';
      useLocationBtn.disabled = true;

      getUserLocationWithFallback()
        .then((position) => {
          locationFound = true; // Set flag when location is found
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          // Use the reverse geocoding function
          reverseGeocodeAndFillLocation(lat, lng);

          // Reset button
          useLocationBtn.innerHTML = '<i class="fas fa-crosshairs"></i> Use Current Location';
          useLocationBtn.disabled = false;
        })
        .catch((error) => {
          console.error('Error getting location:', error);
          // Add 1 second delay before showing error
          setTimeout(() => {
            // Only show error if location wasn't found
            if (!locationFound) {
              let message = 'Unable to get your location: ';
              if (error.code) {
                switch (error.code) {
                  case error.PERMISSION_DENIED:
                    message += 'Please allow location access in your browser settings.';
                    break;
                  case error.POSITION_UNAVAILABLE:
                    message += 'Location information is unavailable.';
                    break;
                  case error.TIMEOUT:
                    message += 'Location request timed out.';
                    break;
                  default:
                    message += 'An unknown error occurred.';
                    break;
                }
              } else {
                message += error.message || 'An unknown error occurred.';
              }

              NotificationSystem.show(message, "error");
              locationInput.value = "";
            }
          }, 1000);

          // Reset button
          useLocationBtn.innerHTML = '<i class="fas fa-crosshairs"></i> Use Current Location';
          useLocationBtn.disabled = false;
        });
    }

    function autoFillCurrentLocation() {
      locationFound = false; // Reset flag at start
      const locationInput = document.getElementById("activity-location");

      if (!locationInput) return;

      // Only auto-fill if the input is empty (don't override user input)
      if (locationInput.value.trim() !== '') return;

      console.log("Auto-filling current location...");

      getUserLocationWithFallback()
        .then((position) => {
          locationFound = true; // Set flag when location is found
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          console.log("Auto-filled location coordinates:", lat, lng);

          // Use the reverse geocoding function to fill the location
          reverseGeocodeAndFillLocation(lat, lng);

          // Show a subtle notification
          NotificationSystem.show("Location auto-detected!", "success");
        })
        .catch((error) => {
          console.log("Could not auto-detect location:", error.message);
          // Silently fail for auto-fill (don't show error notification)
        });
    }

    // Notification system
    // Global variable to track if location was successfully found
    let locationFound = false;
    // Helper function to get user location (with demo user fallback)
    async function getUserLocationWithFallback() {
      const currentUser = DataLayer.load("currentUser");
      console.log('📍 Current user for location:', currentUser);

      // Demo users removed - Firebase only

      // If current user has a saved location, use that
      if (currentUser && currentUser.location) {
        console.log(`📍 Using saved location for ${currentUser.displayName}:`, currentUser.location);
        return {
          coords: {
            latitude: currentUser.location.lat,
            longitude: currentUser.location.lng
          }
        };
      }

      // Check if we're in a demo environment (no real user)
      if (!currentUser || !currentUser.id) {
        console.log(`📍 No current user found, using default Waterloo location`);
        return {
          coords: {
            latitude: 43.4643, // Waterloo University District
            longitude: -80.5204
          }
        };
      }

      // Otherwise, try to get real location
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error("Geolocation is not supported by this browser."));
          return;
        }

        // Check if location permission is denied
        if (navigator.permissions) {
          navigator.permissions.query({ name: 'geolocation' }).then(permission => {
            if (permission.state === 'denied') {
              reject(new Error("Location permission denied. Please enable location access in your browser settings."));
              return;
            }

            // Permission is granted or prompt, proceed with location request
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            });
          }).catch(() => {
            // Fallback if permissions API is not available
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            });
          });
        } else {
          // Fallback if permissions API is not available
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
          });
        }
      });
    }

    const NotificationSystem = {
      show: (message, type = "info", duration = 3000, onClick = null) => {
        // Remove any existing notifications first
        const existingNotifications = document.querySelectorAll('[style*="position: fixed"][style*="bottom: 20px"][style*="right: 20px"]');
        existingNotifications.forEach(notification => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        });

        const notification = document.createElement("div");
        notification.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 16px 20px;
      border-radius: 12px;
      color: #374151;
      font-size: 14px;
      font-weight: 500;
      z-index: 10000;
      transform: translateX(100%);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      max-width: 350px;
      min-width: 280px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: flex-start;
      gap: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    `;

        // Set background and icon based on type
        let icon;
        let bgColor = "var(--background-alt-color)"

        switch (type) {
          case "success":
            notification.style.borderLeft = "4px solid #10b981";
            icon = `<svg width="20" height="20" fill="var(--success-color)" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
        </svg>`;
            break;
          case "error":
            notification.style.borderLeft = "4px solid var(--error-color)";
            icon = `<svg width="20" height="20" fill="#ef4444" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
        </svg>`;
            break;
          case "warning":
            notification.style.borderLeft = "4px solid var(--warning-color)";
            icon = `<svg width="20" height="20" fill="#f59e0b" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
        </svg>`;
            break;
          default:
            notification.style.borderLeft = "4px solid #3b82f6";
            icon = `<svg width="20" height="20" fill="var(--info-color)" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M11 6a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
        </svg>`;
        }

        notification.style.backgroundColor = bgColor;

        // Create icon element
        const iconEl = document.createElement("div");
        iconEl.innerHTML = icon;
        iconEl.style.cssText = `
      flex-shrink: 0;
      margin-top: 1px;
    `;

        // Create content container
        const contentEl = document.createElement("div");
        contentEl.style.cssText = `
      flex: 1;
      line-height: 1.5;
    `;

        // Create message element
        const messageEl = document.createElement("div");
        messageEl.innerHTML = message;
        messageEl.style.cssText = `
      color: var(--primary-color);
      font-weight: 500;
    `;

        // Create close button
        const closeBtn = document.createElement("button");
        closeBtn.innerHTML = `<svg width="16" height="16" fill="var(--muted-text-color)" viewBox="0 0 20 20">
      <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
    </svg>`;
        closeBtn.style.cssText = `
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      margin: -4px -4px -4px 4px;
      border-radius: 6px;
      transition: all 0.2s ease;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      
    `;

        // Add hover effect to close button
        closeBtn.addEventListener("mouseenter", () => {
          closeBtn.style.backgroundColor = "#f3f4f6";
          closeBtn.querySelector('svg').setAttribute('fill', '#6b7280');
        });
        closeBtn.addEventListener("mouseleave", () => {
          closeBtn.style.backgroundColor = "transparent";
          closeBtn.querySelector('svg').setAttribute('fill', '#9ca3af');
        });

        // Function to remove notification
        const removeNotification = () => {
          notification.style.transform = "translateX(100%)";
          notification.style.opacity = "0";
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        };

        // Close button click handler
        closeBtn.addEventListener("click", removeNotification);

        // Add click handler if provided
        if (onClick) {
          notification.style.cursor = 'pointer';
          notification.addEventListener('click', (e) => {
            // Don't trigger if clicking the close button
            if (e.target === closeBtn || closeBtn.contains(e.target)) {
              return;
            }
            onClick();
            removeNotification();
          });
        }

        // Append elements
        contentEl.appendChild(messageEl);
        notification.appendChild(iconEl);
        notification.appendChild(contentEl);
        notification.appendChild(closeBtn);
        document.body.appendChild(notification);

        // Animate in
        requestAnimationFrame(() => {
          notification.style.transform = "translateX(0)";
          notification.style.opacity = "1";
        });

        // Auto-remove after duration
        const autoRemoveTimer = setTimeout(removeNotification, duration);

        // Clear timer if manually closed
        closeBtn.addEventListener("click", () => {
          clearTimeout(autoRemoveTimer);
        });

        // Add pause on hover
        notification.addEventListener("mouseenter", () => {
          clearTimeout(autoRemoveTimer);
        });

        notification.addEventListener("mouseleave", () => {
          setTimeout(removeNotification, 1000); // Give 1 second after mouse leave
        });
      },
    };
    // Function to reverse geocode coordinates and fill location field
    function reverseGeocodeAndFillLocation(lat, lng) {
      const locationInput = document.getElementById("activity-location");
      if (!locationInput) return;

      // Show loading state
      locationInput.value = "Getting your location...";
      locationInput.disabled = true;

      // Use OpenStreetMap Nominatim for reverse geocoding (free service)
      fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16`)
        .then(response => response.json())
        .then(data => {
          if (data.display_name) {
            // Extract city/area name from the full address
            const addressParts = data.display_name.split(', ');
            let locationName = addressParts[0]; // Start with the most specific part

            // Try to find a more meaningful location name
            if (addressParts.length > 1) {
              // Look for city, town, or district
              for (let i = 1; i < Math.min(4, addressParts.length); i++) {
                const part = addressParts[i];
                if (part.includes('City') || part.includes('Town') || part.includes('District') ||
                  part.includes('Neighborhood') || part.includes('Area')) {
                  locationName = part;
                  break;
                }
              }
            }

            locationInput.value = locationName;
            NotificationSystem.show(
              `Location detected: ${locationName}`,
              "success"
            );
          } else {
            locationInput.value = "Location detected (coordinates)";
          }
        })
        .catch(error => {
          console.error('Error reverse geocoding:', error);
          // Add 1 second delay before showing any error notification
          setTimeout(() => {
            // Could show error notification here if needed
          }, 1000);
          locationInput.value = "Location detected (coordinates)";
        })
        .finally(() => {
          locationInput.disabled = false;
        });
    }

    // Location autocomplete functionality
    function initializeLocationAutocomplete() {
      // Function to get user's current location
      function getCurrentLocation() {
        locationFound = false; // Reset flag at start
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            reject(new Error('Geolocation is not supported by this browser.'));
            return;
          }

          navigator.geolocation.getCurrentPosition(
            (position) => {
              locationFound = true; // Set flag when location is found
              resolve({
                lat: position.coords.latitude,
                lng: position.coords.longitude
              });
            },
            (error) => {
              // Add 1 second delay before rejecting
              setTimeout(() => {
                // Only show error if location wasn't found
                if (!locationFound) {
                  let message = 'Unable to retrieve location: ';
                  switch (error.code) {
                    case error.PERMISSION_DENIED:
                      message += 'User denied the request for Geolocation.';
                      break;
                    case error.POSITION_UNAVAILABLE:
                      message += 'Location information is unavailable.';
                      break;
                    case error.TIMEOUT:
                      message += 'The request to get user location timed out.';
                      break;
                    default:
                      message += 'An unknown error occurred.';
                      break;
                  }
                  reject(new Error(message));
                }
              }, 1000);
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            }
          );
        });
      }

      // Function to reverse geocode coordinates to address
      function reverseGeocode(lat, lng) {
        if (typeof google !== "undefined" && google.maps && google.maps.Geocoder) {
          const geocoder = new google.maps.Geocoder();
          return new Promise((resolve, reject) => {
            geocoder.geocode(
              { location: { lat: lat, lng: lng } },
              (results, status) => {
                if (status === 'OK' && results[0]) {
                  resolve(results[0].formatted_address);
                } else {
                  reject(new Error('Geocoder failed: ' + status));
                }
              }
            );
          });
        } else {
          // Fallback using a free geocoding service (OpenStreetMap Nominatim)
          return fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`)
            .then(response => response.json())
            .then(data => {
              if (data.display_name) {
                return data.display_name;
              } else {
                throw new Error('Unable to reverse geocode location');
              }
            });
        }
      }

      // Check if Google Maps API is available
      if (typeof google !== "undefined" && google.maps && google.maps.places) {
        const locationInput = document.getElementById("activity-location");
        if (locationInput) {
          // Set up autocomplete with bias towards user's location
          getCurrentLocation().then(userLocation => {
            const autocomplete = new google.maps.places.Autocomplete(
              locationInput,
              {
                types: ["establishment", "geocode"],
                fields: ["name", "formatted_address", "place_id"],
              }
            );

            // Bias results towards user's current location
            const circle = new google.maps.Circle({
              center: userLocation,
              radius: 50000 // 50km radius
            });
            autocomplete.setBounds(circle.getBounds());

            autocomplete.addListener("place_changed", () => {
              const place = autocomplete.getPlace();
              if (place.formatted_address) {
                locationInput.value = place.formatted_address;
              }
            });

            // Add a button or option to use current location
            const useCurrentLocationBtn = document.createElement("button");
            useCurrentLocationBtn.type = "button";
            useCurrentLocationBtn.textContent = "Use Current Location";
            useCurrentLocationBtn.style.cssText = `
          margin-left: 8px;
          padding: 8px 12px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
        `;

            useCurrentLocationBtn.addEventListener("click", async () => {
              try {
                useCurrentLocationBtn.textContent = "Getting location...";
                useCurrentLocationBtn.disabled = true;

                const location = await getCurrentLocation();
                const address = await reverseGeocode(location.lat, location.lng);
                locationInput.value = address;

                useCurrentLocationBtn.textContent = "Use Current Location";
                useCurrentLocationBtn.disabled = false;
              } catch (error) {
                console.error('Error getting current location:', error);
                alert(error.message);
                useCurrentLocationBtn.textContent = "Use Current Location";
                useCurrentLocationBtn.disabled = false;
              }
            });

            // Insert button after the input field
            locationInput.parentNode.insertBefore(useCurrentLocationBtn, locationInput.nextSibling);

          }).catch(error => {
            console.warn('Could not get user location for autocomplete bias:', error);

            // Set up autocomplete without location bias
            const autocomplete = new google.maps.places.Autocomplete(
              locationInput,
              {
                types: ["establishment", "geocode"],
                fields: ["name", "formatted_address", "place_id"],
              }
            );

            autocomplete.addListener("place_changed", () => {
              const place = autocomplete.getPlace();
              if (place.formatted_address) {
                locationInput.value = place.formatted_address;
              }
            });
          });
        }
      } else {
        // Fallback: Simple location suggestions with current location option
        const locationInput = document.getElementById("activity-location");
        if (locationInput) {
          const commonLocations = [
            "Use Current Location",
            "Downtown",
            "City Center",
            "University District",
            "Arts District",
            "Entertainment District",
            "Shopping District",
            "Financial District",
            "Old Town",
            "Midtown",
            "Uptown",
            "Suburbs",
            "Waterfront",
            "North Side",
            "South Side",
            "East Side",
            "West Side",
          ];

          locationInput.addEventListener("input", (e) => {
            const value = e.target.value.toLowerCase();
            if (value.length > 0) {
              const matches = commonLocations.filter((loc) =>
                loc.toLowerCase().includes(value)
              );

              // Create simple dropdown (basic implementation)
              let dropdown = document.getElementById("location-dropdown");
              if (dropdown) dropdown.remove();

              if (matches.length > 0 && matches.length < commonLocations.length) {
                dropdown = document.createElement("div");
                dropdown.id = "location-dropdown";
                dropdown.style.cssText = `
              position: absolute;
              top: 100%;
              left: 0;
              right: 0;
              background: white;
              border: 1px solid #ddd;
              border-top: none;
              border-radius: 0 0 8px 8px;
              max-height: 200px;
              overflow-y: auto;
              z-index: 1000;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            `;

                matches.slice(0, 5).forEach((match) => {
                  const option = document.createElement("div");
                  option.style.cssText = `
                padding: 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
              `;
                  option.textContent = match;
                  option.addEventListener("mouseenter", () => {
                    option.style.background = "#f5f5f5";
                  });
                  option.addEventListener("mouseleave", () => {
                    option.style.background = "white";
                  });
                  option.addEventListener("click", async () => {
                    if (match === "Use Current Location") {
                      try {
                        option.textContent = "Getting location...";
                        const location = await getCurrentLocation();
                        const address = await reverseGeocode(location.lat, location.lng);
                        locationInput.value = address;
                      } catch (error) {
                        console.error('Error getting current location:', error);
                        alert(error.message);
                        locationInput.value = "";
                      }
                    } else {
                      locationInput.value = match;
                    }
                    dropdown.remove();
                  });
                  dropdown.appendChild(option);
                });

                locationInput.parentNode.style.position = "relative";
                locationInput.parentNode.appendChild(dropdown);
              }
            }
          });

          // Close dropdown when clicking outside
          document.addEventListener("click", (e) => {
            const dropdown = document.getElementById("location-dropdown");
            if (
              dropdown &&
              !locationInput.contains(e.target) &&
              !dropdown.contains(e.target)
            ) {
              dropdown.remove();
            }
          });
        }
      }
    }
    // Initialize app
    document.addEventListener("DOMContentLoaded", () => {
      // Demo experiences removed - Firebase only

      // Start with login page - Firebase auth will redirect if user is signed in
      showPage("login");
    });

    // Keyboard shortcuts for power users
    document.addEventListener("keydown", (event) => {
      // Escape to close modals
      if (event.key === "Escape") {
        // Check for experiences modals first
        const experiencesModal = document.getElementById("experiences-modal");
        const editExperienceModal = document.getElementById("edit-experience-modal");

        if (editExperienceModal) {
          closeEditExperienceModal();
        } else if (experiencesModal) {
          closeExperiencesModal();
        } else {
          // Check for AI modals and close them using their specific functions
          const aiPremiumModal = document.getElementById("ai-premium-modal");
          const aiAssistantModal = document.getElementById("ai-assistant-modal");
          const aiEditModal = document.getElementById("ai-edit-modal");

          if (aiPremiumModal) {
            closeAIPremiumModal();
          } else if (aiAssistantModal) {
            closeAIAssistantModal();
          } else if (aiEditModal) {
            // If there's a closeAIEditModal function, call it
            if (typeof closeAIEditModal === 'function') {
              closeAIEditModal();
            } else {
              aiEditModal.remove();
            }
          }

          // Also try the generic closeModal function as fallback
          if (typeof closeModal === 'function') {
            closeModal();
          }
        }
      }

      // Enter key to click appropriate buttons based on current page
      if (event.key === "Enter") {
        // Check which page is currently visible
        const allPages = document.querySelectorAll('.page');
        let currentPage = null;

        allPages.forEach(page => {
          if (!page.classList.contains("hidden")) {
            currentPage = page.id;
          }
        });

        // Handle different pages
        if (currentPage === "dashboard") {
          // Look for "Start Assessment" button on dashboard
          const startAssessmentBtn = document.querySelector('button[onclick="showPage(\'assessment\')"]');
          if (startAssessmentBtn && startAssessmentBtn.offsetParent !== null) {
            startAssessmentBtn.click();
          }
        } else if (currentPage === "profile") {
          // Look for "Take Assessment" button on profile
          const takeAssessmentBtn = document.querySelector('button[onclick="showPage(\'assessment\')"]');
          console.log('Profile page - Found assessment button:', takeAssessmentBtn);
          console.log('Button visible:', takeAssessmentBtn && takeAssessmentBtn.offsetParent !== null);

          if (takeAssessmentBtn && takeAssessmentBtn.offsetParent !== null) {
            takeAssessmentBtn.click();
          } else {
            // Fallback: look for any button with "Take Assessment" text
            const allButtons = document.querySelectorAll('button');
            const assessmentBtn = Array.from(allButtons).find(btn =>
              btn.textContent.includes('Take Assessment') && btn.offsetParent !== null
            );
            console.log('Fallback - Found assessment button:', assessmentBtn);
            if (assessmentBtn) {
              assessmentBtn.click();
            }
          }
        } else if (currentPage === "results") {
          // Look for "Continue to Dashboard" button on results page
          const continueBtn = document.querySelector('button[onclick="completeAssessment()"]');
          if (continueBtn && continueBtn.offsetParent !== null) {
            continueBtn.click();
          }
        }
      }
    });

    // Enhanced activity submission with notifications
    const EnhancedActivitySystem = {
      submitWithNotification: (event) => {
        try {
          ActivitySystem.submitNewExperience(event);
          NotificationSystem.show(
            "Experience added successfully!",
            "success"
          );
        } catch (error) {
          console.error("Failed to submit experience:", error);
          NotificationSystem.show(
            "Failed to add experience. Please try again.",
            "error"
          );
        }
      },
    };

    // Error handling wrapper
    function safeExecute(fn, errorMessage = "An error occurred") {
      try {
        return fn();
      } catch (error) {
        console.error(errorMessage, error);
        NotificationSystem.show(
          errorMessage + ". Please try again.",
          "error"
        );
        return null;
      }
    }

    // Data export functionality (for demo purposes)
    function exportUserData() {
      const userData = {
        personality: DataLayer.load("personalityScore"),
        personalityType: DataLayer.load("personalityType"),
        experiences: DataLayer.load("userExperiences", []),
        groups: DataLayer.load("groups", []),
        friends: DataLayer.load("friends", []),
        exportDate: new Date().toISOString(),
      };

      const dataStr = JSON.stringify(userData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });

      const link = document.createElement("a");
      link.href = URL.createObjectURL(dataBlob);
      link.download = "social-energy-data.json";
      link.click();
    }

    // Firebase Authentication System
    let authManager = null;
    let userManager = null;
    let friendsManager = null;
    let currentFirebaseUser = null;

    // Initialize Firebase Authentication
    async function initializeFirebaseAuth() {
      try {
        // Import Firebase modules
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
        const { getAuth, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        const { getFirestore } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        // Import Firebase configuration
        const { firebaseConfig } = await import('./firebase-config.js');

        // Check if Firebase is properly configured
        if (!firebaseConfig.apiKey) {
          console.warn('Firebase not configured. Please update firebase-config.js with your Firebase project details.');
          NotificationSystem.show('Firebase not configured. Please check the console for setup instructions.', 'warning');
          return false;
        }

        console.log('Firebase config loaded:', {
          projectId: firebaseConfig.projectId,
          authDomain: firebaseConfig.authDomain,
          hasApiKey: !!firebaseConfig.apiKey
        });

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Set up auth state listener
        onAuthStateChanged(auth, async (user) => {
          if (user) {
            currentFirebaseUser = user;
            console.log('User signed in:', user.uid);
            await loadUserProfile(user.uid);
            // Removed legacy handler system; activity tracking handles presence
            setupActivityTracking(); // Start tracking user activity
            showPage('dashboard');
            updateNavigationVisibility();
          } else {
            currentFirebaseUser = null;
            console.log('User signed out');
            showPage('login');
            updateNavigationVisibility();
          }
        });

        // Initialize managers
        authManager = { auth, db };
        userManager = { db };
        friendsManager = { db };


        console.log('Firebase Auth initialized successfully');
        return true;
      } catch (error) {
        console.error('Error initializing Firebase Auth:', error);
        NotificationSystem.show('Failed to initialize Firebase. Please check your configuration.', 'error');
        return false;
      }
    }

    // Handle user login
    async function handleLogin(event) {
      event.preventDefault();

      const email = document.getElementById('login-email').value.trim();
      const password = document.getElementById('login-password').value;

      if (!email) {
        NotificationSystem.show('Please enter your email address.', 'warning');
        return;
      }

      if (!isValidEmail(email)) {
        NotificationSystem.show('Please enter a valid email address.', 'warning');
        return;
      }

      if (!password) {
        NotificationSystem.show('Please enter your password.', 'warning');
        return;
      }

      try {
        // Wait for Firebase to be initialized
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        const { signInWithEmailAndPassword } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        await signInWithEmailAndPassword(authManager.auth, email, password);
        NotificationSystem.show('Successfully signed in!', 'success');
      } catch (error) {
        console.error('Login error:', error);
        let message = 'Login failed. ';
        switch (error.code) {
          case 'auth/user-not-found':
            message += 'No account found with this email.';
            break;
          case 'auth/wrong-password':
            message += 'Incorrect password.';
            break;
          case 'auth/invalid-email':
            message += 'Invalid email address.';
            break;
          case 'auth/too-many-requests':
            message += 'Too many failed attempts. Please try again later.';
            break;
          case 'auth/user-disabled':
            message += 'This account has been disabled.';
            break;
          default:
            message += error.message;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    // Cursor-style login flow functions
    window.handleEmailContinue = async function () {
      const email = document.getElementById('login-email').value.trim();

      if (!email) {
        NotificationSystem.show('Please enter your email address.', 'warning');
        return;
      }

      if (!isValidEmail(email)) {
        NotificationSystem.show('Please enter a valid email address.', 'warning');
        return;
      }

      // Store email for password step
      window.loginEmail = email;

      // Show email in step 2
      document.getElementById('login-email-display').textContent = email;

      // Hide step 1, show step 2
      document.getElementById('login-step-1').style.display = 'none';
      document.getElementById('login-step-2').style.display = 'block';

      // Focus on password input
      setTimeout(() => {
        document.getElementById('login-password').focus();
      }, 100);
    }

    window.handlePasswordContinue = async function () {
      const password = document.getElementById('login-password').value;

      if (!password) {
        NotificationSystem.show('Please enter your password.', 'warning');
        return;
      }

      try {
        // Wait for Firebase to be initialized
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        const { signInWithEmailAndPassword } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        await signInWithEmailAndPassword(authManager.auth, window.loginEmail, password);
        NotificationSystem.show('Successfully signed in!', 'success');
      } catch (error) {
        console.error('Login error:', error);
        let message = 'Login failed. ';
        switch (error.code) {
          case 'auth/user-not-found':
            message += 'No account found with this email.';
            break;
          case 'auth/wrong-password':
            message += 'Incorrect password.';
            break;
          case 'auth/invalid-email':
            message += 'Invalid email address.';
            break;
          default:
            message += error.message;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    window.backToEmailStep = function () {
      document.getElementById('login-step-2').style.display = 'none';
      document.getElementById('login-step-1').style.display = 'block';
      document.getElementById('login-password').value = '';
    }

    window.togglePasswordVisibility = function (inputId) {
      const input = document.getElementById(inputId);
      const toggle = input.parentElement.querySelector('.password-toggle-btn i');

      if (input.type === 'password') {
        input.type = 'text';
        toggle.className = 'fas fa-eye-slash';
      } else {
        input.type = 'password';
        toggle.className = 'fas fa-eye';
      }
    }

    function isValidEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }



    window.handleGitHubSignIn = async function () {
      try {
        // Wait for Firebase to be initialized
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        const { GithubAuthProvider, signInWithPopup } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        const { doc, setDoc, getDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        const provider = new GithubAuthProvider();
        const result = await signInWithPopup(authManager.auth, provider);
        const user = result.user;

        // Check if this is a new user
        const userDoc = await wrapRead(getDoc(doc(authManager.db, 'users', user.uid)), 'getDoc', `users/${user.uid}`, {});

        if (!userDoc.exists()) {
          // Create new user profile
          const userData = {
            id: user.uid,
            username: user.email.split('@')[0], // Use email prefix as username
            displayName: user.displayName || user.email.split('@')[0],
            email: user.email,
            bio: '',
            avatar: user.displayName ? user.displayName.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase(),
            adjustmentFactor: 0, // Default neutral
            personalityType: 'Neutral',
            isPremium: false,
            location: null,
            isOnline: true,
            lastSeen: serverTimestamp(),
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          };

          await wrapWrite(
            setDoc(doc(authManager.db, 'users', user.uid), userData),
            'setDoc',
            `users/${user.uid}`,
            { created: true }
          );
          NotificationSystem.show('Account created successfully!', 'success');
        }

      } catch (error) {
        console.error('GitHub sign-in error:', error);
        let message = 'GitHub sign-in failed. ';
        switch (error.code) {
          case 'auth/popup-closed-by-user':
            message = 'Sign-in was cancelled.';
            break;
          case 'auth/popup-blocked':
            message = 'Sign-in popup was blocked. Please allow popups for this site.';
            break;
          default:
            message += error.message;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    // Handle Google Sign In
    window.handleGoogleSignIn = async function () {
      try {
        // Wait for Firebase to be initialized
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        const { GoogleAuthProvider, signInWithPopup } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        const { doc, setDoc, getDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        const provider = new GoogleAuthProvider();
        const result = await signInWithPopup(authManager.auth, provider);
        const user = result.user;

        // Check if this is a new user
        const userDoc = await wrapRead(getDoc(doc(authManager.db, 'users', user.uid)), 'getDoc', `users/${user.uid}`, {});

        if (!userDoc.exists()) {
          // Create new user profile
          const userData = {
            id: user.uid,
            username: user.email.split('@')[0], // Use email prefix as username
            displayName: user.displayName || user.email.split('@')[0],
            email: user.email,
            bio: '',
            avatar: user.displayName ? user.displayName.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase(),
            adjustmentFactor: 0, // Default neutral
            personalityType: 'Neutral',
            isPremium: false,
            location: null,
            isOnline: true,
            lastSeen: serverTimestamp(),
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          };

          await wrapWrite(
            setDoc(doc(authManager.db, 'users', user.uid), userData),
            'setDoc',
            `users/${user.uid}`,
            { created: true }
          );
          NotificationSystem.show('Account created successfully!', 'success');
        }

      } catch (error) {
        console.error('Google sign-in error:', error);
        let message = 'Google sign-in failed. ';
        switch (error.code) {
          case 'auth/popup-closed-by-user':
            message = 'Sign-in was cancelled.';
            break;
          case 'auth/popup-blocked':
            message = 'Sign-in popup was blocked. Please allow popups for this site.';
            break;
          default:
            message += error.message;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    // Handle user logout
    window.handleLogout = async function () {
      try {
        // Cleanup real-time listeners before logout
        cleanupRealtimeListeners();



        if (authManager && authManager.auth) {
          const { signOut } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
          await signOut(authManager.auth);
          NotificationSystem.show('Successfully signed out!', 'success');
        }
      } catch (error) {
        console.error('Logout error:', error);
        NotificationSystem.show('Error signing out. Please try again.', 'error');
      }
    }

    // Online status tracking variables
    let activityTimeout = null;
    let isUserActive = true;
    let lastActivityTime = Date.now();
    let isUpdatingStatus = false; // Prevent status update loops

    // Track user activity
    function trackUserActivity() {
      if (!currentFirebaseUser) return;

      const now = Date.now();
      lastActivityTime = now;

      // If user was inactive, mark them as active again
      if (!isUserActive) {
        isUserActive = true;
        updateUserStatus('online', true, true); // Force update only on transition to active
        resumeRealtimeListeners();
      } else if (isUserActive && !document.hidden) {
        // Heartbeat only if enough time elapsed since last successful update
        const HEARTBEAT_MS = 60000; // 1 minute
        if (now - lastStatusUpdateTime >= HEARTBEAT_MS) {
          updateUserStatus('online', true, false); // allow cooldown and no-op if unchanged
        }
        resumeRealtimeListeners();
      }

      // Clear existing timeout
      if (activityTimeout) {
        clearTimeout(activityTimeout);
      }

      // Set timeout to mark user as inactive after 10 minutes of no activity
      activityTimeout = setTimeout(() => {
        isUserActive = false;
        // Do NOT push inactive due to tab switching; only after inactivity timeout
        updateUserStatus('inactive', false, true);
        // Pause realtime listeners while inactive (no status change elsewhere)
        pauseRealtimeListeners();
      }, 10 * 60 * 1000);
    }

    // Set up activity tracking
    let activityTrackingInitialized = false;
    function setupActivityTracking() {
      if (activityTrackingInitialized) return;
      activityTrackingInitialized = true;
      // Track mouse movements, clicks, and keyboard activity - more responsive
      const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'keydown'];
      let activityThrottle = null;

      const throttledTrackActivity = () => {
        if (activityThrottle) return;
        activityThrottle = setTimeout(() => {
          trackUserActivity();
          activityThrottle = null;
        }, 800); // Throttle to ~1.25 times per second
      };

      events.forEach(event => {
        document.addEventListener(event, throttledTrackActivity, true);
      });

      // Track page visibility changes (no Firebase status writes on tab switch)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          pauseRealtimeListeners();
        } else {
          // User returned to the page
          // Do not force status write; activity will trigger heartbeat if needed
          resumeRealtimeListeners();
        }
      });

      // Track window focus/blur for more granular presence
      window.addEventListener('focus', () => {
        if (!document.hidden) {
          resumeRealtimeListeners();
        }
      });

      window.addEventListener('blur', () => {
        // Do not mark inactive on blur; simply pause listeners to reduce reads
        pauseRealtimeListeners();
      });

      // Write offline on pagehide/beforeunload to ensure immediate presence accuracy
      // Avoid costly network waits by using a short, best-effort write.
      const handleFastOffline = () => {
        try {
          if (!currentFirebaseUser || !authManager) return;
          // Fire-and-forget status update (no throttling)
          updateUserStatus('offline', false, true);
        } catch (_) { }
      };
      window.addEventListener('pagehide', handleFastOffline, { capture: true });
      window.addEventListener('beforeunload', handleFastOffline, { capture: true });

      // Periodic activity heartbeat (respects cooldown and no-op if unchanged)
      setInterval(() => {
        if (!document.hidden && isUserActive) {
          updateUserStatus('online', true, false);
        }
      }, 60000);
    }

    // Load user profile from Firebase
    async function loadUserProfile(userId) {
      try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        const userDoc = await wrapRead(getDoc(doc(authManager.db, 'users', userId)), 'getDoc', `users/${userId}`, {});

        if (userDoc.exists()) {
          const userData = userDoc.data();

          // Save user data to local storage for compatibility
          DataLayer.save('currentUser', {
            id: userData.id,
            username: userData.username,
            displayName: userData.displayName,
            email: userData.email,
            bio: userData.bio,
            avatar: userData.avatar,
            adjustmentFactor: userData.adjustmentFactor,
            personalityType: userData.personalityType,
            isPremium: userData.isPremium,
            location: userData.location,
            isOnline: userData.isOnline
          });

          // Load personality data if available
          if (userData.adjustmentFactor !== undefined) {
            DataLayer.save('personalityScore', { adjustmentFactor: userData.adjustmentFactor });
            DataLayer.save('personalityType', { type: userData.personalityType });
          }

          console.log('User profile loaded:', userData);
        } else {
          console.log('No user profile found for:', userId);
        }
      } catch (error) {
        console.error('Error loading user profile:', error);
      }
    }

    // Form switching functions
    window.showRegisterForm = function () {
      document.getElementById('login-form-container').style.display = 'none';
      document.getElementById('register-form-container').style.display = 'block';
    }

    window.showLoginForm = function () {
      // Hide register form
      document.getElementById('register-form-container').style.display = 'none';

      // Show login form container
      document.getElementById('login-form-container').style.display = 'block';

      // Show login step 1, hide step 2 and forgot password
      document.getElementById('login-step-1').style.display = 'block';
      document.getElementById('login-step-2').style.display = 'none';
      document.getElementById('forgot-password-container').style.display = 'none';
    }

    // Handle first step of registration (name and email)
    window.handleRegisterContinue = async function () {
      const firstName = document.getElementById('register-firstName').value.trim();
      const lastName = document.getElementById('register-lastName').value.trim();
      const email = document.getElementById('register-email').value.trim();

      if (!firstName || !lastName) {
        NotificationSystem.show('Please fill in your first and last name.', 'warning');
        return;
      }

      // Enhanced email validation
      const emailValidation = validateRegistrationEmail(email);
      if (!emailValidation.valid) {
        NotificationSystem.show(emailValidation.message, 'warning');
        return;
      }

      // Store the data for the next step
      window.registerData = {
        firstName: firstName,
        lastName: lastName,
        email: email
      };

      // Show password step
      document.getElementById('register-form').style.display = 'none';
      document.getElementById('register-password-step').style.display = 'block';
      document.getElementById('register-email-display').textContent = email;
    }

    // Handle second step of registration (password)
    window.handleRegisterPasswordContinue = async function () {
      const password = document.getElementById('register-password').value;

      if (!password) {
        NotificationSystem.show('Password is required.', 'warning');
        return;
      }

      if (password.length < 8) {
        NotificationSystem.show('Password must be at least 8 characters long.', 'warning');
        return;
      }

      // Check password strength
      const strengthFill = document.getElementById('password-strength-fill');
      if (strengthFill.classList.contains('strength-weak')) {
        NotificationSystem.show('Please choose a stronger password.', 'warning');
        return;
      }

      // Get stored data from first step
      const { firstName, lastName, email } = window.registerData || {};

      if (!firstName || !lastName || !email) {
        NotificationSystem.show('Please complete the first step.', 'warning');
        return;
      }

      try {
        // Wait for Firebase to be initialized
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        const { createUserWithEmailAndPassword, updateProfile, sendEmailVerification } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
        const { doc, setDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        // Create Firebase auth user
        const userCredential = await createUserWithEmailAndPassword(authManager.auth, email, password);
        const user = userCredential.user;

        // Send email verification with action code settings
        const actionCodeSettings = {
          url: window.location.origin + '/pitch/index.html',
          handleCodeInApp: false
        };

        await sendEmailVerification(user, actionCodeSettings);

        // Create display name from first and last name
        const displayName = `${firstName} ${lastName}`;
        const username = `${firstName.toLowerCase()}${lastName.toLowerCase()}${Math.floor(Math.random() * 1000)}`;

        // Update display name
        await updateProfile(user, { displayName });

        // Create user profile in Firestore
        const userProfile = {
          id: user.uid,
          username: username,
          displayName: displayName,
          firstName: firstName,
          lastName: lastName,
          email: email,
          bio: '',
          avatar: displayName.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2),
          adjustmentFactor: 0.0, // Will be set after personality assessment
          personalityType: 'Not Set',
          isPremium: false,
          isOnline: true,
          emailVerified: false,
          lastSeen: serverTimestamp(),
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };

        await wrapWrite(
          setDoc(doc(authManager.db, 'users', user.uid), userProfile),
          'setDoc',
          `users/${user.uid}`,
          { profileCreated: true }
        );

        // Show email verification modal
        showEmailVerificationModal(email);
      } catch (error) {
        console.error('Registration error:', error);
        let message = 'Registration failed. ';
        switch (error.code) {
          case 'auth/email-already-in-use':
            message += 'An account with this email already exists.';
            break;
          case 'auth/weak-password':
            message += 'Password should be at least 6 characters.';
            break;
          case 'auth/invalid-email':
            message += 'Invalid email address.';
            break;
          default:
            message += error.message;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    // Go back to first step of registration
    function backToRegisterStep() {
      document.getElementById('register-password-step').style.display = 'none';
      document.getElementById('register-form').style.display = 'block';
    }

    // Handle Enter key press on first step of registration
    function handleRegisterKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        handleRegisterContinue();
      }
    }

    // Handle Enter key press on password step of registration
    function handleRegisterPasswordKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        handleRegisterPasswordContinue();
      }
    }

    // Handle Enter key press on forgot password form
    function handleForgotPasswordKeyPress(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        handleForgotPassword();
      }
    }
    // Show email verification modal
    function showEmailVerificationModal(email) {
      const modalHtml = `
        <div id="email-verification-modal" class="modal">
          <div class="modal-content" style="max-width: 500px; text-align: center;">
            <div class="modal-header">
              <h2 style="color: var(--primary-color); margin-bottom: 0.5rem;">
                <i class="fas fa-envelope" style="color: var(--secondary-color); margin-right: 0.5rem;"></i>
                Verify Your Email
              </h2>
              <p style="color: var(--text-color); margin: 0;">We've sent a verification link to your email</p>
            </div>
            
            <div class="modal-body" style="padding: 2rem 1rem;">
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 15px; margin-bottom: 1.5rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">📧</div>
                <h3 style="margin: 0 0 0.5rem 0; font-size: 1.3rem;">Check Your Email</h3>
                <p style="margin: 0; opacity: 0.9; font-size: 1rem;">${email}</p>
              </div>
              
              <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 10px; margin-bottom: 1.5rem; border-left: 4px solid var(--primary-color);">
                <h4 style="margin: 0 0 1rem 0; color: var(--primary-color);">
                  <i class="fas fa-info-circle" style="margin-right: 0.5rem;"></i>
                  What's Next?
                </h4>
                <ul style="text-align: left; margin: 0; padding-left: 1.5rem; color: var(--text-color);">
                  <li style="margin-bottom: 0.5rem;">Open the email we just sent you</li>
                  <li style="margin-bottom: 0.5rem;">Click the "Verify Email" button in the email</li>
                  <li style="margin-bottom: 0.5rem;">Come back here and click "I've Verified My Email"</li>
                </ul>
              </div>
              
              <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <button type="button" class="btn" onclick="resendVerificationEmail()" style="background: var(--secondary-color); color: white;">
                  <i class="fas fa-redo" style="margin-right: 0.5rem;"></i>
                  Resend Email
                </button>
                <button type="button" class="btn btn-secondary" onclick="checkEmailVerification()">
                  <i class="fas fa-check" style="margin-right: 0.5rem;"></i>
                  I've Verified My Email
                </button>
              </div>
            </div>
            
            <div class="modal-footer" style="padding: 1rem; border-top: 1px solid #eee;">
              <p style="margin: 0; color: var(--secondary-color); font-size: 0.9rem;">
                <i class="fas fa-shield-alt" style="margin-right: 0.5rem;"></i>
                Email verification helps keep your account secure
              </p>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);

      // Add modal listeners
      const modal = document.getElementById('email-verification-modal');
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeEmailVerificationModal();
        }
      });
    }

    // Close email verification modal
    function closeEmailVerificationModal() {
      const modal = document.getElementById('email-verification-modal');
      if (modal) {
        modal.remove();
      }
    }

    // Resend verification email
    async function resendVerificationEmail() {
      try {
        const { sendEmailVerification } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');

        if (authManager.auth.currentUser) {
          await sendEmailVerification(authManager.auth.currentUser);
          NotificationSystem.show('Verification email sent!', 'success');
        } else {
          NotificationSystem.show('Please sign in first.', 'error');
        }
      } catch (error) {
        console.error('Error sending verification email:', error);
        NotificationSystem.show('Failed to send verification email.', 'error');
      }
    }

    // Check email verification status
    async function checkEmailVerification() {
      try {
        if (authManager.auth.currentUser) {
          await authManager.auth.currentUser.reload();

          if (authManager.auth.currentUser.emailVerified) {
            // Update Firestore
            const { doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
            await wrapWrite(
              updateDoc(doc(authManager.db, 'users', authManager.auth.currentUser.uid), {
                emailVerified: true,
                updatedAt: new Date()
              }),
              'updateDoc',
              `users/${authManager.auth.currentUser.uid}`,
              { emailVerified: true }
            );

            closeEmailVerificationModal();
            NotificationSystem.show('Email verified successfully! Welcome to Catalyst!', 'success');

            // Redirect to dashboard
            showPage('dashboard');
          } else {
            NotificationSystem.show('Please check your email and click the verification link first.', 'warning');
          }
        } else {
          NotificationSystem.show('Please sign in first.', 'error');
        }
      } catch (error) {
        console.error('Error checking verification:', error);
        NotificationSystem.show('Failed to check verification status.', 'error');
      }
    }

    // Show forgot password form
    function showForgotPassword() {
      // Hide all login steps
      document.getElementById('login-step-1').style.display = 'none';
      document.getElementById('login-step-2').style.display = 'none';

      // Show forgot password form
      document.getElementById('forgot-password-container').style.display = 'block';
    }

    // Back to login step
    function backToLoginStep() {
      // Hide forgot password form
      document.getElementById('forgot-password-container').style.display = 'none';

      // Show login form (step 1)
      document.getElementById('login-step-1').style.display = 'block';
      document.getElementById('login-step-2').style.display = 'none';
    }

    // Handle forgot password
    window.handleForgotPassword = async function () {
      const email = document.getElementById('forgot-email').value.trim();

      if (!email) {
        NotificationSystem.show('Please enter your email address.', 'warning');
        return;
      }

      if (!isValidEmail(email)) {
        NotificationSystem.show('Please enter a valid email address.', 'warning');
        return;
      }

      try {
        if (!authManager) {
          const initialized = await initializeFirebaseAuth();
          if (!initialized) {
            return;
          }
        }

        console.log('Sending password reset email to:', email);
        console.log('Auth manager:', authManager);

        const { sendPasswordResetEmail } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');

        // Add action code settings for better email delivery
        const actionCodeSettings = {
          url: window.location.origin + '/pitch/index.html',
          handleCodeInApp: false
        };

        await sendPasswordResetEmail(authManager.auth, email, actionCodeSettings);

        console.log('Password reset email sent successfully');
        NotificationSystem.show('Password reset link sent to your email! Check your inbox and spam folder.', 'success');
        backToLoginStep();
      } catch (error) {
        console.error('Password reset error:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);

        let message = 'Failed to send reset link. ';
        switch (error.code) {
          case 'auth/user-not-found':
            message += 'No account found with this email address.';
            break;
          case 'auth/invalid-email':
            message += 'Invalid email address.';
            break;
          case 'auth/too-many-requests':
            message += 'Too many requests. Please try again later.';
            break;
          case 'auth/network-request-failed':
            message += 'Network error. Please check your connection.';
            break;
          default:
            message += `Error: ${error.message}`;
        }
        NotificationSystem.show(message, 'error');
      }
    }

    // Check password strength
    function checkPasswordStrength(password) {
      const strengthFill = document.getElementById('password-strength-fill');
      const strengthText = document.getElementById('password-strength-text');

      if (!password) {
        strengthFill.className = 'password-strength-fill';
        strengthText.textContent = 'Password strength';
        strengthText.className = 'password-strength-text';
        return;
      }

      let score = 0;
      let feedback = [];

      // Length check
      if (password.length >= 8) {
        score += 1;
      } else {
        feedback.push('At least 8 characters');
      }

      // Lowercase check
      if (/[a-z]/.test(password)) {
        score += 1;
      } else {
        feedback.push('Lowercase letter');
      }

      // Uppercase check
      if (/[A-Z]/.test(password)) {
        score += 1;
      } else {
        feedback.push('Uppercase letter');
      }

      // Number check
      if (/\d/.test(password)) {
        score += 1;
      } else {
        feedback.push('Number');
      }

      // Special character check
      if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
        score += 1;
      } else {
        feedback.push('Special character');
      }

      // Determine strength level
      let strength, textClass, fillClass;

      if (score <= 1) {
        strength = 'Weak';
        textClass = 'text-weak';
        fillClass = 'strength-weak';
      } else if (score <= 2) {
        strength = 'Fair';
        textClass = 'text-fair';
        fillClass = 'strength-fair';
      } else if (score <= 3) {
        strength = 'Good';
        textClass = 'text-good';
        fillClass = 'strength-good';
      } else {
        strength = 'Strong';
        textClass = 'text-strong';
        fillClass = 'strength-strong';
      }

      // Update UI
      strengthFill.className = `password-strength-fill ${fillClass}`;
      strengthText.textContent = `${strength} password`;
      strengthText.className = `password-strength-text ${textClass}`;
    }

    // Email validation function (duplicate removed)
    // function isValidEmail(email) {
    //   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    //   return emailRegex.test(email);
    // }

    // Enhanced email validation for registration
    function validateRegistrationEmail(email) {
      if (!email) {
        return { valid: false, message: 'Email is required.' };
      }

      if (!isValidEmail(email)) {
        return { valid: false, message: 'Please enter a valid email address.' };
      }

      // Check for common disposable email domains
      const disposableDomains = [
        'tempmail.org', 'guerrillamail.com', 'mailinator.com', '10minutemail.com',
        'throwaway.email', 'temp-mail.org', 'sharklasers.com', 'getairmail.com'
      ];

      const domain = email.split('@')[1];
      if (disposableDomains.includes(domain)) {
        return { valid: false, message: 'Please use a valid email address (no temporary emails).' };
      }

      return { valid: true, message: '' };
    }

    // Handle user logout (duplicate removed)
    // async function handleLogout() {
    //   try {
    //     // Clear all caches before logout
    //     CacheSystem.clearAll();

    //     const { signOut } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
    //     await signOut(authManager.auth);

    //     // Update navigation and redirect to login
    //     updateNavigationVisibility();
    //     showPage('login');

    //     NotificationSystem.show('Successfully signed out!', 'success');
    //   } catch (error) {
    //     console.error('Logout error:', error);
    //     NotificationSystem.show('Error signing out.', 'error');
    //   }
    // }

    // Load user profile from Firestore
    async function loadUserProfile(userId) {
      try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        const userDoc = await wrapRead(getDoc(doc(authManager.db, 'users', userId)), 'getDoc', `users/${userId}`, {});

        if (userDoc.exists()) {
          const userData = userDoc.data();

          // Update current user data
          DataLayer.save("currentUser", {
            id: userId,
            username: userData.username,
            displayName: userData.displayName,
            avatar: userData.avatar,
            adjustmentFactor: userData.adjustmentFactor || 0.0,
            personalityType: userData.personalityType || 'Not Set',
            isPremium: userData.isPremium || false,
            location: userData.location || null
          });

          // Save personality data to local storage if available
          if (userData.adjustmentFactor !== undefined && userData.personalityType) {
            DataLayer.save('personalityScore', { adjustmentFactor: userData.adjustmentFactor });
            DataLayer.save('personalityType', { type: userData.personalityType });

            // Remove assessment tab if user has completed assessment
            const assessmentTab = document.querySelector("li:has([onclick=\"showPage('assessment')\"])");
            if (assessmentTab) {
              assessmentTab.remove();
            }
          }

          // Update UI
          updateDashboard();
          updateProfile();

          // Start real-time system
          initializeRealtimeSystem();
        }
      } catch (error) {
        console.error('Error loading user profile:', error);
      }
    }

    // Real-time and Near Real-time Firebase System
    let realtimeListenersInitialized = false;
    let isResumingListeners = false;

    let realtimeListeners = {
      friendRequests: null,
      outgoingRequests: null,
      friendships1: null,
      friendships2: null,
      groups: null,
      userStatus: null,
      friendStatuses: null
    };

    let statusUpdateInterval = null;
    let locationSchedulerStarted = false;
    let lastStatusUpdate = 0;
    let areRealtimeListenersActive = false;
    // Additional presence watch list for currently visible users (e.g., friendship page)
    let additionalPresenceWatchIds = new Set();
    // Single-flight/debounce for user-status listeners
    let isUserStatusInitInFlight = false;
    let userStatusRefreshTimer = null;
    // Throttle UI churn from presence updates
    let lastUserStatusUIUpdate = 0;
    const USER_STATUS_UI_MIN_INTERVAL = 2000; // 2s between UI refreshes

    // --- Firebase Write Logger (local-only) ---
    const FirebaseWriteLogger = (() => {
      const STORAGE_KEY = 'FIREBASE_WRITE_LOGS';
      const MAX_ENTRIES = 1000;
      let buffer = [];

      function load() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          buffer = raw ? JSON.parse(raw) : [];
          if (!Array.isArray(buffer)) buffer = [];
        } catch (_) {
          buffer = [];
        }
      }

      function persist() {
        try {
          if (buffer.length > MAX_ENTRIES) {
            buffer = buffer.slice(buffer.length - MAX_ENTRIES);
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify(buffer));
        } catch (_) {
          // ignore storage failures
        }
      }

      load();

      return {
        log(action, path, meta = {}, resultId = null, error = null) {
          const entry = {
            ts: new Date().toISOString(),
            action, // addDoc | updateDoc | deleteDoc | setDoc
            path,   // e.g., users/uid or friendRequests
            meta: (() => { try { return JSON.parse(JSON.stringify(meta)); } catch { return {}; } })(),
            resultId,
            ok: !error,
            error: error ? { message: String(error?.message || error), code: error?.code || null } : null,
          };
          buffer.push(entry);
          persist();
          return entry;
        },
        exportAsText() {
          const lines = buffer.map(e => {
            return `[${e.ts}] ${e.ok ? 'OK' : 'ERR'} ${e.action} ${e.path} ${e.resultId ? `id=${e.resultId}` : ''} ${e.error ? `error=${e.error.message}` : ''} meta=${JSON.stringify(e.meta)}`.trim();
          });
          const blob = new Blob([lines.join('\n') + '\n'], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `firebase-writes-${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        },
        clear() {
          buffer = [];
          persist();
        },
        getAll() { return [...buffer]; }
      };
    })();

    async function wrapWrite(promise, action, path, meta) {
      const start = Date.now();
      try {
        const result = await promise;
        const durationMs = Date.now() - start;
        const resultId = result?.id || null;
        FirebaseWriteLogger.log(action, path, { ...meta, durationMs }, resultId, null);
        return result;
      } catch (error) {
        const durationMs = Date.now() - start;
        FirebaseWriteLogger.log(action, path, { ...meta, durationMs }, null, error);
        throw error;
      }
    }

    async function wrapRead(promise, action, path, meta) {
      const start = Date.now();
      try {
        const result = await promise;
        const durationMs = Date.now() - start;
        const size = (result?.size !== undefined) ? result.size : (Array.isArray(result?.docs) ? result.docs.length : undefined);
        FirebaseWriteLogger.log(action, path, { ...meta, durationMs, size }, null, null);
        return result;
      } catch (error) {
        const durationMs = Date.now() - start;
        FirebaseWriteLogger.log(action, path, { ...meta, durationMs }, null, error);
        throw error;
      }
    }

    // Comprehensive Data Strategy
    const DataStrategy = {
      // REAL-TIME: Data that changes frequently and affects user interaction
      REAL_TIME: {
        user_presence: 'User online/offline/active status',
        friend_requests: 'Incoming friend requests',
        friend_request_status: 'Status changes (accepted/rejected)',
        group_membership: 'Being added/removed from groups',
        group_messages: 'Group chat messages (future)',
        voting_updates: 'Activity voting in groups',
        ai_itinerary_changes: 'AI itinerary updates',
        member_additions: 'New members added to groups',
        friendship_creation: 'When friend requests are accepted'
      },

      // CACHED: Data that changes infrequently and can be cached with refresh on change
      CACHED: {
        user_profiles: 'Basic user information (name, avatar, bio)',
        experiences: 'User activity experiences',
        personality_data: 'Assessment results and adjustment factors',
        location_data: 'User location information',
        similar_users: 'Users with similar personalities',
        group_details: 'Group descriptions and settings',
        activity_categories: 'Static activity category data',
        friends_list: 'List of current friends',
        recommendations: 'Activity recommendations'
      },

      // BATCH_UPDATE: Data that can be updated in batches for performance
      BATCH_UPDATE: {
        user_experiences: 'Bulk experience updates',
        location_updates: 'Periodic location updates (5min)',
        analytics_data: 'Usage statistics and metrics',
        search_cache: 'Search results for performance'
      }
    };

    // Enhanced initialization with comprehensive data strategy
    let _initRealtimeInFlight = false;
    async function initializeRealtimeSystem() {
      if (!currentFirebaseUser || !authManager) return;
      if (_initRealtimeInFlight) return; // cooldown: skip duplicate inits
      _initRealtimeInFlight = true;

      console.log('🚀 Initializing comprehensive real-time system...');

      // Step 1: BATCH LOAD - Load all essential user data in one go
      await batchLoadEssentialData();

      // Step 2: REAL-TIME LISTENERS - Set up real-time listeners for critical data
      await initializeRealTimeListeners();
      areRealtimeListenersActive = true;
      // Start background location scheduler
      startLocationScheduler();

      console.log('✅ Real-time system fully initialized');
      setTimeout(() => { _initRealtimeInFlight = false; }, 100);
    }

    // Batch load all essential data with caching strategy
    async function batchLoadEssentialData() {
      console.log('📦 Batch loading essential user data...');

      try {
        const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        // Parallel loading of user data
        const loadPromises = [
          loadUserFriendsWithCache(),
          loadUserGroupsWithCache(),
          loadUserExperiencesWithCache(),
          loadFriendRequestsWithCache()
        ];

        await Promise.all(loadPromises);
        console.log('✅ Batch loading completed');
      } catch (error) {
        console.error('❌ Error in batch loading:', error);
      }
    }

    // Load friends with intelligent caching
    async function loadUserFriendsWithCache() {
      const cached = CacheSystem.get('FRIENDS', CacheSystem.CACHE_DURATIONS.FRIENDS);
      if (cached) {
        DataLayer.save('friends', cached);
        return cached;
      }

      try {
        const friends = await FriendsSystem.getFriends();
        CacheSystem.set('FRIENDS', friends);
        DataLayer.save('friends', friends);
        return friends;
      } catch (error) {
        console.error('Error loading friends:', error);
        return [];
      }
    }

    // Load groups with intelligent caching
    async function loadUserGroupsWithCache() {
      const cached = CacheSystem.get('GROUPS', CacheSystem.CACHE_DURATIONS.GROUPS);
      if (cached) {
        DataLayer.save('groups', cached);
        return cached;
      }

      try {
        const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        const groupsQuery = query(
          collection(authManager.db, 'groups'),
          where('members', 'array-contains', currentFirebaseUser.uid)
        );

        const snapshot = await getDocs(groupsQuery);
        const groups = [];
        snapshot.forEach((doc) => {
          groups.push({ id: doc.id, ...doc.data() });
        });

        CacheSystem.set('GROUPS', groups);
        DataLayer.save('groups', groups);
        return groups;
      } catch (error) {
        console.error('Error loading groups:', error);
        return [];
      }
    }

    // Load experiences with caching
    async function loadUserExperiencesWithCache() {
      const cached = CacheSystem.get('EXPERIENCES', CacheSystem.CACHE_DURATIONS.EXPERIENCES);
      if (cached) {
        DataLayer.save('userExperiences', cached);
        return cached;
      }

      try {
        const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        const experiencesQuery = query(
          collection(authManager.db, 'experiences'),
          where('userId', '==', currentFirebaseUser.uid)
        );

        const snapshot = await getDocs(experiencesQuery);
        const experiences = [];
        snapshot.forEach((doc) => {
          const data = doc.data();
          experiences.push({
            id: data.id || doc.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
            firebaseId: doc.id, // Store Firebase document ID separately
            ...data,
            timestamp: data.createdAt?.toDate?.() || new Date()
          });
        });

        CacheSystem.set('EXPERIENCES', experiences);
        DataLayer.save('userExperiences', experiences);
        return experiences;
      } catch (error) {
        console.error('Error loading experiences:', error);
        return [];
      }
    }

    // Load friend requests with short-term caching
    async function loadFriendRequestsWithCache() {
      const cached = CacheSystem.get('FRIEND_REQUESTS', CacheSystem.CACHE_DURATIONS.FRIEND_REQUESTS);
      if (cached) {
        if (typeof FriendsDiscoverySystem !== 'undefined') {
          FriendsDiscoverySystem.friendRequests = cached;
        }
        return cached;
      }

      try {
        const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        const requestsQuery = query(
          collection(authManager.db, 'friendRequests'),
          where('toUserId', '==', currentFirebaseUser.uid),
          where('status', '==', 'pending')
        );

        const snapshot = await getDocs(requestsQuery);
        const requests = [];
        snapshot.forEach((doc) => {
          requests.push({ id: doc.id, ...doc.data() });
        });

        CacheSystem.set('FRIEND_REQUESTS', requests);
        if (typeof FriendsDiscoverySystem !== 'undefined') {
          FriendsDiscoverySystem.friendRequests = requests;
        }
        return requests;
      } catch (error) {
        console.error('Error loading friend requests:', error);
        return [];
      }
    }

    // Initialize real-time listeners for critical data only
    async function initializeRealTimeListeners() {
      if (realtimeListenersInitialized) return;
      realtimeListenersInitialized = true;

      console.log('🔄 Setting up real-time listeners...');

      try {
        const { collection, query, where, onSnapshot, doc, onSnapshot: docOnSnapshot } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        // 1. REAL-TIME: Friend Request Listeners
        await initializeFriendRequestListeners(collection, query, where, onSnapshot);

        // 2. REAL-TIME: Group Update Listeners
        await initializeGroupUpdateListeners(collection, query, where, onSnapshot, doc, docOnSnapshot);

        // 3. REAL-TIME: User Status Updates (presence system)
        await initializeUserStatusListeners();

        // ACTIVITY TRACKING: Real-time presence detection
        setupActivityTracking();

        console.log('✅ Real-time listeners initialized');
      } catch (error) {
        console.error('❌ Error setting up real-time listeners:', error);
      }
    }

    // Pause all realtime listeners (used when user is inactive/hidden)
    function pauseRealtimeListeners() {
      if (!areRealtimeListenersActive) return;
      console.log('⏸️ Pausing real-time listeners due to inactivity/hidden tab');
      cleanupRealtimeListeners();
      areRealtimeListenersActive = false;
    }

    // Resume realtime listeners with a fresh batch sync
    async function resumeRealtimeListeners() {
      if (areRealtimeListenersActive || isResumingListeners) return;

      isResumingListeners = true;
      console.log('▶️ Resuming real-time listeners with batch refresh');

      try {
        await batchLoadEssentialData();
        // Reset the initialization flag to allow fresh setup
        realtimeListenersInitialized = false;
        await initializeRealTimeListeners();
        areRealtimeListenersActive = true;
        startLocationScheduler();
      } catch (error) {
        console.error('Error resuming real-time listeners:', error);
      } finally {
        isResumingListeners = false;
      }
    }

    // Enhanced page visit function with intelligent data loading
    async function updateOnPageVisit(pageName) {
      if (!currentFirebaseUser || !authManager) return;

      console.log(`📄 Page visit: ${pageName} - Loading relevant data...`);

      try {
        const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        switch (pageName) {
          case 'dashboard':
            // Dashboard needs: user profile, experiences summary, groups summary
            await Promise.all([
              loadUserProfileIfNeeded(),
              loadUserExperiencesWithCache(),
              loadUserGroupsWithCache()
            ]);
            updateDashboard();
            break;

          case 'profile':
            // Profile needs: full user data, experiences, assessment data
            await Promise.all([
              loadUserProfileIfNeeded(),
              loadUserExperiencesWithCache()
            ]);
            updateProfile();
            break;

          case 'friends':
            // Friends page needs: friends list, friend requests, similar users
            await Promise.all([
              loadUserFriendsWithCache(),
              loadFriendRequestsWithCache(),
              loadSimilarUsersWithCache()
            ]);
            break;

          case 'groups':
            // Groups page needs: user groups, friends for creating groups
            await Promise.all([
              loadUserGroupsWithCache(),
              loadUserFriendsWithCache()
            ]);
            break;

          case 'activities':
            // Activities page needs: user experiences for recommendations
            await loadUserExperiencesWithCache();
            break;
        }

        console.log(`✅ Page data loaded for: ${pageName}`);
      } catch (error) {
        console.error(`❌ Error loading page data for ${pageName}:`, error);
      }
    }

    // Load user profile only if not cached or expired
    async function loadUserProfileIfNeeded() {
      const cached = CacheSystem.get('USER_PROFILE', CacheSystem.CACHE_DURATIONS.USER_PROFILES);
      if (cached) {
        const currentUser = DataLayer.load('currentUser') || {};
        DataLayer.save('currentUser', { ...currentUser, ...cached });
        return cached;
      }

      try {
        const { doc, getDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
        const userDoc = await wrapRead(getDoc(doc(authManager.db, 'users', currentFirebaseUser.uid)), 'getDoc', `users/${currentFirebaseUser.uid}`, { source: 'dashboard' });

        if (userDoc.exists()) {
          const userData = userDoc.data();
          const profileData = {
            id: currentFirebaseUser.uid,
            username: userData.username,
            displayName: userData.displayName,
            email: userData.email,
            bio: userData.bio,
            avatar: userData.avatar,
            adjustmentFactor: userData.adjustmentFactor,
            personalityType: userData.personalityType,
            isPremium: userData.isPremium,
            location: userData.location,
            isOnline: userData.isOnline
          };

          CacheSystem.set('USER_PROFILE', profileData);
          DataLayer.save('currentUser', profileData);
          return profileData;
        }
      } catch (error) {
        console.error('Error loading user profile:', error);
      }

      return null;
    }

    // Load similar users with caching
    async function loadSimilarUsersWithCache() {
      const cached = CacheSystem.get('SIMILAR_USERS', CacheSystem.CACHE_DURATIONS.SIMILAR_USERS);
      if (cached) {
        return cached;
      }

      try {
        // This would use the existing similar users logic
        const similarUsers = await SimilarUsersSystem.findSimilarUsers();
        CacheSystem.set('SIMILAR_USERS', similarUsers);
        return similarUsers;
      } catch (error) {
        console.error('Error loading similar users:', error);
        return [];
      }
    }






    // Real-time friend request listeners
    async function initializeFriendRequestListeners(collection, query, where, onSnapshot) {
      if (!currentFirebaseUser || !authManager) return;

      // Prevent duplicate initialization
      if (realtimeListeners.friendRequests) {
        console.log('Friend request listeners already initialized, skipping...');
        return;
      }

      try {
        // Listen for incoming friend requests
        const incomingRequestsQuery = query(
          collection(authManager.db, 'friendRequests'),
          where('toUserId', '==', currentFirebaseUser.uid),
          where('status', '==', 'pending')
        );

        realtimeListeners.friendRequests = onSnapshot(incomingRequestsQuery, (snapshot) => {
          const newRequests = [];
          const previousCount = (typeof FriendsDiscoverySystem !== 'undefined') ? FriendsDiscoverySystem.friendRequests.length : 0;

          snapshot.forEach((doc) => {
            newRequests.push({
              id: doc.id,
              ...doc.data()
            });
          });

          // Update local friend requests
          if (typeof FriendsDiscoverySystem !== 'undefined') {
            FriendsDiscoverySystem.friendRequests = newRequests;
            FriendsDiscoverySystem.updateFriendRequestBadge();

            // Force immediate UI refresh in any friendship UI
            if (typeof FriendsDiscoverySystem !== 'undefined' && FriendsDiscoverySystem.displayUsers) {
              FriendsDiscoverySystem.displayUsers();
            }

            // Show notification for new requests only if count increased
            if (newRequests.length > previousCount && newRequests.length > 0) {
              const newCount = newRequests.length - previousCount;
              NotificationSystem.show(
                `You have ${newCount} new friend request${newCount > 1 ? 's' : ''}! Click to view.`,
                'info',
                7000,
                () => {
                  showPage('feed');
                  setTimeout(() => {
                    const friendshipTab = document.getElementById('friendship-tab');
                    if (friendshipTab) {
                      friendshipTab.click();
                    }
                  }, 100);
                }
              );
            }

            // Presence list may change; refresh per-user listeners
            refreshUserStatusListeners();
          }

          // Update dashboard friend request indicator if on dashboard
          updateDashboardFriendRequestIndicator();

          // Update profile page friend request button if viewing someone's profile
          updateProfilePageFriendRequestButton();

          console.log('Real-time friend requests updated:', newRequests.length);
        }, (error) => {
          console.error('Error listening to friend requests:', error);
        });

        // Listen for friend request status changes (accepted/rejected)
        const outgoingRequestsQuery = query(
          collection(authManager.db, 'friendRequests'),
          where('fromUserId', '==', currentFirebaseUser.uid)
        );

        realtimeListeners.outgoingRequests = onSnapshot(outgoingRequestsQuery, (snapshot) => {
          console.log('Outgoing requests updated:', snapshot.size, 'requests');

          snapshot.docChanges().forEach((change) => {
            const request = change.doc.data();

            if (change.type === 'modified') {
              if (request.status === 'accepted') {
                console.log(`Friend request accepted by ${request.toUserId}`);
                FriendsSystem.updateFriendButton(request.toUserId, true);
                NotificationSystem.show('Friend request accepted!', 'success');

                // Optimistically update pending list locally to avoid refetches
                if (typeof FriendsDiscoverySystem !== 'undefined') {
                  FriendsDiscoverySystem.pendingRequests = (FriendsDiscoverySystem.pendingRequests || []).filter(r => r.toUserId !== request.toUserId);
                }

                // Optional: clean up request in background
                setTimeout(async () => {
                  try {
                    const { doc, deleteDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
                    await wrapWrite(
                      deleteDoc(doc(authManager.db, 'friendRequests', change.doc.id)),
                      'deleteDoc',
                      `friendRequests/${change.doc.id}`,
                      { reason: 'accepted_cleanup' }
                    );
                  } catch (error) {
                    console.error('Error cleaning up friend request:', error);
                  }
                }, 2000);

              } else if (request.status === 'rejected') {
                console.log(`Friend request rejected by ${request.toUserId}`);
                FriendsSystem.updateFriendButton(request.toUserId, false);
                NotificationSystem.show('Friend request was declined.', 'warning');

                // Track cooldown locally
                if (typeof FriendsDiscoverySystem !== 'undefined') {
                  FriendsDiscoverySystem.setCooldown(request.toUserId, 5 * 60 * 1000);
                  FriendsDiscoverySystem.pendingRequests = (FriendsDiscoverySystem.pendingRequests || []).filter(r => r.toUserId !== request.toUserId);
                }
              }
            }
          });
        });

        // Listen for new friendships (when requests are accepted by recipient)
        const friendsQuery = query(
          collection(authManager.db, 'friends'),
          where('user1Id', '==', currentFirebaseUser.uid)
        );

        const friendsQuery2 = query(
          collection(authManager.db, 'friends'),
          where('user2Id', '==', currentFirebaseUser.uid)
        );

        // Listen to both friendship queries
        realtimeListeners.friendships1 = onSnapshot(friendsQuery, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const friendship = change.doc.data();
              console.log('New friendship detected (user1):', friendship);

              // Update UI to show they're now friends
              const friendId = friendship.user2Id;
              FriendsSystem.updateFriendButton(friendId, true);

              // Minimal local update to avoid heavy refetches
              if (typeof FriendsDiscoverySystem !== 'undefined') {
                const exists = (FriendsDiscoverySystem.currentFriends || []).some(u => u.id === friendId);
                if (!exists) {
                  FriendsDiscoverySystem.currentFriends = [...(FriendsDiscoverySystem.currentFriends || []), { id: friendId }];
                }
                FriendsDiscoverySystem.displayUsers();
                refreshUserStatusListeners();
              }
            }
          });
        });

        realtimeListeners.friendships2 = onSnapshot(friendsQuery2, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const friendship = change.doc.data();
              console.log('New friendship detected (user2):', friendship);

              // Update UI to show they're now friends
              const friendId = friendship.user1Id;
              FriendsSystem.updateFriendButton(friendId, true);

              // Minimal local update to avoid heavy refetches
              if (typeof FriendsDiscoverySystem !== 'undefined') {
                const exists = (FriendsDiscoverySystem.currentFriends || []).some(u => u.id === friendId);
                if (!exists) {
                  FriendsDiscoverySystem.currentFriends = [...(FriendsDiscoverySystem.currentFriends || []), { id: friendId }];
                }
                FriendsDiscoverySystem.displayUsers();
                refreshUserStatusListeners();
              }
            }
          });
        });

        console.log('Friend request real-time listeners initialized');
        // Rebuild presence listeners for the relevant user set
        refreshUserStatusListeners();
      } catch (error) {
        console.error('Error initializing friend request listeners:', error);
      }
    }

    // Update dashboard friend request indicator
    function updateDashboardFriendRequestIndicator() {
      if (!document.getElementById('dashboard').classList.contains('hidden')) {
        const requestCount = (typeof FriendsDiscoverySystem !== 'undefined') ? FriendsDiscoverySystem.friendRequests.length : 0;

        // Update any existing dashboard friend request elements
        const dashboardFriendElements = document.querySelectorAll('.dashboard-friend-requests');
        dashboardFriendElements.forEach(element => {
          if (requestCount > 0) {
            element.innerHTML = `<i class="fas fa-user-friends"></i> ${requestCount} New Friend Request${requestCount > 1 ? 's' : ''}`;
            element.style.display = 'block';
          } else {
            element.style.display = 'none';
          }
        });
      }
    }

    // Update profile page friend request button if viewing someone's profile
    function updateProfilePageFriendRequestButton() {
      if (!document.getElementById('profile').classList.contains('hidden')) {
        // Check if there are any pending buttons that need updating
        const pendingButtons = document.querySelectorAll('button[style*="fbbf24"]'); // Yellow background buttons
        pendingButtons.forEach(button => {
          if (button.innerHTML.includes('Pending')) {
            // Button is still showing pending - real-time listener will handle the update
            console.log('Found pending button on profile page');
          }
        });
      }
    }

    // Real-time group update listeners
    async function initializeGroupUpdateListeners(collection, query, where, onSnapshot, doc, docOnSnapshot) {
      if (!currentFirebaseUser || !authManager) return;

      // Prevent duplicate initialization
      if (realtimeListeners.groups) {
        console.log('Group listeners already initialized, skipping...');
        return;
      }

      try {
        // Listen for groups where current user is a member
        const userGroupsQuery = query(
          collection(authManager.db, 'groups'),
          where('members', 'array-contains', currentFirebaseUser.uid)
        );

        realtimeListeners.groups = onSnapshot(userGroupsQuery, (snapshot) => {
          const updatedGroups = [];
          let hasNewGroups = false;

          // Track changes for real-time notifications
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              hasNewGroups = true;
              const groupData = { id: change.doc.id, ...change.doc.data() };
              console.log('New group detected:', groupData.name);

              // Show notification for new group if user didn't create it
              if (groupData.adminId !== currentFirebaseUser.uid) {
                NotificationSystem.show(`You've been added to group: ${groupData.name}!`, 'success');
              }
            } else if (change.type === 'modified') {
              console.log('Group modified:', change.doc.data().name);
            } else if (change.type === 'removed') {
              console.log('Group removed:', change.doc.data().name);
            }
          });

          // Build updated groups list
          snapshot.forEach((doc) => {
            updatedGroups.push({
              id: doc.id,
              ...doc.data()
            });
          });

          // Update local groups data and invalidate cache
          DataLayer.save('groups', updatedGroups);
          CacheSystem.invalidateGroupsCache();

          // Refresh groups display if on groups page
          if (document.getElementById('groups').classList.contains('hidden') === false) {
            if (typeof GroupsSystem !== 'undefined') {
              GroupsSystem.displayGroups();
            }
          }

          console.log('Real-time groups updated:', updatedGroups.length, hasNewGroups ? '(new groups detected)' : '');
        }, (error) => {
          console.error('Error listening to groups:', error);
        });

        // Listen for specific group changes (AI itinerary updates, member additions)
        const groups = DataLayer.load('groups', []);
        groups.forEach((group) => {
          const groupDocRef = doc(authManager.db, 'groups', group.id);

          const groupListener = docOnSnapshot(groupDocRef, (docSnapshot) => {
            if (docSnapshot.exists()) {
              const updatedGroup = {
                id: docSnapshot.id,
                ...docSnapshot.data()
              };

              // Check for specific changes
              const oldGroup = groups.find(g => g.id === group.id);
              if (oldGroup) {
                // Check if AI itinerary changed
                if (updatedGroup.aiItinerary && (!oldGroup.aiItinerary || JSON.stringify(updatedGroup.aiItinerary) !== JSON.stringify(oldGroup.aiItinerary))) {
                  NotificationSystem.show('AI itinerary updated for your group!', 'info');
                }

                // Check if new members were added
                if (updatedGroup.members && updatedGroup.members.length > oldGroup.members.length) {
                  const newMembers = updatedGroup.members.filter(memberId => !oldGroup.members.includes(memberId));
                  if (newMembers.length > 0) {
                    NotificationSystem.show(`${newMembers.length} new member${newMembers.length > 1 ? 's' : ''} added to your group!`, 'success');
                  }
                }
              }

              // Update local group data
              const currentGroups = DataLayer.load('groups', []);
              const groupIndex = currentGroups.findIndex(g => g.id === group.id);
              if (groupIndex !== -1) {
                currentGroups[groupIndex] = updatedGroup;
                DataLayer.save('groups', currentGroups);
              }
            }
          });

          // Store listener reference for cleanup
          if (!realtimeListeners.groups) realtimeListeners.groups = [];
          realtimeListeners.groups.push(groupListener);
        });

        console.log('Group update real-time listeners initialized');
      } catch (error) {
        console.error('Error initializing group update listeners:', error);
      }
    }


    // Location scheduler: checks every 10 minutes and updates Firebase if moved ≥ 50m
    async function startLocationScheduler() {
      if (!currentFirebaseUser || !authManager) return;
      if (locationSchedulerStarted) return;

      locationSchedulerStarted = true;

      // Initialize location tracking
      let lastKnownLocation = null;
      let locationUpdateInterval = null;

      // Function to calculate distance between two points (Haversine formula)
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c * 1000; // Convert to meters
      }

      // Function to check and update location
      async function checkAndUpdateLocation() {
        if (!navigator.geolocation) return;

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: false,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            });
          });

          const newLocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy
          };

          // Check if location has changed significantly (>= 50m radius)
          if (lastKnownLocation) {
            const distance = calculateDistance(
              lastKnownLocation.lat, lastKnownLocation.lng,
              newLocation.lat, newLocation.lng
            );

            // Only update if moved more than 50 meters
            if (distance >= 50) {
              console.log(`Location changed by ${distance.toFixed(0)}m (>=50m), updating Firebase`);
              await updateUserLocation(newLocation);
              lastKnownLocation = newLocation;
            } else {
              console.log(`Location change too small (${distance.toFixed(0)}m < 50m), not updating`);
            }
          } else {
            // First time getting location
            console.log('Initial location detected, updating Firebase');
            await updateUserLocation(newLocation);
            lastKnownLocation = newLocation;
          }
        } catch (error) {
          console.log('Could not get current location:', error.message);
        }
      }

      // Location update every 10 minutes with 50m threshold
      statusUpdateInterval = setInterval(async () => {
        try {
          await checkAndUpdateLocation();
        } catch (_) { }
      }, 10 * 60 * 1000);
    }

    // Track last status to avoid redundant updates
    let lastUserStatus = { status: null, isActive: null, isOnline: null };
    let lastStatusUpdateTime = 0;
    const STATUS_UPDATE_COOLDOWN = 5000; // 5 seconds minimum between status updates (reduced from 30s)

    // Update user status in Firebase
    async function updateUserStatus(status, isActive, forceUpdate = false) {
      if (!currentFirebaseUser || !authManager || isUpdatingStatus) return;

      isUpdatingStatus = true;

      // Map status to isOnline
      const isOnline = status === 'online' || status === 'inactive';

      // Check cooldown period unless forced
      const now = Date.now();
      if (!forceUpdate && (now - lastStatusUpdateTime) < STATUS_UPDATE_COOLDOWN) {
        console.log('Status update throttled - too soon since last update');
        isUpdatingStatus = false;
        return;
      }

      // Only update if status actually changed (unless forced)
      if (!forceUpdate &&
        lastUserStatus.status === status &&
        lastUserStatus.isActive === isActive &&
        lastUserStatus.isOnline === isOnline) {
        isUpdatingStatus = false;
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        await wrapWrite(
          updateDoc(doc(authManager.db, 'users', currentFirebaseUser.uid), {
            status: status,
            isOnline: isOnline,
            isActive: isActive,
            lastSeen: serverTimestamp(),
            lastStatusUpdate: serverTimestamp()
          }),
          'updateDoc',
          `users/${currentFirebaseUser.uid}`,
          { status, isOnline, isActive }
        );

        // Update our cache of last status
        lastUserStatus = { status, isActive, isOnline };
        lastStatusUpdateTime = now;

        console.log(`User status updated: ${status} (online: ${isOnline}, active: ${isActive})`);
      } catch (error) {
        console.error('Error updating user status:', error);
      } finally {
        isUpdatingStatus = false;
      }
    }

    // Update user location in Firebase
    async function updateUserLocation(location) {
      console.log('updateUserLocation', location);
      if (!currentFirebaseUser || !authManager || !location) return;

      // Validate location object
      if (!location.lat || !location.lng ||
        typeof location.lat !== 'number' ||
        typeof location.lng !== 'number') {
        console.warn('Invalid location data:', location);
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        await wrapWrite(
          updateDoc(doc(authManager.db, 'users', currentFirebaseUser.uid), {
            location: {
              lat: location.lat,
              lng: location.lng,
              accuracy: location.accuracy || null
            },
            lastLocationUpdate: serverTimestamp()
          }),
          'updateDoc',
          `users/${currentFirebaseUser.uid}`,
          { location }
        );

        console.log(`User location updated: ${location.lat}, ${location.lng}`);
      } catch (error) {
        console.error('Error updating user location:', error);
      }
    }

    // Check if user is currently active
    // let isUserActive = !document.hidden && document.hasFocus();

    // Cleanup real-time listeners
    function cleanupRealtimeListeners() {
      if (realtimeListeners.friendRequests) {
        realtimeListeners.friendRequests();
        realtimeListeners.friendRequests = null;
      }

      if (realtimeListeners.outgoingRequests) {
        realtimeListeners.outgoingRequests();
        realtimeListeners.outgoingRequests = null;
      }

      if (realtimeListeners.friendships1) {
        realtimeListeners.friendships1();
        realtimeListeners.friendships1 = null;
      }

      if (realtimeListeners.friendships2) {
        realtimeListeners.friendships2();
        realtimeListeners.friendships2 = null;
      }

      if (realtimeListeners.friendStatuses) {
        Object.values(realtimeListeners.friendStatuses).forEach(unsubscribe => {
          if (typeof unsubscribe === 'function') {
            unsubscribe();
          }
        });
        realtimeListeners.friendStatuses = null;
      }

      if (realtimeListeners.groups) {
        if (Array.isArray(realtimeListeners.groups)) {
          realtimeListeners.groups.forEach(listener => listener());
        } else {
          realtimeListeners.groups();
        }
        realtimeListeners.groups = null;
      }

      if (realtimeListeners.userStatus) {
        realtimeListeners.userStatus();
        realtimeListeners.userStatus = null;
      }

      if (statusUpdateInterval) {
        clearInterval(statusUpdateInterval);
        statusUpdateInterval = null;
      }
      locationSchedulerStarted = false;

      console.log('Real-time listeners cleaned up');
    }
    // Initialize real-time user status listeners (per-user doc listeners for minimal reads)
    async function initializeUserStatusListeners() {
      if (!currentFirebaseUser || !authManager) return;
      if (isUserStatusInitInFlight) return;
      isUserStatusInitInFlight = true;

      try {
        // Clean up any existing friend status doc listeners
        if (!realtimeListeners.friendStatuses) realtimeListeners.friendStatuses = {};
        Object.values(realtimeListeners.friendStatuses).forEach(unsub => {
          if (typeof unsub === 'function') unsub();
        });
        realtimeListeners.friendStatuses = {};

        // Determine which user IDs to watch: friends + incoming + outgoing + visible
        const idsToWatch = new Set();
        if (typeof FriendsDiscoverySystem !== 'undefined') {
          (FriendsDiscoverySystem.currentFriends || []).forEach(u => u?.id && idsToWatch.add(u.id));
          (FriendsDiscoverySystem.friendRequests || []).forEach(r => r?.fromUser?.id && idsToWatch.add(r.fromUser.id));
          (FriendsDiscoverySystem.pendingRequests || []).forEach(r => r?.toUserId && idsToWatch.add(r.toUserId));
        }
        if (additionalPresenceWatchIds && additionalPresenceWatchIds.size > 0) {
          additionalPresenceWatchIds.forEach(id => idsToWatch.add(id));
        }

        // If nothing to watch, skip to avoid unnecessary listeners
        if (idsToWatch.size === 0) {
          console.log('User status listeners initialized (no users to watch)');
          return;
        }

        const { doc, onSnapshot } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        idsToWatch.forEach(userId => {
          if (!userId || userId === currentFirebaseUser.uid) return;
          const userDocRef = doc(authManager.db, 'users', userId);
          const unsub = onSnapshot(userDocRef, (docSnap) => {
            if (!docSnap.exists()) return;
            const userData = docSnap.data();

            // Merge minimal presence fields into allUsers
            if (typeof FriendsDiscoverySystem !== 'undefined') {
              const idx = (FriendsDiscoverySystem.allUsers || []).findIndex(u => u.id === userId);
              const newEntry = {
                id: userId,
                displayName: userData.displayName || 'Unknown User',
                username: userData.username || '',
                avatar: userData.avatar || '?',
                adjustmentFactor: userData.adjustmentFactor || 0,
                personalityType: userData.personalityType || 'Not Set',
                isOnline: userData.isOnline || false,
                isActive: userData.isActive || false,
                status: userData.status || 'offline',
                location: userData.location || null
              };
              if (idx >= 0) {
                FriendsDiscoverySystem.allUsers[idx] = { ...FriendsDiscoverySystem.allUsers[idx], ...newEntry };
              } else {
                FriendsDiscoverySystem.allUsers = [...FriendsDiscoverySystem.allUsers, newEntry];
              }

              // Throttled UI refresh when friendship section is visible
              const friendshipSection = document.getElementById('friendship-section');
              const now = Date.now();
              const isVisible = friendshipSection && friendshipSection.style.display !== 'none';
              const canRefresh = isVisible && now - lastUserStatusUIUpdate >= USER_STATUS_UI_MIN_INTERVAL;
              if (canRefresh) {
                lastUserStatusUIUpdate = now;
                FriendsDiscoverySystem.displayUsers();
              }
            }
          }, (error) => {
            console.error('Error listening to user status doc:', error);
          });
          realtimeListeners.friendStatuses[userId] = unsub;
        });

        console.log('User status listeners initialized for', idsToWatch.size, 'users');
      } catch (error) {
        console.error('Error initializing user status listeners:', error);
      }
      finally {
        isUserStatusInitInFlight = false;
      }
    }

    // Rebuild per-user status listeners when friend lists change
    async function refreshUserStatusListeners() {
      if (!areRealtimeListenersActive) return;
      if (userStatusRefreshTimer) clearTimeout(userStatusRefreshTimer);
      userStatusRefreshTimer = setTimeout(() => {
        initializeUserStatusListeners();
      }, 100);
    }

    // Page-specific update functions
    async function updateOnPageVisit(pageName) {
      if (!currentFirebaseUser || !authManager) return;

      try {
        const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        switch (pageName) {
          case 'dashboard':
            // Update user profile and experiences for dashboard
            const userDoc = await getDoc(doc(authManager.db, 'users', currentFirebaseUser.uid));
            if (userDoc.exists()) {
              const userData = userDoc.data();
              const currentUser = DataLayer.load('currentUser') || {};
              const updatedUser = { ...currentUser, ...userData, id: currentFirebaseUser.uid };
              DataLayer.save('currentUser', updatedUser);
            }

            // Load experiences
            const experiencesCollection = collection(authManager.db, 'experiences');
            const experiencesQuery = query(experiencesCollection, where('userId', '==', currentFirebaseUser.uid));
            const experiencesSnapshot = await getDocs(experiencesQuery);

            const userExperiences = [];
            experiencesSnapshot.forEach((doc) => {
              const experienceData = doc.data();
              userExperiences.push({
                id: experienceData.id || doc.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
                firebaseId: doc.id, // Store Firebase document ID separately
                ...experienceData,
                timestamp: experienceData.createdAt?.toDate?.() || new Date()
              });
            });
            DataLayer.save('userExperiences', userExperiences);

            updateDashboard();
            break;

          case 'feed':
            console.log('🔄 updateOnPageVisit: feed case - initializing FeedSystem');
            // Use paginated feed loader with caching
            await FeedSystem.resetAndLoad();
            // Initialize real-time system for friendship features
            initializeRealtimeSystem();
            break;

          case 'community':
            // Delegate to FriendsDiscoverySystem.init which single-flights loads
            if (typeof FriendsDiscoverySystem !== 'undefined') {
              await FriendsDiscoverySystem.init();
            }
            // Initialize real-time system for friendship features
            initializeRealtimeSystem();
            break;

          case 'groups':
            // Update groups from Firebase
            if (typeof GroupsSystem !== 'undefined') {
              await GroupsSystem.loadGroupsFromFirebase();
              GroupsSystem.displayGroups();
            }
            break;

          case 'profile':
            // Update user profile and experiences for profile page
            const profileUserDoc = await wrapRead(getDoc(doc(authManager.db, 'users', currentFirebaseUser.uid)), 'getDoc', `users/${currentFirebaseUser.uid}`, { source: 'profile' });
            if (profileUserDoc.exists()) {
              const userData = profileUserDoc.data();
              const currentUser = DataLayer.load('currentUser') || {};
              const updatedUser = { ...currentUser, ...userData, id: currentFirebaseUser.uid };
              DataLayer.save('currentUser', updatedUser);
            }

            const profileExperiencesCollection = collection(authManager.db, 'experiences');
            const profileExperiencesQuery = query(profileExperiencesCollection, where('userId', '==', currentFirebaseUser.uid));
            const profileExperiencesSnapshot = await wrapRead(getDocs(profileExperiencesQuery), 'getDocs', 'experiences', { userId: currentFirebaseUser.uid, source: 'profile' });

            const profileUserExperiences = [];
            profileExperiencesSnapshot.forEach((doc) => {
              const experienceData = doc.data();
              profileUserExperiences.push({
                id: experienceData.id || doc.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
                firebaseId: doc.id, // Store Firebase document ID separately
                ...experienceData,
                timestamp: experienceData.createdAt?.toDate?.() || new Date()
              });
            });
            DataLayer.save('userExperiences', profileUserExperiences);

            updateProfile();
            break;
        }

        console.log(`Page-specific update completed for ${pageName}`);
      } catch (error) {
        console.error(`Error in page-specific update for ${pageName}:`, error);
      }
    }

    // Show register form (duplicate removed)
    // function showRegisterForm() {
    //   document.getElementById('login-form-container').style.display = 'none';
    //   document.getElementById('register-form-container').style.display = 'block';
    // }

    // Show login form (duplicate removed)
    // function showLoginForm() {
    //   document.getElementById('register-form-container').style.display = 'none';
    //   document.getElementById('login-form-container').style.display = 'block';

    //   // Reset to step 1
    //   document.getElementById('login-step-1').style.display = 'block';
    //   document.getElementById('login-step-2').style.display = 'none';
    //   document.getElementById('login-email').value = '';
    //   document.getElementById('login-password').value = '';

    //   // Reset password visibility
    //   const passwordToggle = document.querySelector('.password-toggle-btn i');
    //   if (passwordToggle) {
    //     passwordToggle.className = 'fas fa-eye';
    //   }
    // }

    // Profile editing functionality
    function showEditProfileModal() {
      const currentUser = DataLayer.load('currentUser');

      const modalHtml = `
        <div id="edit-profile-modal" class="modal">
          <div class="modal-content" style="max-width: 500px;">
            <button class="modal-close" onclick="closeEditProfileModal()">&times;</button>
            <div class="modal-header">
              <h2>Edit Profile</h2>
            </div>
            <div class="modal-body">
              <form id="edit-profile-form" onsubmit="handleEditProfile(event)">
                <div class="form-group">
                  <label for="edit-display-name">Display Name *</label>
                  <input type="text" id="edit-display-name" class="form-control" value="${currentUser?.displayName || ''}" required>
                </div>
                <div class="form-group">
                  <label for="edit-username">Username *</label>
                  <input type="text" id="edit-username" class="form-control" value="${currentUser?.username || ''}" required>
                </div>
                <div class="form-group">
                  <label for="edit-bio">Bio</label>
                  <textarea id="edit-bio" class="form-control" rows="3" placeholder="Tell us about yourself...">${currentUser?.bio || ''}</textarea>
                </div>
                <div style="text-align: center; margin-top: 2rem;">
                  <button type="submit" class="btn">Save Changes</button>
                  <button type="button" class="btn btn-secondary" onclick="closeEditProfileModal()">Cancel</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML("beforeend", modalHtml);
      addModalListeners("edit-profile-modal", closeEditProfileModal);
    }

    function closeEditProfileModal() {
      const modal = document.getElementById("edit-profile-modal");
      if (modal) modal.remove();
      document.body.classList.remove('modal-open');
    }

    async function handleEditProfile(event) {
      event.preventDefault();

      const displayName = document.getElementById('edit-display-name').value.trim();
      const username = document.getElementById('edit-username').value.trim();
      const bio = document.getElementById('edit-bio').value.trim();

      if (!displayName || !username) {
        NotificationSystem.show('Display name and username are required.', 'error');
        return;
      }

      try {
        const currentUser = DataLayer.load('currentUser');
        const updatedUser = {
          ...currentUser,
          displayName,
          username,
          bio: bio || null,
          avatar: displayName.charAt(0).toUpperCase()
        };

        // Update local data
        DataLayer.save('currentUser', updatedUser);

        // Update Firebase if authenticated
        if (currentFirebaseUser && authManager) {
          const { doc, updateDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          await updateDoc(doc(authManager.db, 'users', currentFirebaseUser.uid), {
            displayName,
            username,
            bio: bio || null,
            avatar: displayName.charAt(0).toUpperCase(),
            updatedAt: serverTimestamp()
          });
        }

        closeEditProfileModal();
        NotificationSystem.show('Profile updated successfully!', 'success');

        // Refresh profile display
        updateProfile();
        updateDashboard();
      } catch (error) {
        console.error('Error updating profile:', error);
        NotificationSystem.show('Failed to update profile. Please try again.', 'error');
      }
    }

    // Optimized Friends Discovery and Management System
    const FriendsDiscoverySystem = {
      currentFilter: 'all',
      allUsers: [],
      currentFriends: [],
      friendRequests: [],
      pendingRequests: [],
      isInitialized: false,
      isLoading: false,
      isInitializing: false, // Prevent initialization loops

      // Initialize the system - Only called when friendship tab is clicked
      async init() {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to view friends.', 'warning');
          return;
        }

        // Prevent multiple simultaneous initializations
        if (this.isLoading || this.isInitializing || this._initInFlight) {
          console.log('Friends system already loading or initializing, skipping init');
          return;
        }

        // Check if already initialized and cache is fresh
        if (this.isInitialized && !this.isCacheExpired()) {
          console.log('Using cached friends data');
          this.displayUsers();
          return;
        }

        // Singleflight guard
        this._initInFlight = true;
        // Show loading state
        this.isLoading = true;
        this.isInitializing = true;
        this.showLoadingState();

        try {
          console.log('🔄 Initializing FriendsDiscoverySystem...');

          // Initialize arrays if they don't exist
          if (!Array.isArray(this.allUsers)) this.allUsers = [];
          if (!Array.isArray(this.currentFriends)) this.currentFriends = [];
          if (!Array.isArray(this.friendRequests)) this.friendRequests = [];
          if (!Array.isArray(this.pendingRequests)) this.pendingRequests = [];

          // Load data with aggressive caching
          await this.loadAllUsersOptimized();
          await this.loadCurrentFriendsOptimized();
          await this.loadFriendRequests();
          await this.loadPendingRequests();

          this.isInitialized = true;
          console.log('✅ FriendsDiscoverySystem initialized successfully');
          this.displayUsers();
          this.startRequestCheck();
        } catch (error) {
          console.error('Error initializing friends system:', error);
          NotificationSystem.show('Failed to load friends data.', 'error');

          // Set default empty arrays on error
          this.allUsers = [];
          this.currentFriends = [];
          this.friendRequests = [];
          this.pendingRequests = [];
          this.displayUsers();
        } finally {
          this.isLoading = false;
          this.isInitializing = false;
          this._initInFlight = false;
          this.hideLoadingState();
        }
      },

      // Check if cache is expired
      isCacheExpired() {
        const cache = DataLayer.load('friends_cache_timestamp', 0);
        const now = Date.now();
        return (now - cache) > CacheSystem.CACHE_DURATIONS.FRIENDS;
      },

      // Show loading state
      showLoadingState() {
        const content = document.getElementById('friends-content');
        if (content) {
          content.innerHTML = `
            <div style="text-align: center; padding: 2rem;">
              <div class="loading-spinner"></div>
              <p style="margin-top: 1rem; color: var(--muted-text-color);">Loading friends...</p>
            </div>
          `;
        }
      },

      // Hide loading state
      hideLoadingState() {
        // Will be replaced by actual content
      },

      // Queue user for background loading
      queueUserForLoading(userId) {
        if (!this._userLoadingQueue) {
          this._userLoadingQueue = new Set();
        }
        if (!this._userLoadingQueue.has(userId)) {
          this._userLoadingQueue.add(userId);
          // Process queue in background
          this._processUserLoadingQueue();
        }
      },

      // Process user loading queue
      async _processUserLoadingQueue() {
        if (this._processingQueue || !this._userLoadingQueue || this._userLoadingQueue.size === 0) {
          return;
        }

        this._processingQueue = true;
        const userIds = Array.from(this._userLoadingQueue);
        this._userLoadingQueue.clear();

        try {
          const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const usersCollection = collection(authManager.db, 'users');
          const q = query(usersCollection, where('__name__', 'in', userIds));
          const snapshot = await getDocs(q);

          snapshot.forEach((docSnap) => {
            const userData = docSnap.data();
            const user = {
              id: docSnap.id,
              displayName: userData.displayName || 'Unknown User',
              username: userData.username || '',
              avatar: userData.avatar || '?',
              adjustmentFactor: userData.adjustmentFactor || 0,
              personalityType: userData.personalityType || 'Not Set',
              isPremium: userData.isPremium || false
            };

            // Cache user data individually for faster lookups
            CacheSystem.set(`USER_${user.id}`, user);

            // Add to allUsers array
            if (Array.isArray(this.allUsers)) {
              const existingIndex = this.allUsers.findIndex(u => u.id === user.id);
              if (existingIndex >= 0) {
                this.allUsers[existingIndex] = user;
              } else {
                this.allUsers.push(user);
              }
            }
          });

          // Trigger feed refresh to show updated user data
          if (typeof FeedSystem !== 'undefined' && FeedSystem.displayFeed) {
            setTimeout(() => FeedSystem.displayFeed(), 100);
          }

          console.log('✅ Loaded and cached', snapshot.size, 'users from queue');
        } catch (error) {
          console.error('Error processing user loading queue:', error);
        } finally {
          this._processingQueue = false;
        }
      },

      // Load all users from Firebase with aggressive caching (server-side pagination: 20 per page)
      async loadAllUsersOptimized() {
        if (this._loadUsersInFlight) return;
        this._loadUsersInFlight = true;
        // Check cache first
        const cached = CacheSystem.get('ALL_USERS_PAGINATED', CacheSystem.CACHE_DURATIONS.ALL_USERS_BASIC);
        if (cached && Array.isArray(cached.items)) {
          this.allUsers = cached.items;
          this._usersPageCursor = cached.lastCursorValue || null;
          this._usersHasMore = !!cached.hasMore;
          console.log('Using cached paginated users:', this.allUsers.length);
          this._loadUsersInFlight = false;
          return;
        }

        try {
          console.log('Loading first users page from Firebase (paginated)...');
          const { collection, query, orderBy, limit, startAfter, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const usersCollection = collection(authManager.db, 'users');
          let q = query(usersCollection, orderBy('createdAt', 'desc'), limit(20));
          const snapshot = await wrapRead(getDocs(q), 'getDocs', 'users', { source: 'friendsDiscovery', paginated: true });

          this.allUsers = [];
          snapshot.forEach((docSnap) => {
            const userData = docSnap.data();
            if (docSnap.id !== currentFirebaseUser.uid) {
              this.allUsers.push({
                id: docSnap.id,
                displayName: userData.displayName || 'Unknown User',
                username: userData.username || '',
                avatar: userData.avatar || '?',
                adjustmentFactor: userData.adjustmentFactor || 0,
                personalityType: userData.personalityType || 'Not Set',
                status: userData.status || 'offline',
                isActive: userData.isActive || false,
                isOnline: userData.isOnline || false,
                location: userData.location || null
              });
            }
          });

          this._usersPageCursor = snapshot.docs[snapshot.docs.length - 1]?.data()?.createdAt || null;
          this._usersHasMore = snapshot.size === 20;

          CacheSystem.set('ALL_USERS_PAGINATED', {
            items: this.allUsers,
            lastCursorValue: this._usersPageCursor,
            hasMore: this._usersHasMore
          });
          console.log('Loaded and cached first users page:', this.allUsers.length);
        } catch (error) {
          console.error('Error loading users:', error);
          this.allUsers = [];
        } finally {
          this._loadUsersInFlight = false;
        }
      },

      async loadMoreUsers() {
        if (!this._usersHasMore || this._usersLoadingMore) return;
        if (!currentFirebaseUser || !authManager) return;
        this._usersLoadingMore = true;
        try {
          const { collection, query, orderBy, limit, startAfter, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const usersCollection = collection(authManager.db, 'users');
          let q = query(usersCollection, orderBy('createdAt', 'desc'), limit(20));
          if (this._usersPageCursor) {
            q = query(q, startAfter(this._usersPageCursor));
          }
          const snapshot = await wrapRead(getDocs(q), 'getDocs', 'users', { paginated: true });
          const page = [];
          snapshot.forEach((docSnap) => {
            const userData = docSnap.data();
            if (docSnap.id !== currentFirebaseUser.uid) {
              page.push({
                id: docSnap.id,
                displayName: userData.displayName || 'Unknown User',
                username: userData.username || '',
                avatar: userData.avatar || '?',
                adjustmentFactor: userData.adjustmentFactor || 0,
                personalityType: userData.personalityType || 'Not Set',
                status: userData.status || 'offline',
                isActive: userData.isActive || false,
                isOnline: userData.isOnline || false,
                location: userData.location || null
              });
            }
          });

          this.allUsers = [...this.allUsers, ...page];
          this._usersPageCursor = snapshot.docs[snapshot.docs.length - 1]?.data()?.createdAt || this._usersPageCursor;
          this._usersHasMore = snapshot.size === 20;
          CacheSystem.set('ALL_USERS_PAGINATED', {
            items: this.allUsers,
            lastCursorValue: this._usersPageCursor,
            hasMore: this._usersHasMore
          });
          this.displayUsers();
        } catch (error) {
          console.error('Error loading more users:', error);
        } finally {
          this._usersLoadingMore = false;
        }
      },

      // Legacy function for compatibility
      async loadAllUsers() {
        return this.loadAllUsersOptimized();
      },

      // Load current friends with caching
      async loadCurrentFriendsOptimized() {
        // Check cache first
        const cachedFriends = CacheSystem.get('FRIENDS', CacheSystem.CACHE_DURATIONS.FRIENDS);
        if (cachedFriends) {
          this.currentFriends = cachedFriends;
          console.log('Using cached friends:', this.currentFriends.length);
          return;
        }

        try {
          console.log('Loading friends from Firebase...');
          const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid)),
            query(friendsCollection, where('user2Id', '==', currentFirebaseUser.uid))
          ];

          this.currentFriends = [];
          const friendIds = new Set();

          for (const q of queries) {
            const querySnapshot = await wrapRead(getDocs(q), 'getDocs', 'friends', {});

            for (const docSnap of querySnapshot.docs) {
              const friendshipData = docSnap.data();
              const friendId = friendshipData.user1Id === currentFirebaseUser.uid
                ? friendshipData.user2Id
                : friendshipData.user1Id;

              if (!friendIds.has(friendId)) {
                friendIds.add(friendId);

                const friendDoc = await wrapRead(getDoc(doc(authManager.db, 'users', friendId)), 'getDoc', `users/${friendId}`, {});
                if (friendDoc.exists()) {
                  const friendData = friendDoc.data();
                  this.currentFriends.push({
                    id: friendDoc.id,
                    displayName: friendData.displayName || 'Unknown User',
                    username: friendData.username || '',
                    avatar: friendData.avatar || '?',
                    adjustmentFactor: friendData.adjustmentFactor || 0,
                    personalityType: friendData.personalityType || 'Not Set',
                    status: friendData.status || 'offline',
                    isActive: friendData.isActive || false,
                    location: friendData.location || null,
                    bio: friendData.bio || ''
                  });
                }
              }
            }
          }

          // Cache the data
          CacheSystem.set('FRIENDS', this.currentFriends);
          console.log('Loaded and cached friends:', this.currentFriends.length);
        } catch (error) {
          console.error('Error loading friends:', error);
          this.currentFriends = [];
        }
      },

      // Legacy function for compatibility
      async loadCurrentFriends() {
        return this.loadCurrentFriendsOptimized();
      },

      // Load friend requests
      async loadFriendRequests() {
        try {
          const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const requestsCollection = collection(authManager.db, 'friendRequests');
          const requestsQuery = query(requestsCollection, where('toUserId', '==', currentFirebaseUser.uid), where('status', '==', 'pending'));
          const querySnapshot = await getDocs(requestsQuery);

          this.friendRequests = [];
          for (const docSnap of querySnapshot.docs) {
            const requestData = docSnap.data();
            const fromUserDoc = await getDoc(doc(authManager.db, 'users', requestData.fromUserId));
            if (fromUserDoc.exists()) {
              this.friendRequests.push({
                requestId: docSnap.id,
                fromUser: {
                  id: fromUserDoc.id,
                  ...fromUserDoc.data()
                },
                createdAt: requestData.createdAt
              });
            }
          }

          console.log('Loaded friend requests:', this.friendRequests.length);
          this.updateFriendRequestBadge();
        } catch (error) {
          console.error('Error loading friend requests:', error);
          this.friendRequests = [];
        }
      },

      // Load pending requests sent by current user
      async loadPendingRequests() {
        try {
          const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const requestsCollection = collection(authManager.db, 'friendRequests');
          const requestsQuery = query(requestsCollection, where('fromUserId', '==', currentFirebaseUser.uid), where('status', '==', 'pending'));
          const querySnapshot = await getDocs(requestsQuery);

          this.pendingRequests = [];
          for (const docSnap of querySnapshot.docs) {
            const requestData = docSnap.data();
            this.pendingRequests.push({
              requestId: docSnap.id,
              toUserId: requestData.toUserId,
              createdAt: requestData.createdAt
            });
          }

          console.log('Loaded pending requests:', this.pendingRequests.length);
        } catch (error) {
          console.error('Error loading pending requests:', error);
          this.pendingRequests = [];
        }
      },

      // Set filter
      async setFilter(filter) {
        this.currentFilter = filter;

        // Update active dropdown items instead of tabs
        document.querySelectorAll('#friendship-filter-menu .filter-dropdown-item').forEach(item => {
          item.classList.remove('active');
        });

        // Find and activate the correct dropdown item
        const filterMap = {
          'all': 'All Users',
          'similar': 'Similar to You',
          'friends': 'My Friends',
          'requests': 'Friend Requests'
        };

        const filterText = filterMap[filter] || 'All Users';
        const targetItem = Array.from(document.querySelectorAll('#friendship-filter-menu .filter-dropdown-item'))
          .find(item => item.textContent.trim().includes(filterText));

        if (targetItem) {
          targetItem.classList.add('active');
          // Update button text
          const textElement = document.getElementById('friendship-filter-text');
          if (textElement) {
            textElement.textContent = filterText;
          }
        }

        // When switching to 'friends', ensure we have fresh data
        if (filter === 'friends') {
          console.log('Switching to My Friends - refreshing friends data');
          // Force fresh friends data by invalidating cache
          CacheSystem.invalidateFriendsCache();
          await this.loadCurrentFriendsOptimized();
          console.log('Friends data refreshed:', this.currentFriends.length, 'friends found');
        }

        this.displayUsers();
      },

      // Filter users based on search with debounce
      filterUsers() {
        // Clear any existing timeout
        if (this.filterTimeout) {
          clearTimeout(this.filterTimeout);
        }

        // Debounce the filter to prevent excessive calls
        this.filterTimeout = setTimeout(() => {
          this.displayUsers();
        }, 300);
      },

      // Display users based on current filter with debounce
      displayUsers() {
        // Prevent excessive calls
        if (this.displayTimeout) {
          clearTimeout(this.displayTimeout);
        }

        this.displayTimeout = setTimeout(() => {
          this._displayUsersInternal();
        }, 100);
      },

      // Internal display function with safety checks
      _displayUsersInternal() {
        // Prevent recursive calls
        if (this.isDisplaying) return;
        this.isDisplaying = true;

        try {
          const searchTerm = document.getElementById('friends-search')?.value?.toLowerCase() || '';
          let usersToDisplay = [];

          // Ensure arrays exist and are valid
          if (!Array.isArray(this.allUsers)) this.allUsers = [];
          if (!Array.isArray(this.currentFriends)) this.currentFriends = [];
          if (!Array.isArray(this.friendRequests)) this.friendRequests = [];

          switch (this.currentFilter) {
            case 'all':
              usersToDisplay = this.allUsers.filter(user =>
                user && (
                  (user.displayName && user.displayName.toLowerCase().includes(searchTerm)) ||
                  (user.username && user.username.toLowerCase().includes(searchTerm)) ||
                  (user.personalityType && user.personalityType.toLowerCase().includes(searchTerm))
                )
              );
              break;
            case 'similar':
              const currentUser = DataLayer.load('currentUser');
              if (currentUser && currentUser.adjustmentFactor !== undefined) {
                usersToDisplay = this.allUsers.filter(user => {
                  if (!user || user.adjustmentFactor === undefined) return false;
                  const personalityDiff = Math.abs(user.adjustmentFactor - currentUser.adjustmentFactor);
                  return personalityDiff <= 0.3 && // Similar personality
                    (
                      (user.displayName && user.displayName.toLowerCase().includes(searchTerm)) ||
                      (user.username && user.username.toLowerCase().includes(searchTerm))
                    );
                });
              }
              break;
            case 'friends':
              usersToDisplay = this.currentFriends.filter(user =>
                user && (
                  (user.displayName && user.displayName.toLowerCase().includes(searchTerm)) ||
                  (user.username && user.username.toLowerCase().includes(searchTerm))
                )
              );
              break;
            case 'requests':
              usersToDisplay = this.friendRequests
                .filter(request => request && request.fromUser)
                .map(request => request.fromUser)
                .filter(user =>
                  user && (
                    (user.displayName && user.displayName.toLowerCase().includes(searchTerm)) ||
                    (user.username && user.username.toLowerCase().includes(searchTerm))
                  )
                );
              break;
          }

          // Compute visible user IDs for presence subscriptions
          additionalPresenceWatchIds = new Set(usersToDisplay.slice(0, 20).map(u => u.id));
          refreshUserStatusListeners();

          // Apply client pagination for filtered list (UI only)
          const PAGE_SIZE = 10;
          this.currentPage = this.currentPage || 1;
          const totalItems = usersToDisplay.length;
          const totalPages = Math.max(1, Math.ceil(totalItems / PAGE_SIZE));
          if (this.currentPage > totalPages) this.currentPage = totalPages;
          const start = (this.currentPage - 1) * PAGE_SIZE;
          const pageItems = usersToDisplay.slice(start, start + PAGE_SIZE);

          this.renderUsers(pageItems, totalPages);
        } catch (error) {
          console.error('Error in _displayUsersInternal:', error);
        } finally {
          this.isDisplaying = false;
        }
      },

      // Render users in the UI
      renderUsers(users, totalPages = 1) {
        const container = document.getElementById('friendship-content');

        // Ensure users is an array
        if (!Array.isArray(users)) {
          console.warn('renderUsers called with non-array:', users);
          users = [];
        }

        if (users.length === 0) {
          let message = '';
          switch (this.currentFilter) {
            case 'all':
              message = 'No users found matching your search.';
              break;
            case 'similar':
              message = 'No users with similar personality found.';
              break;
            case 'friends':
              message = 'You haven\'t added any friends yet.';
              break;
            case 'requests':
              message = 'No pending friend requests.';
              break;
          }

          container.innerHTML = `
            <div style="text-align: center; padding: 3rem 1rem; color: #666;">
              <div style="font-size: 3rem; color: #ddd; margin-bottom: 1rem;">👥</div>
              <h3>${message}</h3>
            </div>
          `;
          return;
        }

        const usersHtml = users.map(user => {
          // Ensure user has valid ID and arrays exist
          if (!user || !user.id) {
            console.warn('Skipping user without valid ID:', user);
            return '';
          }

          // Ensure arrays exist and are valid
          if (!Array.isArray(this.currentFriends)) this.currentFriends = [];
          if (!Array.isArray(this.friendRequests)) this.friendRequests = [];
          if (!Array.isArray(this.pendingRequests)) this.pendingRequests = [];

          const isFriend = this.currentFriends.some(friend => friend && friend.id && friend.id === user.id);
          const hasRequest = this.friendRequests.some(request => request && request.fromUser && request.fromUser.id && request.fromUser.id === user.id);
          const hasPendingRequest = this.pendingRequests.some(request => request && request.toUserId && request.toUserId === user.id);

          return `
            <div class="user-card" data-user-id="${user.id}" style="
              border: 1px solid #eee; 
              border-radius: 12px; 
              padding: 1.5rem; 
              background: white;
              box-shadow: 0 2px 8px rgba(0,0,0,0.05);
              margin-bottom: 1rem;
              transition: transform 0.2s ease, box-shadow 0.2s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" 
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.05)'">
              
              <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <div style="display: flex; align-items: center; gap: 1rem;">
                  <div style="width: 50px; height: 50px; border-radius: 50%; background: var(--secondary-gradient); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.2rem;">
                    ${user.avatar || user.displayName?.charAt(0) || '?'}
                  </div>
                  <div>
                    <h3 style="margin: 0 0 0.3rem 0; font-size: 1.1rem;">${addOnlineStatusIndicator(user.displayName || 'Unknown User', user.id, user.isOnline, user.isActive)}</h3>
                    <p style="margin: 0; color: #666; font-size: 0.9rem;">@${user.username || 'unknown'}</p>
                    <p style="margin: 0.3rem 0 0 0; color: var(--secondary-color); font-size: 0.8rem; font-weight: bold;">
                      ${user.personalityType || 'Not Set'}
                    </p>
                  </div>
                </div>
                
                <div class="user-actions" style="text-align: right;">
                  ${this.getActionButton(user, isFriend, hasRequest, hasPendingRequest)}
                </div>
              </div>
              
              ${user.bio && user.bio !== 'undefined' ? `
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                  <p style="margin: 0; color: #666; font-style: italic;">"${user.bio}"</p>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');

        const pagination = this._renderPagination(totalPages);
        container.innerHTML = usersHtml + pagination + (this._usersHasMore ? `
          <div style=\"display:flex; justify-content:center; margin:8px 0 24px;\">
            <button class=\"btn btn-secondary\" onclick=\"FriendsDiscoverySystem.loadMoreUsers()\">Load More Users</button>
          </div>
        ` : '');

        // After render, expand presence watch list to currently rendered cards as well
        try {
          const cards = Array.from(document.querySelectorAll('.user-card')) || [];
          additionalPresenceWatchIds = new Set(cards.map(card => card.getAttribute('data-user-id')).filter(Boolean));
          refreshUserStatusListeners();
        } catch (_) { }
      },

      _renderPagination(totalPages) {
        if (totalPages <= 1) return '';
        const prevDisabled = (this.currentPage || 1) <= 1 ? 'disabled' : '';
        const nextDisabled = (this.currentPage || 1) >= totalPages ? 'disabled' : '';
        const prevPage = Math.max(1, (this.currentPage || 1) - 1);
        const nextPage = Math.min(totalPages, (this.currentPage || 1) + 1);
        return `
          <div style="display:flex; justify-content:center; align-items:center; gap:8px; margin:16px 0;">
            <button class="btn btn-secondary" ${prevDisabled} onclick="FriendsDiscoverySystem.gotoPage(${prevPage})">Prev</button>
            <span>Page ${this.currentPage || 1} of ${totalPages}</span>
            <button class="btn btn-secondary" ${nextDisabled} onclick="FriendsDiscoverySystem.gotoPage(${nextPage})">Next</button>
          </div>
        `;
      },

      gotoPage(page) {
        this.currentPage = page;
        this.displayUsers();
      },

      // Get appropriate action button for user
      getActionButton(user, isFriend, hasRequest, hasPendingRequest) {
        // Respect local cooldowns to prevent rapid re-requests
        if (this.isInCooldown(user.id)) {
          return `
            <button class="btn" style="font-size: 0.8rem; padding: 6px 12px; background: #e5e7eb; color: #6b7280; border: 1px solid #d1d5db;" disabled>
              <i class="fas fa-hourglass-half"></i> Try again soon
            </button>
          `;
        }
        if (isFriend) {
          return `
            <div style="text-align: center;">
              <span style="background: rgba(74, 144, 226, 0.1); color: var(--primary-color); font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 12px; border: 1px solid var(--primary-color); display: inline-block;">✓ Friend</span>
              <br>
              <button class="btn btn-danger" style="font-size: 0.8rem; padding: 4px 8px; margin-top: 0.5rem;" onclick="FriendsDiscoverySystem.removeFriend('${user.id}')">
                Remove
              </button>
            </div>
          `;
        } else if (hasRequest) {
          return `
            <div style="text-align: center;">
              <button class="btn btn-success" style="font-size: 0.8rem; padding: 4px 8px; margin: 0.2rem;" onclick="FriendsDiscoverySystem.acceptRequest('${user.id}')">
                Accept
              </button>
              <br>
              <button class="btn btn-danger" style="font-size: 0.8rem; padding: 4px 8px;" onclick="FriendsDiscoverySystem.rejectRequest('${user.id}')">
                Decline
              </button>
            </div>
          `;
        } else if (hasPendingRequest) {
          return `
            <button class="btn" data-pending-for="${user.id}" style="font-size: 0.8rem; padding: 6px 12px; background: #fbbf24; color: #1f2937; border: 1px solid #f59e0b;" onclick="FriendsDiscoverySystem.cancelPendingRequest('${user.id}')">
              <i class="fas fa-clock"></i> Pending
            </button>
          `;
        } else {
          return `
            <button class="btn" style="font-size: 0.8rem; padding: 6px 12px;" onclick="FriendsDiscoverySystem.sendFriendRequest('${user.id}')">
              Add Friend
            </button>
          `;
        }
      },

      // Send friend request
      async sendFriendRequest(userId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to send friend requests.', 'warning');
          return;
        }

        // Guard: prevent duplicate clicks or requests while pending/cooldown
        if (this.isInCooldown(userId) || this.pendingRequests.some(r => r.toUserId === userId)) {
          return;
        }

        try {
          const { collection, addDoc, serverTimestamp, query, where, getDocs, limit } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const requestData = {
            fromUserId: currentFirebaseUser.uid,
            toUserId: userId,
            status: 'pending',
            createdAt: serverTimestamp()
          };

          // Preflight: avoid composite indexes by using single-field queries and client filtering
          const requestsCollection = collection(authManager.db, 'friendRequests');
          const fiveMinutesMs = 5 * 60 * 1000;

          // Outgoing: only filter by fromUserId (single field), then narrow in-memory
          const outgoingQ = query(requestsCollection, where('fromUserId', '==', currentFirebaseUser.uid), limit(20));
          const outgoingSnap = await getDocs(outgoingQ);

          // Incoming: only filter by fromUserId of the other user (single field), then narrow in-memory
          const incomingQ = query(requestsCollection, where('fromUserId', '==', userId), limit(20));
          const incomingSnap = await getDocs(incomingQ);

          const now = Date.now();
          const hasBlocking = (snap, targetToUserId) => {
            const relevant = snap.docs
              .map(d => d.data())
              .filter(d => d.toUserId === targetToUserId);
            if (relevant.length === 0) return false;
            // Any pending blocks; recent rejected (5m) also blocks
            const pendingExists = relevant.some(d => d.status === 'pending');
            if (pendingExists) return true;
            const latestRejected = relevant
              .filter(d => d.status === 'rejected' && d.createdAt)
              .reduce((max, d) => Math.max(max, d.createdAt.toDate ? d.createdAt.toDate().getTime() : 0), 0);
            return latestRejected > 0 && (now - latestRejected) < fiveMinutesMs;
          };

          const blocked = hasBlocking(outgoingSnap, userId) || hasBlocking(incomingSnap, currentFirebaseUser.uid);

          if (blocked) {
            this.setCooldown(userId, fiveMinutesMs);
            NotificationSystem.show('Please wait before sending another request.', 'info');
            this.displayUsers();
            return;
          }

          await wrapWrite(
            addDoc(collection(authManager.db, 'friendRequests'), requestData),
            'addDoc',
            'friendRequests',
            { toUserId: userId }
          );

          NotificationSystem.show('Friend request sent!', 'success');

          // Update the button to show "Pending" with yellow background
          const button = document.querySelector(`[onclick="FriendsDiscoverySystem.sendFriendRequest('${userId}')"]`);
          if (button) {
            button.innerHTML = '<i class="fas fa-clock"></i> Pending';
            button.style.background = '#fbbf24';
            button.style.color = '#1f2937';
            button.style.border = '1px solid #f59e0b';
            button.setAttribute('data-pending-for', userId);
            button.onclick = () => FriendsDiscoverySystem.cancelPendingRequest(userId);
          }

          // Update local pending list to avoid reads
          this.pendingRequests = [...(this.pendingRequests || []), { toUserId: userId, requestId: null, createdAt: new Date() }];
          this.displayUsers(); // minimal refresh
        } catch (error) {
          console.error('Error sending friend request:', error);
          NotificationSystem.show('Failed to send friend request.', 'error');
        }
      },

      // Cancel an outgoing pending friend request
      async cancelPendingRequest(userId) {
        try {
          const { collection, query, where, getDocs, deleteDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
          const requestsCollection = collection(authManager.db, 'friendRequests');
          // Find pending requests from me to this user
          const q = query(requestsCollection, where('fromUserId', '==', currentFirebaseUser.uid), where('toUserId', '==', userId), where('status', '==', 'pending'));
          const snapshot = await getDocs(q);
          for (const d of snapshot.docs) {
            await deleteDoc(doc(authManager.db, 'friendRequests', d.id));
          }

          // Update local state
          this.pendingRequests = (this.pendingRequests || []).filter(r => r.toUserId !== userId);
          NotificationSystem.show('Friend request canceled.', 'info');
          this.displayUsers();

          // Also update any buttons on activity/feed cards
          const buttons = document.querySelectorAll(`[data-pending-for="${userId}"]`);
          buttons.forEach(btn => {
            btn.innerHTML = 'Add Friend';
            btn.style.background = '';
            btn.style.color = '';
            btn.style.border = '';
            btn.removeAttribute('data-pending-for');
            btn.onclick = () => FriendsSystem.addFriend(userId);
          });
        } catch (error) {
          console.error('Error canceling pending request:', error);
          NotificationSystem.show('Failed to cancel request.', 'error');
        }
      },

      // Accept friend request with proper real-time updates
      async acceptRequest(userId) {
        try {
          const { collection, query, where, getDocs, updateDoc, doc, serverTimestamp, addDoc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Find the request
          const requestsCollection = collection(authManager.db, 'friendRequests');
          const requestQuery = query(requestsCollection, where('fromUserId', '==', userId), where('toUserId', '==', currentFirebaseUser.uid));
          const requestSnapshot = await getDocs(requestQuery);

          if (!requestSnapshot.empty) {
            const requestDoc = requestSnapshot.docs[0];
            const requestData = requestDoc.data();

            // Step 1: Update request status to 'accepted' (this triggers real-time listeners)
            await wrapWrite(
              updateDoc(doc(authManager.db, 'friendRequests', requestDoc.id), {
                status: 'accepted',
                acceptedAt: serverTimestamp()
              }),
              'updateDoc',
              `friendRequests/${requestDoc.id}`,
              { status: 'accepted' }
            );

            // Step 2: Create friendship record (this also triggers real-time listeners)
            await wrapWrite(
              addDoc(collection(authManager.db, 'friends'), {
                user1Id: requestData.fromUserId,
                user2Id: requestData.toUserId,
                createdAt: serverTimestamp()
              }),
              'addDoc',
              'friends',
              { user1Id: requestData.fromUserId, user2Id: requestData.toUserId }
            );

            // Invalidate friend-related caches BEFORE reloading
            CacheSystem.invalidateFriendsCache();

            NotificationSystem.show('Friend request accepted!', 'success');

            // Force immediate cache invalidation and reload
            this.isInitialized = false; // Force complete re-initialization

            // Clear all arrays to force fresh load
            this.currentFriends = [];
            this.friendRequests = [];
            this.pendingRequests = [];

            // Force immediate fresh reload from Firebase (not cache)
            await this.loadCurrentFriendsOptimized();
            await this.loadFriendRequests();
            await this.loadPendingRequests();

            // Force complete UI refresh
            this.displayUsers();

            // Delay refresh to ensure Firebase propagation
            setTimeout(async () => {
              console.log('Delayed refresh after friend acceptance');
              await this.loadCurrentFriendsOptimized();
              this.displayUsers();
            }, 2000);

            console.log('Friend request accepted, UI updated immediately');
          }
        } catch (error) {
          console.error('Error accepting friend request:', error);
          NotificationSystem.show('Failed to accept friend request.', 'error');
        }
      },

      // Reject friend request
      async rejectRequest(userId) {
        try {
          const { collection, query, where, getDocs, updateDoc, doc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const requestsCollection = collection(authManager.db, 'friendRequests');
          const requestQuery = query(requestsCollection, where('fromUserId', '==', userId), where('toUserId', '==', currentFirebaseUser.uid));
          const requestSnapshot = await getDocs(requestQuery);

          if (!requestSnapshot.empty) {
            const requestDoc = requestSnapshot.docs[0];
            await wrapWrite(
              updateDoc(doc(authManager.db, 'friendRequests', requestDoc.id), {
                status: 'rejected',
                rejectedAt: serverTimestamp()
              }),
              'updateDoc',
              `friendRequests/${requestDoc.id}`,
              { status: 'rejected' }
            );
          }

          NotificationSystem.show('Friend request declined.', 'info');

          // Local cooldown for 5 minutes to prevent spam re-requests
          this.setCooldown(userId, 5 * 60 * 1000);
          // Update local lists
          this.friendRequests = (this.friendRequests || []).filter(r => r.fromUser?.id !== userId);
          this.pendingRequests = (this.pendingRequests || []).filter(r => r.toUserId !== userId);
          this.displayUsers();
        } catch (error) {
          console.error('Error rejecting friend request:', error);
          NotificationSystem.show('Failed to reject friend request.', 'error');
        }
      },

      // Remove friend
      async removeFriend(userId) {
        try {
          const { collection, query, where, getDocs, deleteDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid), where('user2Id', '==', userId)),
            query(friendsCollection, where('user1Id', '==', userId), where('user2Id', '==', currentFirebaseUser.uid))
          ];

          for (const q of queries) {
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
              const friendshipDoc = querySnapshot.docs[0];
              await deleteDoc(doc(authManager.db, 'friends', friendshipDoc.id));
            }
          }

          NotificationSystem.show('Friend removed successfully!', 'success');

          // Force immediate UI update
          await this.loadCurrentFriendsOptimized();
          await this.loadFriendRequests();
          await this.loadPendingRequests();
          this.displayUsers();
        } catch (error) {
          console.error('Error removing friend:', error);
          NotificationSystem.show('Failed to remove friend.', 'error');
        }
      },

      // Update friend request badge
      updateFriendRequestBadge() {
        const badge = document.getElementById('friend-request-badge');
        if (badge) {
          const requestCount = this.friendRequests.length;
          if (requestCount > 0) {
            badge.style.display = 'flex';
            badge.textContent = requestCount > 9 ? '9+' : requestCount.toString();
          } else {
            badge.style.display = 'none';
          }
        }

        // If friendship UI is visible, ensure it re-renders immediately to show Accept/Decline without manual refresh
        if (typeof FriendsDiscoverySystem !== 'undefined' && FriendsDiscoverySystem.displayUsers) {
          FriendsDiscoverySystem.displayUsers();
        }
      },

      // --- Cooldown system to reduce repeated writes/reads ---
      _cooldowns: new Map(),
      isInCooldown(userId) {
        const until = this._cooldowns.get(userId);
        return until ? Date.now() < until : false;
      },
      setCooldown(userId, durationMs) {
        const until = Date.now() + durationMs;
        this._cooldowns.set(userId, until);
        setTimeout(() => {
          this._cooldowns.delete(userId);
          this.displayUsers();
        }, durationMs);
      },

      // Force refresh specific user card
      forceRefreshUserCard(userId) {
        const userCard = document.querySelector(`[data-user-id="${userId}"]`);
        if (userCard) {
          // Add a brief flash effect to indicate update
          userCard.style.transition = 'all 0.3s ease';
          userCard.style.transform = 'scale(1.02)';
          userCard.style.boxShadow = '0 8px 25px rgba(0,0,0,0.15)';

          setTimeout(() => {
            userCard.style.transform = 'scale(1)';
            userCard.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
          }, 300);
        }
      },

      // Show friend request notification
      showFriendRequestNotification() {
        const requestCount = this.friendRequests.length;
        if (requestCount > 0) {
          NotificationSystem.show(
            `You have ${requestCount} new friend request${requestCount > 1 ? 's' : ''}! Click here to view.`,
            'info',
            5000,
            () => {
              // Navigate to feed page and show friendship section
              showPage('feed');

              // Wait a moment for page to load, then switch to friendship tab
              setTimeout(() => {
                const friendshipTab = document.getElementById('friendship-tab');
                if (friendshipTab) {
                  friendshipTab.click();
                }

                // Also set the filter to show requests
                setTimeout(() => {
                  if (typeof FriendsDiscoverySystem !== 'undefined' && FriendsDiscoverySystem.setFilter) {
                    FriendsDiscoverySystem.setFilter('requests');
                  }
                }, 500);
              }, 100);
            }
          );
        }
      },

      // Check for new friend requests periodically
      startRequestCheck() {
        if (currentFirebaseUser) {
          // Check immediately on login
          setTimeout(async () => {
            await this.loadFriendRequests();
            this.showFriendRequestNotification();
          }, 2000);

          // Real-time friend request checking is now handled by initializeRealtimeSystem()
        }
      },


    };


    // Comprehensive Firebase update function
    async function updateFromFirebase() {
      if (!currentFirebaseUser || !authManager) return;

      try {
        const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

        // Update user profile from Firebase
        const userDoc = await getDoc(doc(authManager.db, 'users', currentFirebaseUser.uid));
        if (userDoc.exists()) {
          const userData = userDoc.data();
          const currentUser = DataLayer.load('currentUser') || {};

          // Update current user data
          const updatedUser = {
            ...currentUser,
            ...userData,
            id: currentFirebaseUser.uid
          };

          DataLayer.save('currentUser', updatedUser);
          console.log('User profile updated from Firebase');
        }

        // Load experiences from Firebase
        const experiencesCollection = collection(authManager.db, 'experiences');
        const experiencesQuery = query(experiencesCollection, where('userId', '==', currentFirebaseUser.uid));
        const experiencesSnapshot = await getDocs(experiencesQuery);

        const userExperiences = [];
        experiencesSnapshot.forEach((doc) => {
          const experienceData = doc.data();
          userExperiences.push({
            id: experienceData.id || doc.id, // Preserve original ID if it exists, otherwise use Firebase doc ID
            firebaseId: doc.id, // Store Firebase document ID separately
            ...experienceData,
            timestamp: experienceData.createdAt?.toDate?.() || new Date()
          });
        });

        DataLayer.save('userExperiences', userExperiences);
        console.log('Experiences loaded from Firebase:', userExperiences.length);

        // Update FriendsDiscoverySystem if it exists
        if (typeof FriendsDiscoverySystem !== 'undefined') {
          await FriendsDiscoverySystem.loadAllUsersOptimized();
          await FriendsDiscoverySystem.loadCurrentFriendsOptimized();
          await FriendsDiscoverySystem.loadFriendRequests();
          await FriendsDiscoverySystem.loadPendingRequests();
          FriendsDiscoverySystem.displayUsers();
        }

        // Update UI if on relevant pages
        if (document.getElementById('dashboard-content')) {
          updateDashboard();
        }
        if (document.getElementById('profile-content')) {
          updateProfile();
        }
        if (document.getElementById('feed-content')) {
          FeedSystem.displayFeed();
        }

        console.log('Firebase update completed');
      } catch (error) {
        console.error('Error updating from Firebase:', error);
      }
    }

    // Enhanced Friends System with Firebase
    const FirebaseFriendsSystem = {
      async addFriend(userId) {
        if (!currentFirebaseUser) {
          NotificationSystem.show('Please sign in to add friends.', 'warning');
          return false;
        }

        try {
          const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          // Create friend request
          const requestData = {
            fromUserId: currentFirebaseUser.uid,
            toUserId: userId,
            status: 'pending',
            createdAt: serverTimestamp()
          };

          await addDoc(collection(authManager.db, 'friendRequests'), requestData);

          NotificationSystem.show('Friend request sent!', 'success');
          return true;
        } catch (error) {
          console.error('Error adding friend:', error);
          NotificationSystem.show('Failed to send friend request.', 'error');
          return false;
        }
      },

      async getFriends() {
        if (!currentFirebaseUser) return [];

        try {
          const { collection, query, where, getDocs, getDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid)),
            query(friendsCollection, where('user2Id', '==', currentFirebaseUser.uid))
          ];

          const friends = [];
          const friendIds = new Set();

          for (const q of queries) {
            const querySnapshot = await getDocs(q);

            for (const docSnap of querySnapshot.docs) {
              const friendshipData = docSnap.data();
              const friendId = friendshipData.user1Id === currentFirebaseUser.uid
                ? friendshipData.user2Id
                : friendshipData.user1Id;

              if (!friendIds.has(friendId)) {
                friendIds.add(friendId);

                const friendDoc = await getDoc(doc(authManager.db, 'users', friendId));
                if (friendDoc.exists()) {
                  friends.push({
                    id: friendDoc.id,
                    ...friendDoc.data()
                  });
                }
              }
            }
          }

          return friends;
        } catch (error) {
          console.error('Error getting friends:', error);
          return [];
        }
      },

      async isFriend(userId) {
        if (!currentFirebaseUser) return false;

        try {
          const { collection, query, where, getDocs } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');

          const friendsCollection = collection(authManager.db, 'friends');
          const queries = [
            query(friendsCollection, where('user1Id', '==', currentFirebaseUser.uid), where('user2Id', '==', userId)),
            query(friendsCollection, where('user1Id', '==', userId), where('user2Id', '==', currentFirebaseUser.uid))
          ];

          for (const q of queries) {
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
              return true;
            }
          }

          return false;
        } catch (error) {
          console.error('Error checking friendship:', error);
          return false;
        }
      }
    };

    // Add keyboard event listeners for Cursor-style login flow
    document.addEventListener('DOMContentLoaded', function () {
      // Email input Enter key
      const emailInput = document.getElementById('login-email');
      if (emailInput) {
        emailInput.addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            handleEmailContinue();
          }
        });
      }

      // Password input Enter key
      const passwordInput = document.getElementById('login-password');
      if (passwordInput) {
        passwordInput.addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            handlePasswordContinue();
          }
        });
      }
    });

    // Final initialization
    console.log("Social Energy App initialized successfully!");
    console.log("Use Alt+1-6 for quick navigation between pages");
    console.log("Firebase app initialized:", {
      users: "Firebase",
      experiences: "Firebase",
      features: [
        "Personality Assessment",
        "Activity Tracking",
        "Social Feed",
        "Group Planning",
        "Personalized Recommendations",
      ],
    });

    // Test if login functions are accessible
    console.log("Testing login functions accessibility:");
    console.log("handleEmailContinue:", typeof window.handleEmailContinue);
    console.log("handleGoogleSignIn:", typeof window.handleGoogleSignIn);
    console.log("handleGitHubSignIn:", typeof window.handleGitHubSignIn);
    console.log("handlePasswordContinue:", typeof window.handlePasswordContinue);

    // Initialize Firebase Auth and show login page by default
    initializeFirebaseAuth().then(() => {
      // Show login page by default for unauthenticated users
      if (!currentFirebaseUser) {
        showPage('login');
      }
    });
  </script>
</body>

</html>